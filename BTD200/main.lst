CCS PCH C Compiler, Version 5.091, 49613               13-Aug-25 15:05

               Filename:   C:\Users\JohnCarloBCarbonel\testSR\BTD200\main.lst

               ROM used:   23608 bytes (18%)
                           Largest free fragment is 65536
               RAM used:   1696 (44%) at main() level
                           2041 (53%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

00000:  GOTO   56DA
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   0726
00068:  BTFSS  FF0.3
0006A:  GOTO   0074
0006E:  BTFSC  FF0.0
00070:  GOTO   031C
00074:  BTFSS  FF0.4
00076:  GOTO   0080
0007A:  BTFSC  FF0.1
0007C:  GOTO   033A
00080:  BTFSS  F9D.5
00082:  GOTO   008C
00086:  BTFSC  F9E.5
00088:  GOTO   02F8
0008C:  BTFSS  FA3.5
0008E:  GOTO   0098
00092:  BTFSC  FA4.5
00094:  GOTO   02C4
00098:  MOVFF  0E,00
0009C:  MOVFF  0F,01
000A0:  MOVFF  10,02
000A4:  MOVFF  11,03
000A8:  MOVFF  0C,FE9
000AC:  MOVFF  07,FEA
000B0:  BSF    07.7
000B2:  MOVFF  08,FE1
000B6:  MOVFF  09,FE2
000BA:  MOVFF  0A,FD9
000BE:  MOVFF  0B,FDA
000C2:  MOVFF  12,FF3
000C6:  MOVFF  13,FF4
000CA:  MOVFF  14,FFA
000CE:  MOVFF  15,FF5
000D2:  MOVFF  16,FF6
000D6:  MOVFF  17,FF7
000DA:  MOVFF  18,FF8
000DE:  MOVFF  19,FFB
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
.................... //Author: Glenn Vincent Lopez
.................... //May 11, 2022
.................... 
.................... #include <18F87K22.h>
.................... //////////// Standard Header file for the PIC18F87K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F87K22
000EE:  CLRF   FF7
000F0:  ADDLW  02
000F2:  MOVWF  FF6
000F4:  MOVLW  01
000F6:  ADDWFC FF7,F
000F8:  MOVLW  00
000FA:  MOVWF  FF8
000FC:  TBLRD*+
000FE:  MOVF   FF5,W
00100:  RETURN 0
00102:  DATA 00,00
00104:  CLRF   FF7
00106:  ADDLW  18
00108:  MOVWF  FF6
0010A:  MOVLW  01
0010C:  ADDWFC FF7,F
0010E:  MOVLW  00
00110:  MOVWF  FF8
00112:  TBLRD*+
00114:  MOVF   FF5,W
00116:  RETURN 0
00118:  DATA 4F,4B
0011A:  DATA 00,00
0011C:  CLRF   FF7
0011E:  ADDLW  30
00120:  MOVWF  FF6
00122:  MOVLW  01
00124:  ADDWFC FF7,F
00126:  MOVLW  00
00128:  MOVWF  FF8
0012A:  TBLRD*+
0012C:  MOVF   FF5,W
0012E:  RETURN 0
00130:  DATA 2F,2C
00132:  DATA 3A,22
00134:  DATA 00,00
00136:  CLRF   FF7
00138:  ADDLW  4A
0013A:  MOVWF  FF6
0013C:  MOVLW  01
0013E:  ADDWFC FF7,F
00140:  MOVLW  00
00142:  MOVWF  FF8
00144:  TBLRD*+
00146:  MOVF   FF5,W
00148:  RETURN 0
0014A:  DATA 42,54
0014C:  DATA 44,72
0014E:  DATA 65,63
00150:  DATA 6F,6E
00152:  DATA 0D,00
00154:  CLRF   FF7
00156:  ADDLW  68
00158:  MOVWF  FF6
0015A:  MOVLW  01
0015C:  ADDWFC FF7,F
0015E:  MOVLW  00
00160:  MOVWF  FF8
00162:  TBLRD*+
00164:  MOVF   FF5,W
00166:  RETURN 0
00168:  DATA 42,54
0016A:  DATA 44,63
0016C:  DATA 6F,6E
0016E:  DATA 0D,00
00170:  CLRF   FF7
00172:  ADDLW  84
00174:  MOVWF  FF6
00176:  MOVLW  01
00178:  ADDWFC FF7,F
0017A:  MOVLW  00
0017C:  MOVWF  FF8
0017E:  TBLRD*+
00180:  MOVF   FF5,W
00182:  RETURN 0
00184:  DATA 42,54
00186:  DATA 44,73
00188:  DATA 74,61
0018A:  DATA 62,6C
0018C:  DATA 65,0D
0018E:  DATA 00,00
00190:  CLRF   FF7
00192:  ADDLW  A4
00194:  MOVWF  FF6
00196:  MOVLW  01
00198:  ADDWFC FF7,F
0019A:  MOVLW  00
0019C:  MOVWF  FF8
0019E:  TBLRD*+
001A0:  MOVF   FF5,W
001A2:  RETURN 0
001A4:  DATA 52,4D
001A6:  DATA 53,2A
001A8:  DATA 00,00
001AA:  CLRF   FF7
001AC:  ADDLW  BE
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  MOVLW  00
001B6:  MOVWF  FF8
001B8:  TBLRD*+
001BA:  MOVF   FF5,W
001BC:  RETURN 0
001BE:  DATA 4E,46
001C0:  DATA 44,2A
001C2:  DATA 00,00
001C4:  CLRF   FF7
001C6:  ADDLW  D8
001C8:  MOVWF  FF6
001CA:  MOVLW  01
001CC:  ADDWFC FF7,F
001CE:  MOVLW  00
001D0:  MOVWF  FF8
001D2:  TBLRD*+
001D4:  MOVF   FF5,W
001D6:  RETURN 0
001D8:  DATA 43,52
001DA:  DATA 53,2A
001DC:  DATA 00,00
001DE:  CLRF   FF7
001E0:  ADDLW  F2
001E2:  MOVWF  FF6
001E4:  MOVLW  01
001E6:  ADDWFC FF7,F
001E8:  MOVLW  00
001EA:  MOVWF  FF8
001EC:  TBLRD*+
001EE:  MOVF   FF5,W
001F0:  RETURN 0
001F2:  DATA 43,57
001F4:  DATA 53,2A
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 2E,2B
0020E:  DATA 00,00
00210:  CLRF   FF7
00212:  ADDLW  24
00214:  MOVWF  FF6
00216:  MOVLW  02
00218:  ADDWFC FF7,F
0021A:  MOVLW  00
0021C:  MOVWF  FF8
0021E:  TBLRD*+
00220:  MOVF   FF5,W
00222:  RETURN 0
00224:  DATA 57,41
00226:  DATA 54,43
00228:  DATA 48,44
0022A:  DATA 4F,47
0022C:  DATA 20,54
0022E:  DATA 49,4D
00230:  DATA 45,4F
00232:  DATA 55,54
00234:  DATA 00,00
00236:  CLRF   FF7
00238:  ADDLW  4A
0023A:  MOVWF  FF6
0023C:  MOVLW  02
0023E:  ADDWFC FF7,F
00240:  MOVLW  00
00242:  MOVWF  FF8
00244:  TBLRD*+
00246:  MOVF   FF5,W
00248:  RETURN 0
0024A:  DATA 46,52
0024C:  DATA 45,53
0024E:  DATA 48,20
00250:  DATA 50,4F
00252:  DATA 57,45
00254:  DATA 52,20
00256:  DATA 55,50
00258:  DATA 21,00
0025A:  CLRF   FF7
0025C:  ADDLW  6E
0025E:  MOVWF  FF6
00260:  MOVLW  02
00262:  ADDWFC FF7,F
00264:  MOVLW  00
00266:  MOVWF  FF8
00268:  TBLRD*+
0026A:  MOVF   FF5,W
0026C:  RETURN 0
0026E:  DATA 53,4F
00270:  DATA 46,54
00272:  DATA 57,41
00274:  DATA 52,45
00276:  DATA 20,52
00278:  DATA 45,53
0027A:  DATA 45,54
0027C:  DATA 2D,00
0027E:  CLRF   FF7
00280:  ADDLW  92
00282:  MOVWF  FF6
00284:  MOVLW  02
00286:  ADDWFC FF7,F
00288:  MOVLW  00
0028A:  MOVWF  FF8
0028C:  TBLRD*+
0028E:  MOVF   FF5,W
00290:  RETURN 0
00292:  DATA 48,41
00294:  DATA 52,44
00296:  DATA 57,41
00298:  DATA 52,45
0029A:  DATA 20,52
0029C:  DATA 45,53
0029E:  DATA 45,54
002A0:  DATA 00,00
002A2:  CLRF   FF7
002A4:  ADDLW  B6
002A6:  MOVWF  FF6
002A8:  MOVLW  02
002AA:  ADDWFC FF7,F
002AC:  MOVLW  00
002AE:  MOVWF  FF8
002B0:  TBLRD*+
002B2:  MOVF   FF5,W
002B4:  RETURN 0
002B6:  DATA 36,33
002B8:  DATA 39,35
002BA:  DATA 36,34
002BC:  DATA 33,33
002BE:  DATA 34,39
002C0:  DATA 31,33
002C2:  DATA 00,00
*
00346:  DATA 41,54
00348:  DATA 2B,43
0034A:  DATA 4F,50
0034C:  DATA 53,3F
0034E:  DATA 0D,00
00350:  DATA 41,54
00352:  DATA 2B,43
00354:  DATA 52,45
00356:  DATA 47,3F
00358:  DATA 0D,00
0035A:  DATA 41,54
0035C:  DATA 0D,00
0035E:  DATA 47,53
00360:  DATA 4D,20
00362:  DATA 6D,6F
00364:  DATA 64,75
00366:  DATA 6C,65
00368:  DATA 20,61
0036A:  DATA 63,74
0036C:  DATA 69,76
0036E:  DATA 65,0A
00370:  DATA 00,00
00372:  DATA 47,53
00374:  DATA 4D,20
00376:  DATA 6D,6F
00378:  DATA 64,75
0037A:  DATA 6C,65
0037C:  DATA 20,6E
0037E:  DATA 6F,20
00380:  DATA 72,65
00382:  DATA 73,70
00384:  DATA 6F,6E
00386:  DATA 73,65
00388:  DATA 0A,00
0038A:  DATA 49,67
0038C:  DATA 6E,69
0038E:  DATA 74,65
00390:  DATA 20,47
00392:  DATA 53,4D
00394:  DATA 20,6D
00396:  DATA 6F,64
00398:  DATA 75,6C
0039A:  DATA 65,0A
0039C:  DATA 00,00
0039E:  DATA 41,54
003A0:  DATA 5E,53
003A2:  DATA 4D,53
003A4:  DATA 4F,0D
003A6:  DATA 00,00
003A8:  DATA 47,53
003AA:  DATA 4D,20
003AC:  DATA 4D,6F
003AE:  DATA 64,75
003B0:  DATA 6C,65
003B2:  DATA 20,53
003B4:  DATA 68,75
003B6:  DATA 74,64
003B8:  DATA 6F,77
003BA:  DATA 6E,0A
003BC:  DATA 00,00
003BE:  DATA 49,6E
003C0:  DATA 69,74
003C2:  DATA 69,61
003C4:  DATA 6C,69
003C6:  DATA 7A,65
003C8:  DATA 20,47
003CA:  DATA 53,4D
003CC:  DATA 20,4D
003CE:  DATA 6F,64
003D0:  DATA 75,6C
003D2:  DATA 65,0A
003D4:  DATA 00,00
003D6:  DATA 43,68
003D8:  DATA 65,63
003DA:  DATA 6B,69
003DC:  DATA 6E,67
003DE:  DATA 20,6E
003E0:  DATA 65,74
003E2:  DATA 77,6F
003E4:  DATA 72,6B
003E6:  DATA 20,72
003E8:  DATA 65,67
003EA:  DATA 69,73
003EC:  DATA 74,72
003EE:  DATA 61,74
003F0:  DATA 69,6F
003F2:  DATA 6E,2C
003F4:  DATA 20,70
003F6:  DATA 6C,65
003F8:  DATA 61,73
003FA:  DATA 65,20
003FC:  DATA 77,61
003FE:  DATA 69,74
00400:  DATA 0A,00
00402:  DATA 52,65
00404:  DATA 67,69
00406:  DATA 73,74
00408:  DATA 65,72
0040A:  DATA 65,64
0040C:  DATA 20,74
0040E:  DATA 6F,20
00410:  DATA 6E,65
00412:  DATA 74,77
00414:  DATA 6F,72
00416:  DATA 6B,3A
00418:  DATA 20,25
0041A:  DATA 73,0A
0041C:  DATA 00,00
0041E:  DATA 4E,65
00420:  DATA 74,77
00422:  DATA 6F,72
00424:  DATA 6B,20
00426:  DATA 72,65
00428:  DATA 67,69
0042A:  DATA 73,74
0042C:  DATA 72,61
0042E:  DATA 74,69
00430:  DATA 6F,6E
00432:  DATA 20,66
00434:  DATA 61,69
00436:  DATA 6C,65
00438:  DATA 64,0A
0043A:  DATA 00,00
0043C:  DATA 50,65
0043E:  DATA 72,66
00440:  DATA 6F,72
00442:  DATA 6D,69
00444:  DATA 6E,67
00446:  DATA 20,47
00448:  DATA 53,4D
0044A:  DATA 20,6D
0044C:  DATA 6F,64
0044E:  DATA 75,6C
00450:  DATA 65,20
00452:  DATA 72,65
00454:  DATA 62,6F
00456:  DATA 6F,74
00458:  DATA 0A,00
0045A:  DATA 41,54
0045C:  DATA 26,46
0045E:  DATA 30,0D
00460:  DATA 00,00
00462:  DATA 41,54
00464:  DATA 45,30
00466:  DATA 0D,00
00468:  DATA 41,54
0046A:  DATA 5E,53
0046C:  DATA 53,59
0046E:  DATA 4E,43
00470:  DATA 3D,31
00472:  DATA 0D,00
00474:  DATA 41,54
00476:  DATA 2B,43
00478:  DATA 4E,4D
0047A:  DATA 49,3D
0047C:  DATA 31,2C
0047E:  DATA 31,2C
00480:  DATA 30,2C
00482:  DATA 30,2C
00484:  DATA 31,0D
00486:  DATA 00,00
00488:  DATA 41,54
0048A:  DATA 2B,43
0048C:  DATA 4D,47
0048E:  DATA 46,3D
00490:  DATA 31,0D
00492:  DATA 00,00
00494:  DATA 41,54
00496:  DATA 2B,43
00498:  DATA 53,4D
0049A:  DATA 53,3D
0049C:  DATA 30,0D
0049E:  DATA 00,00
004A0:  DATA 41,54
004A2:  DATA 2B,43
004A4:  DATA 4C,49
004A6:  DATA 50,3D
004A8:  DATA 31,0D
004AA:  DATA 00,00
004AC:  DATA 41,54
004AE:  DATA 2B,43
004B0:  DATA 50,42
004B2:  DATA 53,3D
004B4:  DATA 4F,4E
004B6:  DATA 0D,00
004B8:  DATA 41,54
004BA:  DATA 2B,43
004BC:  DATA 50,4D
004BE:  DATA 53,3D
004C0:  DATA 4D,54
004C2:  DATA 2C,4D
004C4:  DATA 54,2C
004C6:  DATA 4D,54
004C8:  DATA 0D,00
004CA:  DATA 47,53
004CC:  DATA 4D,20
004CE:  DATA 72,65
004D0:  DATA 61,64
004D2:  DATA 79,0A
004D4:  DATA 00,00
004D6:  DATA 41,54
004D8:  DATA 2B,43
004DA:  DATA 4D,47
004DC:  DATA 44,3D
004DE:  DATA 25,69
004E0:  DATA 0D,00
004E2:  DATA 41,54
004E4:  DATA 2B,43
004E6:  DATA 4D,47
004E8:  DATA 53,3D
004EA:  DATA 25,63
004EC:  DATA 25,73
004EE:  DATA 25,63
004F0:  DATA 2C,31
004F2:  DATA 32,39
004F4:  DATA 0D,00
004F6:  DATA 4D,65
004F8:  DATA 73,73
004FA:  DATA 61,67
004FC:  DATA 65,20
004FE:  DATA 73,65
00500:  DATA 6E,74
00502:  DATA 20,74
00504:  DATA 6F,3A
00506:  DATA 20,25
00508:  DATA 73,0A
0050A:  DATA 00,00
0050C:  DATA 47,53
0050E:  DATA 4D,20
00510:  DATA 65,72
00512:  DATA 72,6F
00514:  DATA 72,20
00516:  DATA 32,3A
00518:  DATA 20,4D
0051A:  DATA 65,73
0051C:  DATA 73,61
0051E:  DATA 67,65
00520:  DATA 20,4E
00522:  DATA 4F,54
00524:  DATA 20,73
00526:  DATA 65,6E
00528:  DATA 74,2E
0052A:  DATA 0A,00
0052C:  DATA 47,53
0052E:  DATA 4D,20
00530:  DATA 54,69
00532:  DATA 6D,65
00534:  DATA 6F,75
00536:  DATA 74,20
00538:  DATA 32,3A
0053A:  DATA 20,4D
0053C:  DATA 65,73
0053E:  DATA 73,61
00540:  DATA 67,65
00542:  DATA 20,4E
00544:  DATA 4F,54
00546:  DATA 20,73
00548:  DATA 65,6E
0054A:  DATA 74,2E
0054C:  DATA 0A,00
0054E:  DATA 47,53
00550:  DATA 4D,20
00552:  DATA 65,72
00554:  DATA 72,6F
00556:  DATA 72,20
00558:  DATA 31,3A
0055A:  DATA 20,20
0055C:  DATA 4D,65
0055E:  DATA 73,73
00560:  DATA 61,67
00562:  DATA 65,20
00564:  DATA 4E,4F
00566:  DATA 54,20
00568:  DATA 73,65
0056A:  DATA 6E,74
0056C:  DATA 2E,0A
0056E:  DATA 00,00
00570:  DATA 47,53
00572:  DATA 4D,20
00574:  DATA 54,69
00576:  DATA 6D,65
00578:  DATA 6F,75
0057A:  DATA 74,20
0057C:  DATA 31,3A
0057E:  DATA 20,4D
00580:  DATA 65,73
00582:  DATA 73,61
00584:  DATA 67,65
00586:  DATA 20,4E
00588:  DATA 4F,54
0058A:  DATA 20,73
0058C:  DATA 65,6E
0058E:  DATA 74,2E
00590:  DATA 0A,00
00592:  DATA 41,54
00594:  DATA 2B,43
00596:  DATA 53,51
00598:  DATA 0D,00
0059A:  DATA 53,4D
0059C:  DATA 53,3A
0059E:  DATA 20,25
005A0:  DATA 73,0A
005A2:  DATA 00,00
005A4:  DATA 54,72
005A6:  DATA 79,20
005A8:  DATA 74,6F
005AA:  DATA 20,73
005AC:  DATA 65,6E
005AE:  DATA 64,20
005B0:  DATA 25,69
005B2:  DATA 20,2D
005B4:  DATA 3E,20
005B6:  DATA 00,00
005B8:  DATA 41,54
005BA:  DATA 2B,43
005BC:  DATA 43,4C
005BE:  DATA 4B,3D
005C0:  DATA 22,25
005C2:  DATA 73,22
005C4:  DATA 0D,00
005C6:  DATA 47,53
005C8:  DATA 4D,20
005CA:  DATA 63,6C
005CC:  DATA 6F,63
005CE:  DATA 6B,20
005D0:  DATA 73,65
005D2:  DATA 74,0A
005D4:  DATA 00,00
005D6:  DATA 47,53
005D8:  DATA 4D,20
005DA:  DATA 63,6C
005DC:  DATA 6F,63
005DE:  DATA 6B,20
005E0:  DATA 4E,4F
005E2:  DATA 54,20
005E4:  DATA 73,65
005E6:  DATA 74,0A
005E8:  DATA 00,00
005EA:  DATA 41,54
005EC:  DATA 2B,43
005EE:  DATA 43,4C
005F0:  DATA 4B,3F
005F2:  DATA 0D,00
005F4:  DATA 69,6E
005F6:  DATA 69,74
005F8:  DATA 0D,00
005FA:  DATA 4C,54
005FC:  DATA 45,20
005FE:  DATA 49,6E
00600:  DATA 69,74
00602:  DATA 69,61
00604:  DATA 6C,69
00606:  DATA 7A,65
00608:  DATA 64,0A
0060A:  DATA 00,00
0060C:  DATA 73,69
0060E:  DATA 67,6E
00610:  DATA 61,6C
00612:  DATA 0D,00
00614:  DATA 0A,53
00616:  DATA 4D,53
00618:  DATA 20,53
0061A:  DATA 65,6E
0061C:  DATA 74,3A
0061E:  DATA 20,25
00620:  DATA 73,0A
00622:  DATA 00,00
00624:  DATA 4F,46
00626:  DATA 46,0D
00628:  DATA 00,00
0062A:  DATA 4F,4E
0062C:  DATA 0D,00
0062E:  DATA 69,67
00630:  DATA 74,0D
00632:  DATA 00,00
00634:  DATA 4C,54
00636:  DATA 45,20
00638:  DATA 49,67
0063A:  DATA 6E,69
0063C:  DATA 74,65
0063E:  DATA 64,0A
00640:  DATA 00,00
00642:  MOVLB  7
00644:  MOVF   xF5,W
00646:  CLRF   01
00648:  SUBWF  xF4,W
0064A:  BC    0652
0064C:  MOVFF  7F4,00
00650:  BRA    066A
00652:  CLRF   00
00654:  MOVLW  08
00656:  MOVWF  xF6
00658:  RLCF   xF4,F
0065A:  RLCF   00,F
0065C:  MOVF   xF5,W
0065E:  SUBWF  00,W
00660:  BTFSC  FD8.0
00662:  MOVWF  00
00664:  RLCF   01,F
00666:  DECFSZ xF6,F
00668:  BRA    0658
0066A:  MOVLB  0
0066C:  RETURN 0
0066E:  CLRF   01
00670:  CLRF   02
00672:  CLRF   00
00674:  CLRF   03
00676:  MOVLB  7
00678:  MOVF   xF7,W
0067A:  BNZ   0680
0067C:  MOVF   xF6,W
0067E:  BZ    06B0
00680:  MOVLW  10
00682:  MOVWF  xF8
00684:  BCF    FD8.0
00686:  RLCF   xF4,F
00688:  RLCF   xF5,F
0068A:  RLCF   00,F
0068C:  RLCF   03,F
0068E:  MOVF   xF7,W
00690:  SUBWF  03,W
00692:  BNZ   0698
00694:  MOVF   xF6,W
00696:  SUBWF  00,W
00698:  BNC   06A8
0069A:  MOVF   xF6,W
0069C:  SUBWF  00,F
0069E:  BTFSS  FD8.0
006A0:  DECF   03,F
006A2:  MOVF   xF7,W
006A4:  SUBWF  03,F
006A6:  BSF    FD8.0
006A8:  RLCF   01,F
006AA:  RLCF   02,F
006AC:  DECFSZ xF8,F
006AE:  BRA    0684
006B0:  MOVLB  0
006B2:  GOTO   06FE (RETURN)
*
00824:  DATA 52,54
00826:  DATA 43,20
00828:  DATA 64,61
0082A:  DATA 74,65
0082C:  DATA 20,61
0082E:  DATA 6E,64
00830:  DATA 20,74
00832:  DATA 69,6D
00834:  DATA 65,3A
00836:  DATA 20,25
00838:  DATA 73,0A
0083A:  DATA 00,00
0083C:  DATA 52,54
0083E:  DATA 43,20
00840:  DATA 75,70
00842:  DATA 64,61
00844:  DATA 74,65
00846:  DATA 64,0A
00848:  DATA 00,00
0084A:  DATA 59,45
0084C:  DATA 41,52
0084E:  DATA 5F,50
00850:  DATA 52,45
00852:  DATA 56,3D
00854:  DATA 25,69
00856:  DATA 0A,00
00858:  DATA 66,72
0085A:  DATA 6F,6D
0085C:  DATA 20,43
0085E:  DATA 4F,55
00860:  DATA 4E,54
00862:  DATA 45,52
00864:  DATA 4E,45
00866:  DATA 57,59
00868:  DATA 45,41
0086A:  DATA 52,20
0086C:  DATA 3D,25
0086E:  DATA 73,0A
00870:  DATA 00,00
00872:  DATA 41,54
00874:  DATA 2B,43
00876:  DATA 43,4C
00878:  DATA 4B,3D
0087A:  DATA 22,25
0087C:  DATA 73,22
0087E:  DATA 0D,00
00880:  DATA 63,6C
00882:  DATA 6F,63
00884:  DATA 6B,20
00886:  DATA 73,65
00888:  DATA 74,0A
0088A:  DATA 00,00
0088C:  DATA 41,54
0088E:  DATA 2B,43
00890:  DATA 43,4C
00892:  DATA 4B,3F
00894:  DATA 0D,00
00896:  DATA 4D,43
00898:  DATA 55,20
0089A:  DATA 63,6C
0089C:  DATA 6F,63
0089E:  DATA 6B,20
008A0:  DATA 73,65
008A2:  DATA 74,0A
008A4:  DATA 00,00
008A6:  DATA 4D,43
008A8:  DATA 55,20
008AA:  DATA 64,61
008AC:  DATA 74,65
008AE:  DATA 20,61
008B0:  DATA 6E,64
008B2:  DATA 20,74
008B4:  DATA 69,6D
008B6:  DATA 65,3A
008B8:  DATA 20,25
008BA:  DATA 73,0A
008BC:  DATA 00,00
008BE:  DATA 20,20
008C0:  DATA 20,20
008C2:  DATA 20,20
008C4:  DATA 44,45
008C6:  DATA 42,55
008C8:  DATA 47,20
008CA:  DATA 4D,4F
008CC:  DATA 44,45
008CE:  DATA 20,4D
008D0:  DATA 45,4E
008D2:  DATA 55,0A
008D4:  DATA 00,00
008D6:  DATA 20,20
008D8:  DATA 20,20
008DA:  DATA 20,20
008DC:  DATA 41,2E
008DE:  DATA 20,20
008E0:  DATA 20,20
008E2:  DATA 20,47
008E4:  DATA 65,74
008E6:  DATA 20,64
008E8:  DATA 61,74
008EA:  DATA 61,20
008EC:  DATA 66,72
008EE:  DATA 6F,6D
008F0:  DATA 20,74
008F2:  DATA 68,65
008F4:  DATA 20,73
008F6:  DATA 65,6E
008F8:  DATA 73,6F
008FA:  DATA 72,0A
008FC:  DATA 00,00
008FE:  DATA 20,20
00900:  DATA 20,20
00902:  DATA 20,20
00904:  DATA 42,2E
00906:  DATA 20,20
00908:  DATA 20,20
0090A:  DATA 20,47
0090C:  DATA 65,74
0090E:  DATA 20,61
00910:  DATA 72,51
00912:  DATA 27,73
00914:  DATA 20,63
00916:  DATA 75,72
00918:  DATA 72,65
0091A:  DATA 6E,74
0091C:  DATA 20,63
0091E:  DATA 6F,6E
00920:  DATA 66,69
00922:  DATA 67,75
00924:  DATA 72,61
00926:  DATA 74,69
00928:  DATA 6F,6E
0092A:  DATA 73,0A
0092C:  DATA 00,00
0092E:  DATA 20,20
00930:  DATA 20,20
00932:  DATA 20,20
00934:  DATA 43,2E
00936:  DATA 20,20
00938:  DATA 20,20
0093A:  DATA 20,44
0093C:  DATA 69,73
0093E:  DATA 70,6C
00940:  DATA 61,79
00942:  DATA 20,44
00944:  DATA 45,42
00946:  DATA 55,47
00948:  DATA 20,6D
0094A:  DATA 65,6E
0094C:  DATA 75,0A
0094E:  DATA 00,00
00950:  DATA 20,20
00952:  DATA 20,20
00954:  DATA 20,20
00956:  DATA 44,2E
00958:  DATA 20,20
0095A:  DATA 20,20
0095C:  DATA 20,43
0095E:  DATA 68,61
00960:  DATA 6E,67
00962:  DATA 65,20
00964:  DATA 73,65
00966:  DATA 6E,64
00968:  DATA 69,6E
0096A:  DATA 67,20
0096C:  DATA 74,69
0096E:  DATA 6D,65
00970:  DATA 0A,00
00972:  DATA 20,20
00974:  DATA 20,20
00976:  DATA 20,20
00978:  DATA 45,2E
0097A:  DATA 20,20
0097C:  DATA 20,20
0097E:  DATA 20,43
00980:  DATA 68,65
00982:  DATA 63,6B
00984:  DATA 20,73
00986:  DATA 61,74
00988:  DATA 65,6C
0098A:  DATA 6C,69
0098C:  DATA 74,65
0098E:  DATA 20,73
00990:  DATA 65,6E
00992:  DATA 64,69
00994:  DATA 6E,67
00996:  DATA 0A,00
00998:  DATA 20,20
0099A:  DATA 20,20
0099C:  DATA 20,20
0099E:  DATA 46,2E
009A0:  DATA 20,20
009A2:  DATA 20,20
009A4:  DATA 20,53
009A6:  DATA 65,74
009A8:  DATA 20,73
009AA:  DATA 65,72
009AC:  DATA 76,65
009AE:  DATA 72,20
009B0:  DATA 6E,75
009B2:  DATA 6D,62
009B4:  DATA 65,72
009B6:  DATA 0A,00
009B8:  DATA 20,20
009BA:  DATA 20,20
009BC:  DATA 20,20
009BE:  DATA 47,2E
009C0:  DATA 20,20
009C2:  DATA 20,20
009C4:  DATA 20,4C
009C6:  DATA 69,73
009C8:  DATA 74,20
009CA:  DATA 72,65
009CC:  DATA 67,69
009CE:  DATA 73,74
009D0:  DATA 65,72
009D2:  DATA 65,64
009D4:  DATA 20,6E
009D6:  DATA 75,6D
009D8:  DATA 62,65
009DA:  DATA 72,73
009DC:  DATA 0A,00
009DE:  DATA 20,20
009E0:  DATA 20,20
009E2:  DATA 20,20
009E4:  DATA 48,2E
009E6:  DATA 20,20
009E8:  DATA 20,20
009EA:  DATA 20,47
009EC:  DATA 65,6E
009EE:  DATA 65,72
009F0:  DATA 61,74
009F2:  DATA 65,20
009F4:  DATA 43,52
009F6:  DATA 43,20
009F8:  DATA 63,6F
009FA:  DATA 64,65
009FC:  DATA 0A,00
009FE:  DATA 20,20
00A00:  DATA 20,20
00A02:  DATA 20,20
00A04:  DATA 49,2E
00A06:  DATA 20,20
00A08:  DATA 20,20
00A0A:  DATA 20,53
00A0C:  DATA 65,74
00A0E:  DATA 20,64
00A10:  DATA 61,74
00A12:  DATA 65,20
00A14:  DATA 61,6E
00A16:  DATA 64,20
00A18:  DATA 74,69
00A1A:  DATA 6D,65
00A1C:  DATA 0A,00
00A1E:  DATA 20,20
00A20:  DATA 20,20
00A22:  DATA 20,20
00A24:  DATA 4A,2E
00A26:  DATA 20,20
00A28:  DATA 20,20
00A2A:  DATA 20,53
00A2C:  DATA 65,74
00A2E:  DATA 20,70
00A30:  DATA 6F,77
00A32:  DATA 65,72
00A34:  DATA 20,62
00A36:  DATA 6F,61
00A38:  DATA 72,64
00A3A:  DATA 20,63
00A3C:  DATA 6F,6E
00A3E:  DATA 66,69
00A40:  DATA 67,75
00A42:  DATA 72,61
00A44:  DATA 74,69
00A46:  DATA 6F,6E
00A48:  DATA 0A,00
00A4A:  DATA 20,20
00A4C:  DATA 20,20
00A4E:  DATA 20,20
00A50:  DATA 4C,2E
00A52:  DATA 20,20
00A54:  DATA 20,20
00A56:  DATA 20,44
00A58:  DATA 6F,77
00A5A:  DATA 6E,6C
00A5C:  DATA 6F,61
00A5E:  DATA 64,20
00A60:  DATA 64,61
00A62:  DATA 74,61
00A64:  DATA 20,66
00A66:  DATA 72,6F
00A68:  DATA 6D,20
00A6A:  DATA 66,6C
00A6C:  DATA 61,73
00A6E:  DATA 68,20
00A70:  DATA 6D,65
00A72:  DATA 6D,6F
00A74:  DATA 72,79
00A76:  DATA 0A,00
00A78:  DATA 20,20
00A7A:  DATA 20,20
00A7C:  DATA 20,20
00A7E:  DATA 4D,2E
00A80:  DATA 20,20
00A82:  DATA 20,20
00A84:  DATA 20,43
00A86:  DATA 68,61
00A88:  DATA 6E,67
00A8A:  DATA 65,20
00A8C:  DATA 70,61
00A8E:  DATA 73,73
00A90:  DATA 77,6F
00A92:  DATA 72,64
00A94:  DATA 0A,00
00A96:  DATA 20,20
00A98:  DATA 20,20
00A9A:  DATA 20,20
00A9C:  DATA 4E,2E
00A9E:  DATA 20,20
00AA0:  DATA 20,20
00AA2:  DATA 20,45
00AA4:  DATA 6E,61
00AA6:  DATA 62,6C
00AA8:  DATA 65,20
00AAA:  DATA 73,61
00AAC:  DATA 74,65
00AAE:  DATA 6C,6C
00AB0:  DATA 69,74
00AB2:  DATA 65,0A
00AB4:  DATA 00,00
00AB6:  DATA 20,20
00AB8:  DATA 20,20
00ABA:  DATA 20,20
00ABC:  DATA 4F,2E
00ABE:  DATA 20,20
00AC0:  DATA 20,20
00AC2:  DATA 20,53
00AC4:  DATA 65,74
00AC6:  DATA 20,74
00AC8:  DATA 68,65
00ACA:  DATA 20,73
00ACC:  DATA 65,6E
00ACE:  DATA 73,6F
00AD0:  DATA 72,20
00AD2:  DATA 74,79
00AD4:  DATA 70,65
00AD6:  DATA 0A,00
00AD8:  DATA 20,20
00ADA:  DATA 20,20
00ADC:  DATA 20,20
00ADE:  DATA 51,2E
00AE0:  DATA 20,20
00AE2:  DATA 20,20
00AE4:  DATA 54,65
00AE6:  DATA 73,74
00AE8:  DATA 20,49
00AEA:  DATA 72,69
00AEC:  DATA 64,69
00AEE:  DATA 75,6D
00AF0:  DATA 20,73
00AF2:  DATA 61,74
00AF4:  DATA 65,6C
00AF6:  DATA 6C,69
00AF8:  DATA 74,65
00AFA:  DATA 20,63
00AFC:  DATA 6F,6D
00AFE:  DATA 6D,61
00B00:  DATA 6E,64
00B02:  DATA 73,0A
00B04:  DATA 00,00
00B06:  DATA 20,20
00B08:  DATA 20,20
00B0A:  DATA 20,20
00B0C:  DATA 53,2E
00B0E:  DATA 20,20
00B10:  DATA 20,20
00B12:  DATA 20,54
00B14:  DATA 75,72
00B16:  DATA 6E,20
00B18:  DATA 6F,66
00B1A:  DATA 66,20
00B1C:  DATA 77,61
00B1E:  DATA 74,63
00B20:  DATA 68,64
00B22:  DATA 6F,67
00B24:  DATA 0A,00
00B26:  DATA 20,20
00B28:  DATA 20,20
00B2A:  DATA 20,20
00B2C:  DATA 57,2E
00B2E:  DATA 20,20
00B30:  DATA 20,20
00B32:  DATA 20,45
00B34:  DATA 78,69
00B36:  DATA 74,20
00B38:  DATA 44,45
00B3A:  DATA 42,55
00B3C:  DATA 47,20
00B3E:  DATA 6D,6F
00B40:  DATA 64,65
00B42:  DATA 0A,00
00B44:  DATA 20,20
00B46:  DATA 20,20
00B48:  DATA 20,20
00B4A:  DATA 58,2E
00B4C:  DATA 20,20
00B4E:  DATA 20,20
00B50:  DATA 20,44
00B52:  DATA 65,6C
00B54:  DATA 65,74
00B56:  DATA 65,20
00B58:  DATA 72,65
00B5A:  DATA 67,69
00B5C:  DATA 73,74
00B5E:  DATA 65,72
00B60:  DATA 65,64
00B62:  DATA 20,6E
00B64:  DATA 75,6D
00B66:  DATA 62,65
00B68:  DATA 72,0A
00B6A:  DATA 00,00
00B6C:  DATA 20,20
00B6E:  DATA 20,20
00B70:  DATA 20,20
00B72:  DATA 61,2E
00B74:  DATA 20,20
00B76:  DATA 20,20
00B78:  DATA 20,52
00B7A:  DATA 65,67
00B7C:  DATA 69,73
00B7E:  DATA 74,65
00B80:  DATA 72,20
00B82:  DATA 6E,75
00B84:  DATA 6D,62
00B86:  DATA 65,72
00B88:  DATA 0A,00
00B8A:  DATA 0A,45
00B8C:  DATA 6E,74
00B8E:  DATA 65,72
00B90:  DATA 20,43
00B92:  DATA 68,6F
00B94:  DATA 69,63
00B96:  DATA 65,3A
00B98:  DATA 0A,00
00B9A:  DATA 50,72
00B9C:  DATA 65,73
00B9E:  DATA 73,20
00BA0:  DATA 43,20
00BA2:  DATA 74,6F
00BA4:  DATA 20,63
00BA6:  DATA 68,61
00BA8:  DATA 6E,67
00BAA:  DATA 65,0A
00BAC:  DATA 00,00
00BAE:  DATA 45,6E
00BB0:  DATA 74,65
00BB2:  DATA 72,20
00BB4:  DATA 44,61
00BB6:  DATA 74,65
00BB8:  DATA 20,61
00BBA:  DATA 6E,64
00BBC:  DATA 20,54
00BBE:  DATA 69,6D
00BC0:  DATA 65,20
00BC2:  DATA 28,46
00BC4:  DATA 4F,52
00BC6:  DATA 4D,41
00BC8:  DATA 54,20
00BCA:  DATA 22,59
00BCC:  DATA 59,2F
00BCE:  DATA 4D,4D
00BD0:  DATA 2F,44
00BD2:  DATA 44,2C
00BD4:  DATA 48,48
00BD6:  DATA 3A,4D
00BD8:  DATA 4D,3A
00BDA:  DATA 53,53
00BDC:  DATA 22,29
00BDE:  DATA 00,00
00BE0:  DATA 50,6C
00BE2:  DATA 65,61
00BE4:  DATA 73,65
00BE6:  DATA 20,63
00BE8:  DATA 68,6F
00BEA:  DATA 6F,73
00BEC:  DATA 65,20
00BEE:  DATA 61,6E
00BF0:  DATA 6F,74
00BF2:  DATA 68,65
00BF4:  DATA 72,20
00BF6:  DATA 6C,65
00BF8:  DATA 74,74
00BFA:  DATA 65,72
00BFC:  DATA 20,66
00BFE:  DATA 72,6F
00C00:  DATA 6D,20
00C02:  DATA 74,68
00C04:  DATA 65,20
00C06:  DATA 44,45
00C08:  DATA 42,55
00C0A:  DATA 47,20
00C0C:  DATA 6D,65
00C0E:  DATA 6E,75
00C10:  DATA 0A,00
00C12:  DATA 41,53
00C14:  DATA 33,39
00C16:  DATA 33,35
00C18:  DATA 20,52
00C1A:  DATA 65,61
00C1C:  DATA 64,79
00C1E:  DATA 0A,00
00C20:  DATA 0A,4C
00C22:  DATA 69,67
00C24:  DATA 68,74
00C26:  DATA 6E,69
00C28:  DATA 6E,67
00C2A:  DATA 20,44
00C2C:  DATA 65,74
00C2E:  DATA 65,63
00C30:  DATA 74,65
00C32:  DATA 64,21
00C34:  DATA 21,21
00C36:  DATA 0A,2A
00C38:  DATA 2A,2A
00C3A:  DATA 2A,2A
00C3C:  DATA 2A,2A
00C3E:  DATA 2A,2A
00C40:  DATA 2A,2A
00C42:  DATA 2A,2A
00C44:  DATA 2A,2A
00C46:  DATA 2A,2A
00C48:  DATA 2A,2A
00C4A:  DATA 2A,2A
00C4C:  DATA 2A,2A
00C4E:  DATA 2A,2A
00C50:  DATA 2A,2A
00C52:  DATA 2A,2A
00C54:  DATA 2A,2A
00C56:  DATA 2A,2A
00C58:  DATA 2A,2A
00C5A:  DATA 2A,2A
00C5C:  DATA 2A,2A
00C5E:  DATA 2A,2A
00C60:  DATA 2A,2A
00C62:  DATA 2A,2A
00C64:  DATA 2A,2A
00C66:  DATA 2A,2A
00C68:  DATA 2A,2A
00C6A:  DATA 2A,2A
00C6C:  DATA 2A,2A
00C6E:  DATA 2A,2A
00C70:  DATA 2A,2A
00C72:  DATA 2A,2A
00C74:  DATA 2A,2A
00C76:  DATA 2A,2A
00C78:  DATA 2A,2A
00C7A:  DATA 2A,2A
00C7C:  DATA 2A,2A
00C7E:  DATA 2A,2A
00C80:  DATA 2A,2A
00C82:  DATA 2A,2A
00C84:  DATA 2A,2A
00C86:  DATA 2A,2A
00C88:  DATA 2A,2A
00C8A:  DATA 2A,2A
00C8C:  DATA 2A,2A
00C8E:  DATA 2A,2A
00C90:  DATA 2A,2A
00C92:  DATA 2A,2A
00C94:  DATA 2A,2A
00C96:  DATA 2A,2A
00C98:  DATA 2A,2A
00C9A:  DATA 2A,2A
00C9C:  DATA 2A,2A
00C9E:  DATA 2A,2A
00CA0:  DATA 2A,2A
00CA2:  DATA 2A,2A
00CA4:  DATA 2A,2A
00CA6:  DATA 2A,2A
00CA8:  DATA 2A,2A
00CAA:  DATA 2A,2A
00CAC:  DATA 2A,2A
00CAE:  DATA 2A,2A
00CB0:  DATA 2A,2A
00CB2:  DATA 2A,2A
00CB4:  DATA 2A,2A
00CB6:  DATA 2A,2A
00CB8:  DATA 2A,2A
00CBA:  DATA 2A,2A
00CBC:  DATA 2A,2A
00CBE:  DATA 2A,2A
00CC0:  DATA 2A,2A
00CC2:  DATA 2A,2A
00CC4:  DATA 2A,2A
00CC6:  DATA 2A,2A
00CC8:  DATA 2A,2A
00CCA:  DATA 2A,2A
00CCC:  DATA 2A,00
00CCE:  DATA 46,43
00CD0:  DATA 3A,25
00CD2:  DATA 73,2B
00CD4:  DATA 25,73
00CD6:  DATA 47,53
00CD8:  DATA 3A,2A
00CDA:  DATA 2B,42
00CDC:  DATA 54,3A
00CDE:  DATA 25,73
00CE0:  DATA 2B,44
00CE2:  DATA 54,3A
00CE4:  DATA 2A,0D
00CE6:  DATA 00,00
00CE8:  DATA 53,4D
00CEA:  DATA 53,20
00CEC:  DATA 74,6F
00CEE:  DATA 20,53
00CF0:  DATA 65,6E
00CF2:  DATA 74,3A
00CF4:  DATA 20,25
00CF6:  DATA 73,00
00CF8:  DATA 44,61
00CFA:  DATA 74,65
00CFC:  DATA 2D,54
00CFE:  DATA 69,6D
00D00:  DATA 65,3A
00D02:  DATA 20,25
00D04:  DATA 73,0A
00D06:  DATA 00,00
00D08:  DATA 53,4D
00D0A:  DATA 53,20
00D0C:  DATA 74,6F
00D0E:  DATA 20,53
00D10:  DATA 65,6E
00D12:  DATA 74,3A
00D14:  DATA 20,25
00D16:  DATA 73,00
00D18:  DATA 44,61
00D1A:  DATA 74,65
00D1C:  DATA 2D,54
00D1E:  DATA 69,6D
00D20:  DATA 65,3A
00D22:  DATA 20,25
00D24:  DATA 73,0A
00D26:  DATA 00,00
00D28:  DATA 53,4D
00D2A:  DATA 53,20
00D2C:  DATA 74,6F
00D2E:  DATA 20,53
00D30:  DATA 65,6E
00D32:  DATA 74,3A
00D34:  DATA 20,25
00D36:  DATA 73,00
00D38:  DATA 44,61
00D3A:  DATA 74,65
00D3C:  DATA 2D,54
00D3E:  DATA 69,6D
00D40:  DATA 65,3A
00D42:  DATA 20,25
00D44:  DATA 73,0A
00D46:  DATA 00,00
00D48:  DATA 53,4D
00D4A:  DATA 53,20
00D4C:  DATA 74,6F
00D4E:  DATA 20,53
00D50:  DATA 65,6E
00D52:  DATA 74,3A
00D54:  DATA 20,25
00D56:  DATA 73,00
00D58:  DATA 44,61
00D5A:  DATA 74,65
00D5C:  DATA 2D,54
00D5E:  DATA 69,6D
00D60:  DATA 65,3A
00D62:  DATA 20,25
00D64:  DATA 73,0A
00D66:  DATA 00,00
00D68:  DATA 53,4D
00D6A:  DATA 53,20
00D6C:  DATA 74,6F
00D6E:  DATA 20,53
00D70:  DATA 65,6E
00D72:  DATA 74,3A
00D74:  DATA 20,25
00D76:  DATA 73,00
00D78:  DATA 44,61
00D7A:  DATA 74,65
00D7C:  DATA 2D,54
00D7E:  DATA 69,6D
00D80:  DATA 65,3A
00D82:  DATA 20,25
00D84:  DATA 73,0A
00D86:  DATA 00,00
00D88:  DATA 53,4D
00D8A:  DATA 53,20
00D8C:  DATA 74,6F
00D8E:  DATA 20,53
00D90:  DATA 65,6E
00D92:  DATA 74,3A
00D94:  DATA 20,25
00D96:  DATA 73,00
00D98:  DATA 0A,41
00D9A:  DATA 52,51
00D9C:  DATA 20,41
00D9E:  DATA 63,63
00DA0:  DATA 65,70
00DA2:  DATA 74,73
00DA4:  DATA 20,52
00DA6:  DATA 65,71
00DA8:  DATA 75,65
00DAA:  DATA 73,74
00DAC:  DATA 0A,00
00DAE:  DATA 4D,65
00DB0:  DATA 73,73
00DB2:  DATA 61,67
00DB4:  DATA 65,20
00DB6:  DATA 4E,75
00DB8:  DATA 6D,62
00DBA:  DATA 65,72
00DBC:  DATA 20,3D
00DBE:  DATA 20,25
00DC0:  DATA 69,0A
00DC2:  DATA 00,00
00DC4:  DATA 0A,4D
00DC6:  DATA 65,73
00DC8:  DATA 73,61
00DCA:  DATA 67,65
00DCC:  DATA 20,4E
00DCE:  DATA 75,6D
00DD0:  DATA 62,65
00DD2:  DATA 72,20
00DD4:  DATA 3D,20
00DD6:  DATA 25,69
00DD8:  DATA 0A,00
00DDA:  DATA 0A,4D
00DDC:  DATA 65,73
00DDE:  DATA 73,61
00DE0:  DATA 67,65
00DE2:  DATA 20,4E
00DE4:  DATA 75,6D
00DE6:  DATA 62,65
00DE8:  DATA 72,20
00DEA:  DATA 3D,20
00DEC:  DATA 25,69
00DEE:  DATA 0A,00
00DF0:  DATA 4C,54
00DF2:  DATA 25,69
00DF4:  DATA 3A,25
00DF6:  DATA 30,2E
00DF8:  DATA 33,66
00DFA:  DATA 2B,4C
00DFC:  DATA 4E,25
00DFE:  DATA 69,3A
00E00:  DATA 25,30
00E02:  DATA 2E,33
00E04:  DATA 66,2B
00E06:  DATA 00,00
00E08:  DATA 4C,54
00E0A:  DATA 25,69
00E0C:  DATA 3A,25
00E0E:  DATA 73,2B
00E10:  DATA 4C,4E
00E12:  DATA 25,69
00E14:  DATA 3A,25
00E16:  DATA 73,2B
00E18:  DATA 00,00
00E1A:  DATA 30,30
00E1C:  DATA 2E,30
00E1E:  DATA 30,30
00E20:  DATA 00,00
00E22:  DATA 30,30
00E24:  DATA 30,2E
00E26:  DATA 30,30
00E28:  DATA 30,00
00E2A:  DATA 44,61
00E2C:  DATA 74,65
00E2E:  DATA 2D,54
00E30:  DATA 69,6D
00E32:  DATA 65,3A
00E34:  DATA 20,25
00E36:  DATA 73,0A
00E38:  DATA 00,00
00E3A:  DATA 57,61
00E3C:  DATA 72,6E
00E3E:  DATA 69,6E
00E40:  DATA 67,20
00E42:  DATA 2D,20
00E44:  DATA 46,6C
00E46:  DATA 61,73
00E48:  DATA 68,20
00E4A:  DATA 43,6F
00E4C:  DATA 75,6E
00E4E:  DATA 74,3A
00E50:  DATA 20,25
00E52:  DATA 58,20
00E54:  DATA 20,00
00E56:  DATA 4F,54
00E58:  DATA 48,45
00E5A:  DATA 52,20
00E5C:  DATA 52,45
00E5E:  DATA 53,45
00E60:  DATA 54,20
00E62:  DATA 43,41
00E64:  DATA 55,53
00E66:  DATA 45,20
00E68:  DATA 28,25
00E6A:  DATA 69,29
00E6C:  DATA 00,00
00E6E:  DATA 25,73
00E70:  DATA 20,2D
00E72:  DATA 20,25
00E74:  DATA 73,00
00E76:  DATA 0A,2A
00E78:  DATA 2A,2A
00E7A:  DATA 2A,2A
00E7C:  DATA 2A,2A
00E7E:  DATA 2A,2A
00E80:  DATA 2A,2A
00E82:  DATA 2A,2A
00E84:  DATA 2A,2A
00E86:  DATA 2A,2A
00E88:  DATA 2A,2A
00E8A:  DATA 2A,2A
00E8C:  DATA 2A,2A
00E8E:  DATA 2A,2A
00E90:  DATA 2A,2A
00E92:  DATA 2A,2A
00E94:  DATA 2A,2A
00E96:  DATA 2A,2A
00E98:  DATA 2A,2A
00E9A:  DATA 2A,2A
00E9C:  DATA 2A,2A
00E9E:  DATA 2A,2A
00EA0:  DATA 2A,2A
00EA2:  DATA 2A,2A
00EA4:  DATA 2A,2A
00EA6:  DATA 2A,2A
00EA8:  DATA 0A,00
00EAA:  DATA 55,4C
00EAC:  DATA 41,54
00EAE:  DATA 20,4C
00EB0:  DATA 69,67
00EB2:  DATA 68,74
00EB4:  DATA 6E,69
00EB6:  DATA 6E,67
00EB8:  DATA 20,4D
00EBA:  DATA 6F,6E
00EBC:  DATA 69,74
00EBE:  DATA 6F,72
00EC0:  DATA 69,6E
00EC2:  DATA 67,20
00EC4:  DATA 53,74
00EC6:  DATA 61,74
00EC8:  DATA 69,6F
00ECA:  DATA 6E,20
00ECC:  DATA 28,42
00ECE:  DATA 65,74
00ED0:  DATA 61,20
00ED2:  DATA 76,65
00ED4:  DATA 72,73
00ED6:  DATA 69,6F
00ED8:  DATA 6E,29
00EDA:  DATA 0A,00
00EDC:  DATA 0A,49
00EDE:  DATA 6E,69
00EE0:  DATA 74,69
00EE2:  DATA 61,6C
00EE4:  DATA 69,7A
00EE6:  DATA 69,6E
00EE8:  DATA 67,20
00EEA:  DATA 42,54
00EEC:  DATA 44,32
00EEE:  DATA 30,30
00EF0:  DATA 0A,00
00EF2:  DATA 44,45
00EF4:  DATA 42,55
00EF6:  DATA 47,20
00EF8:  DATA 4D,4F
00EFA:  DATA 44,45
00EFC:  DATA 00,00
00EFE:  DATA 52,65
00F00:  DATA 73,65
00F02:  DATA 74,20
00F04:  DATA 4D,43
00F06:  DATA 55,0A
00F08:  DATA 00,00
00F0A:  DATA 54,69
00F0C:  DATA 6D,65
00F0E:  DATA 20,53
00F10:  DATA 79,6E
00F12:  DATA 63,0A
00F14:  DATA 00,00
*
00F40:  TBLRD*+
00F42:  MOVF   FF5,F
00F44:  BZ    0F6C
00F46:  MOVFF  FF6,790
00F4A:  MOVFF  FF7,791
00F4E:  MOVFF  FF8,792
00F52:  MOVF   FF5,W
00F54:  BTFSS  FA4.4
00F56:  BRA    0F54
00F58:  MOVLB  F
00F5A:  MOVWF  x1C
00F5C:  MOVFF  790,FF6
00F60:  MOVFF  791,FF7
00F64:  MOVFF  792,FF8
00F68:  MOVLB  0
00F6A:  BRA    0F40
00F6C:  RETURN 0
*
00F8C:  MOVFF  490,FEA
00F90:  MOVFF  48F,FE9
00F94:  MOVLB  7
00F96:  MOVFF  7BC,FEF
00F9A:  INCF   FE9,F
00F9C:  BTFSC  FD8.2
00F9E:  INCF   FEA,F
00FA0:  CLRF   FEF
00FA2:  MOVLB  4
00FA4:  INCF   x8F,F
00FA6:  BTFSC  FD8.2
00FA8:  INCF   x90,F
00FAA:  MOVLB  0
00FAC:  RETURN 0
00FAE:  TBLRD*+
00FB0:  MOVFF  FF6,7B0
00FB4:  MOVFF  FF7,7B1
00FB8:  MOVFF  FF8,7B2
00FBC:  MOVFF  FF5,7BC
00FC0:  RCALL  0F8C
00FC2:  MOVFF  7B0,FF6
00FC6:  MOVFF  7B1,FF7
00FCA:  MOVFF  7B2,FF8
00FCE:  MOVLB  7
00FD0:  DECFSZ xAF,F
00FD2:  BRA    0FD6
00FD4:  BRA    0FDA
00FD6:  MOVLB  0
00FD8:  BRA    0FAE
00FDA:  MOVLB  0
00FDC:  RETURN 0
00FDE:  MOVLW  20
00FE0:  MOVLB  7
00FE2:  BTFSS  xB0.4
00FE4:  MOVLW  30
00FE6:  MOVWF  xB1
00FE8:  MOVFF  7AF,00
00FEC:  BTFSS  00.7
00FEE:  BRA    1000
00FF0:  COMF   00,F
00FF2:  INCF   00,F
00FF4:  MOVFF  00,7AF
00FF8:  MOVLW  2D
00FFA:  MOVWF  xB1
00FFC:  BSF    xB0.7
00FFE:  BSF    xB0.0
01000:  MOVF   01,W
01002:  CLRF   1B
01004:  BTFSC  FF2.7
01006:  BSF    1B.7
01008:  BCF    FF2.7
0100A:  MOVFF  7AF,7F4
0100E:  MOVLW  64
01010:  MOVWF  xF5
01012:  MOVLB  0
01014:  CALL   0642
01018:  BTFSC  1B.7
0101A:  BSF    FF2.7
0101C:  MOVFF  00,7AF
01020:  MOVLW  30
01022:  ADDWF  01,W
01024:  MOVLB  7
01026:  MOVWF  xB2
01028:  CLRF   1B
0102A:  BTFSC  FF2.7
0102C:  BSF    1B.7
0102E:  BCF    FF2.7
01030:  MOVFF  7AF,7F4
01034:  MOVLW  0A
01036:  MOVWF  xF5
01038:  MOVLB  0
0103A:  CALL   0642
0103E:  BTFSC  1B.7
01040:  BSF    FF2.7
01042:  MOVLW  30
01044:  ADDWF  00,W
01046:  MOVLB  7
01048:  MOVWF  xB4
0104A:  MOVLW  30
0104C:  ADDWF  01,W
0104E:  MOVWF  xB3
01050:  MOVFF  7B1,00
01054:  MOVLW  30
01056:  SUBWF  xB2,W
01058:  BZ    1062
0105A:  BSF    xB0.1
0105C:  BTFSC  xB0.7
0105E:  BSF    xB0.2
01060:  BRA    1086
01062:  MOVFF  7B1,7B2
01066:  MOVLW  20
01068:  MOVWF  xB1
0106A:  MOVLW  30
0106C:  SUBWF  xB3,W
0106E:  BZ    1078
01070:  BSF    xB0.0
01072:  BTFSC  xB0.7
01074:  BSF    xB0.1
01076:  BRA    1086
01078:  BTFSS  FD8.2
0107A:  BSF    xB0.0
0107C:  BNZ   1086
0107E:  MOVFF  7B2,7B3
01082:  MOVLW  20
01084:  MOVWF  xB2
01086:  BTFSC  xB0.2
01088:  BRA    1094
0108A:  BTFSC  xB0.1
0108C:  BRA    109C
0108E:  BTFSC  xB0.0
01090:  BRA    10A4
01092:  BRA    10AC
01094:  MOVFF  7B1,7BC
01098:  MOVLB  0
0109A:  RCALL  0F8C
0109C:  MOVFF  7B2,7BC
010A0:  MOVLB  0
010A2:  RCALL  0F8C
010A4:  MOVFF  7B3,7BC
010A8:  MOVLB  0
010AA:  RCALL  0F8C
010AC:  MOVFF  7B4,7BC
010B0:  MOVLB  0
010B2:  RCALL  0F8C
010B4:  RETURN 0
010B6:  MOVF   FEF,F
010B8:  BZ    10DE
010BA:  MOVFF  FEA,76B
010BE:  MOVFF  FE9,76A
010C2:  MOVF   FEF,W
010C4:  BTFSS  FA4.4
010C6:  BRA    10C4
010C8:  MOVLB  F
010CA:  MOVWF  x1C
010CC:  MOVFF  76B,FEA
010D0:  MOVFF  76A,FE9
010D4:  INCF   FE9,F
010D6:  BTFSC  FD8.2
010D8:  INCF   FEA,F
010DA:  MOVLB  0
010DC:  BRA    10B6
010DE:  RETURN 0
*
01322:  MOVF   FEF,F
01324:  BZ    1344
01326:  MOVFF  FEA,769
0132A:  MOVFF  FE9,768
0132E:  MOVFF  FEF,7BC
01332:  RCALL  0F8C
01334:  MOVFF  769,FEA
01338:  MOVFF  768,FE9
0133C:  INCF   FE9,F
0133E:  BTFSC  FD8.2
01340:  INCF   FEA,F
01342:  BRA    1322
01344:  RETURN 0
*
014F2:  MOVLB  7
014F4:  BTFSC  x63.7
014F6:  BRA    151C
014F8:  MOVLW  0F
014FA:  MOVWF  00
014FC:  SWAPF  x62,W
014FE:  ANDWF  00,F
01500:  MOVLW  0A
01502:  SUBWF  00,W
01504:  BC    150C
01506:  MOVLW  30
01508:  ADDWF  00,F
0150A:  BRA    1510
0150C:  MOVF   x63,W
0150E:  ADDWF  00,F
01510:  MOVF   00,W
01512:  BTFSS  FA4.4
01514:  BRA    1512
01516:  MOVLB  F
01518:  MOVWF  x1C
0151A:  MOVLB  7
0151C:  MOVLW  0F
0151E:  ANDWF  x62,F
01520:  MOVLW  0A
01522:  SUBWF  x62,W
01524:  BC    152A
01526:  MOVLW  30
01528:  BRA    152E
0152A:  BCF    x63.7
0152C:  MOVF   x63,W
0152E:  ADDWF  x62,F
01530:  MOVF   x62,W
01532:  BTFSS  FA4.4
01534:  BRA    1532
01536:  MOVLB  F
01538:  MOVWF  x1C
0153A:  MOVLB  0
0153C:  RETURN 0
*
0157A:  TBLRD*+
0157C:  MOVFF  FF6,791
01580:  MOVFF  FF7,792
01584:  MOVFF  FF8,793
01588:  MOVF   FF5,W
0158A:  BTFSS  FA4.4
0158C:  BRA    158A
0158E:  MOVLB  F
01590:  MOVWF  x1C
01592:  MOVFF  791,FF6
01596:  MOVFF  792,FF7
0159A:  MOVFF  793,FF8
0159E:  MOVLB  7
015A0:  DECFSZ x90,F
015A2:  BRA    15A6
015A4:  BRA    15AA
015A6:  MOVLB  0
015A8:  BRA    157A
015AA:  MOVLB  0
015AC:  RETURN 0
015AE:  MOVF   FEF,F
015B0:  BZ    15D2
015B2:  MOVFF  FEA,76B
015B6:  MOVFF  FE9,76A
015BA:  MOVF   FEF,W
015BC:  BTFSS  F9E.4
015BE:  BRA    15BC
015C0:  MOVWF  FAD
015C2:  MOVFF  76B,FEA
015C6:  MOVFF  76A,FE9
015CA:  INCF   FE9,F
015CC:  BTFSC  FD8.2
015CE:  INCF   FEA,F
015D0:  BRA    15AE
015D2:  GOTO   181A (RETURN)
*
01B36:  MOVLW  20
01B38:  MOVLB  7
01B3A:  BTFSS  x91.4
01B3C:  MOVLW  30
01B3E:  MOVWF  x92
01B40:  MOVFF  790,00
01B44:  BTFSS  00.7
01B46:  BRA    1B58
01B48:  COMF   00,F
01B4A:  INCF   00,F
01B4C:  MOVFF  00,790
01B50:  MOVLW  2D
01B52:  MOVWF  x92
01B54:  BSF    x91.7
01B56:  BSF    x91.0
01B58:  MOVF   01,W
01B5A:  CLRF   1B
01B5C:  BTFSC  FF2.7
01B5E:  BSF    1B.7
01B60:  BCF    FF2.7
01B62:  MOVFF  790,7F4
01B66:  MOVLW  64
01B68:  MOVWF  xF5
01B6A:  MOVLB  0
01B6C:  CALL   0642
01B70:  BTFSC  1B.7
01B72:  BSF    FF2.7
01B74:  MOVFF  00,790
01B78:  MOVLW  30
01B7A:  ADDWF  01,W
01B7C:  MOVLB  7
01B7E:  MOVWF  x93
01B80:  CLRF   1B
01B82:  BTFSC  FF2.7
01B84:  BSF    1B.7
01B86:  BCF    FF2.7
01B88:  MOVFF  790,7F4
01B8C:  MOVLW  0A
01B8E:  MOVWF  xF5
01B90:  MOVLB  0
01B92:  CALL   0642
01B96:  BTFSC  1B.7
01B98:  BSF    FF2.7
01B9A:  MOVLW  30
01B9C:  ADDWF  00,W
01B9E:  MOVLB  7
01BA0:  MOVWF  x95
01BA2:  MOVLW  30
01BA4:  ADDWF  01,W
01BA6:  MOVWF  x94
01BA8:  MOVFF  792,00
01BAC:  MOVLW  30
01BAE:  SUBWF  x93,W
01BB0:  BZ    1BBA
01BB2:  BSF    x91.1
01BB4:  BTFSC  x91.7
01BB6:  BSF    x91.2
01BB8:  BRA    1BDE
01BBA:  MOVFF  792,793
01BBE:  MOVLW  20
01BC0:  MOVWF  x92
01BC2:  MOVLW  30
01BC4:  SUBWF  x94,W
01BC6:  BZ    1BD0
01BC8:  BSF    x91.0
01BCA:  BTFSC  x91.7
01BCC:  BSF    x91.1
01BCE:  BRA    1BDE
01BD0:  BTFSS  FD8.2
01BD2:  BSF    x91.0
01BD4:  BNZ   1BDE
01BD6:  MOVFF  793,794
01BDA:  MOVLW  20
01BDC:  MOVWF  x93
01BDE:  BTFSC  x91.2
01BE0:  BRA    1BEC
01BE2:  BTFSC  x91.1
01BE4:  BRA    1BF8
01BE6:  BTFSC  x91.0
01BE8:  BRA    1C04
01BEA:  BRA    1C10
01BEC:  MOVF   x92,W
01BEE:  BTFSS  FA4.4
01BF0:  BRA    1BEE
01BF2:  MOVLB  F
01BF4:  MOVWF  x1C
01BF6:  MOVLB  7
01BF8:  MOVF   x93,W
01BFA:  BTFSS  FA4.4
01BFC:  BRA    1BFA
01BFE:  MOVLB  F
01C00:  MOVWF  x1C
01C02:  MOVLB  7
01C04:  MOVF   x94,W
01C06:  BTFSS  FA4.4
01C08:  BRA    1C06
01C0A:  MOVLB  F
01C0C:  MOVWF  x1C
01C0E:  MOVLB  7
01C10:  MOVF   x95,W
01C12:  BTFSS  FA4.4
01C14:  BRA    1C12
01C16:  MOVLB  F
01C18:  MOVWF  x1C
01C1A:  MOVLB  0
01C1C:  RETURN 0
01C1E:  MOVLB  7
01C20:  CLRF   xB5
01C22:  CLRF   xB6
01C24:  MOVLW  01
01C26:  MOVWF  xB7
01C28:  CLRF   FDA
01C2A:  CLRF   FD9
01C2C:  MOVLW  07
01C2E:  MOVWF  xBA
01C30:  MOVLW  AD
01C32:  MOVWF  xB9
01C34:  MOVLW  07
01C36:  MOVWF  FEA
01C38:  MOVLW  B1
01C3A:  MOVWF  FE9
01C3C:  MOVFF  7BA,FE2
01C40:  MOVFF  7B9,FE1
01C44:  MOVFF  7B7,7B8
01C48:  BCF    FD8.0
01C4A:  MOVF   FE5,W
01C4C:  MULWF  FEE
01C4E:  MOVF   FF3,W
01C50:  ADDWFC xB5,F
01C52:  MOVF   FF4,W
01C54:  ADDWFC xB6,F
01C56:  DECFSZ xB8,F
01C58:  BRA    1C48
01C5A:  MOVFF  7B5,FDE
01C5E:  MOVFF  7B6,7B5
01C62:  CLRF   xB6
01C64:  BTFSC  FD8.0
01C66:  INCF   xB6,F
01C68:  INCF   xB9,F
01C6A:  BTFSC  FD8.2
01C6C:  INCF   xBA,F
01C6E:  INCF   xB7,F
01C70:  MOVF   xB7,W
01C72:  SUBLW  05
01C74:  BNZ   1C34
01C76:  MOVLB  0
01C78:  GOTO   1D9A (RETURN)
01C7C:  BTFSC  FD8.1
01C7E:  BRA    1C88
01C80:  MOVLW  07
01C82:  MOVWF  FEA
01C84:  MOVLW  BD
01C86:  MOVWF  FE9
01C88:  MOVLB  7
01C8A:  MOVF   xB8,W
01C8C:  XORWF  xBC,W
01C8E:  ANDLW  80
01C90:  MOVWF  xC2
01C92:  BTFSS  xB8.7
01C94:  BRA    1CAC
01C96:  COMF   xB5,F
01C98:  COMF   xB6,F
01C9A:  COMF   xB7,F
01C9C:  COMF   xB8,F
01C9E:  INCF   xB5,F
01CA0:  BTFSC  FD8.2
01CA2:  INCF   xB6,F
01CA4:  BTFSC  FD8.2
01CA6:  INCF   xB7,F
01CA8:  BTFSC  FD8.2
01CAA:  INCF   xB8,F
01CAC:  BTFSS  xBC.7
01CAE:  BRA    1CC6
01CB0:  COMF   xB9,F
01CB2:  COMF   xBA,F
01CB4:  COMF   xBB,F
01CB6:  COMF   xBC,F
01CB8:  INCF   xB9,F
01CBA:  BTFSC  FD8.2
01CBC:  INCF   xBA,F
01CBE:  BTFSC  FD8.2
01CC0:  INCF   xBB,F
01CC2:  BTFSC  FD8.2
01CC4:  INCF   xBC,F
01CC6:  CLRF   00
01CC8:  CLRF   01
01CCA:  CLRF   02
01CCC:  CLRF   03
01CCE:  CLRF   xBD
01CD0:  CLRF   xBE
01CD2:  CLRF   xBF
01CD4:  CLRF   xC0
01CD6:  MOVF   xBC,W
01CD8:  IORWF  xBB,W
01CDA:  IORWF  xBA,W
01CDC:  IORWF  xB9,W
01CDE:  BZ    1D38
01CE0:  MOVLW  20
01CE2:  MOVWF  xC1
01CE4:  BCF    FD8.0
01CE6:  RLCF   xB5,F
01CE8:  RLCF   xB6,F
01CEA:  RLCF   xB7,F
01CEC:  RLCF   xB8,F
01CEE:  RLCF   xBD,F
01CF0:  RLCF   xBE,F
01CF2:  RLCF   xBF,F
01CF4:  RLCF   xC0,F
01CF6:  MOVF   xBC,W
01CF8:  SUBWF  xC0,W
01CFA:  BNZ   1D0C
01CFC:  MOVF   xBB,W
01CFE:  SUBWF  xBF,W
01D00:  BNZ   1D0C
01D02:  MOVF   xBA,W
01D04:  SUBWF  xBE,W
01D06:  BNZ   1D0C
01D08:  MOVF   xB9,W
01D0A:  SUBWF  xBD,W
01D0C:  BNC   1D2C
01D0E:  MOVF   xB9,W
01D10:  SUBWF  xBD,F
01D12:  MOVF   xBA,W
01D14:  BTFSS  FD8.0
01D16:  INCFSZ xBA,W
01D18:  SUBWF  xBE,F
01D1A:  MOVF   xBB,W
01D1C:  BTFSS  FD8.0
01D1E:  INCFSZ xBB,W
01D20:  SUBWF  xBF,F
01D22:  MOVF   xBC,W
01D24:  BTFSS  FD8.0
01D26:  INCFSZ xBC,W
01D28:  SUBWF  xC0,F
01D2A:  BSF    FD8.0
01D2C:  RLCF   00,F
01D2E:  RLCF   01,F
01D30:  RLCF   02,F
01D32:  RLCF   03,F
01D34:  DECFSZ xC1,F
01D36:  BRA    1CE4
01D38:  BTFSS  xC2.7
01D3A:  BRA    1D52
01D3C:  COMF   00,F
01D3E:  COMF   01,F
01D40:  COMF   02,F
01D42:  COMF   03,F
01D44:  INCF   00,F
01D46:  BTFSC  FD8.2
01D48:  INCF   01,F
01D4A:  BTFSC  FD8.2
01D4C:  INCF   02,F
01D4E:  BTFSC  FD8.2
01D50:  INCF   03,F
01D52:  MOVFF  7BD,FEF
01D56:  MOVFF  7BE,FEC
01D5A:  MOVFF  7BF,FEC
01D5E:  MOVFF  7C0,FEC
01D62:  MOVLB  0
01D64:  RETURN 0
*
029AA:  MOVLW  8E
029AC:  MOVWF  00
029AE:  MOVFF  7E2,01
029B2:  MOVFF  7E1,02
029B6:  CLRF   03
029B8:  MOVF   01,F
029BA:  BNZ   29CE
029BC:  MOVFF  02,01
029C0:  CLRF   02
029C2:  MOVLW  08
029C4:  SUBWF  00,F
029C6:  MOVF   01,F
029C8:  BNZ   29CE
029CA:  CLRF   00
029CC:  BRA    29DE
029CE:  BCF    FD8.0
029D0:  BTFSC  01.7
029D2:  BRA    29DC
029D4:  RLCF   02,F
029D6:  RLCF   01,F
029D8:  DECF   00,F
029DA:  BRA    29CE
029DC:  BCF    01.7
029DE:  RETURN 0
029E0:  MOVLB  7
029E2:  MOVF   xE1,W
029E4:  BTFSC  FD8.2
029E6:  BRA    2ACA
029E8:  MOVWF  00
029EA:  MOVF   xE5,W
029EC:  BTFSC  FD8.2
029EE:  BRA    2ACA
029F0:  ADDWF  00,F
029F2:  BNC   29FC
029F4:  MOVLW  81
029F6:  ADDWF  00,F
029F8:  BC    2ACA
029FA:  BRA    2A04
029FC:  MOVLW  7F
029FE:  SUBWF  00,F
02A00:  BNC   2ACA
02A02:  BZ    2ACA
02A04:  MOVFF  7E2,7E9
02A08:  MOVF   xE6,W
02A0A:  XORWF  xE9,F
02A0C:  BSF    xE2.7
02A0E:  BSF    xE6.7
02A10:  MOVF   xE4,W
02A12:  MULWF  xE8
02A14:  MOVFF  FF4,7EB
02A18:  MOVF   xE3,W
02A1A:  MULWF  xE7
02A1C:  MOVFF  FF4,03
02A20:  MOVFF  FF3,7EA
02A24:  MULWF  xE8
02A26:  MOVF   FF3,W
02A28:  ADDWF  xEB,F
02A2A:  MOVF   FF4,W
02A2C:  ADDWFC xEA,F
02A2E:  MOVLW  00
02A30:  ADDWFC 03,F
02A32:  MOVF   xE4,W
02A34:  MULWF  xE7
02A36:  MOVF   FF3,W
02A38:  ADDWF  xEB,F
02A3A:  MOVF   FF4,W
02A3C:  ADDWFC xEA,F
02A3E:  MOVLW  00
02A40:  CLRF   02
02A42:  ADDWFC 03,F
02A44:  ADDWFC 02,F
02A46:  MOVF   xE2,W
02A48:  MULWF  xE8
02A4A:  MOVF   FF3,W
02A4C:  ADDWF  xEA,F
02A4E:  MOVF   FF4,W
02A50:  ADDWFC 03,F
02A52:  MOVLW  00
02A54:  ADDWFC 02,F
02A56:  MOVF   xE2,W
02A58:  MULWF  xE7
02A5A:  MOVF   FF3,W
02A5C:  ADDWF  03,F
02A5E:  MOVF   FF4,W
02A60:  ADDWFC 02,F
02A62:  MOVLW  00
02A64:  CLRF   01
02A66:  ADDWFC 01,F
02A68:  MOVF   xE4,W
02A6A:  MULWF  xE6
02A6C:  MOVF   FF3,W
02A6E:  ADDWF  xEA,F
02A70:  MOVF   FF4,W
02A72:  ADDWFC 03,F
02A74:  MOVLW  00
02A76:  ADDWFC 02,F
02A78:  ADDWFC 01,F
02A7A:  MOVF   xE3,W
02A7C:  MULWF  xE6
02A7E:  MOVF   FF3,W
02A80:  ADDWF  03,F
02A82:  MOVF   FF4,W
02A84:  ADDWFC 02,F
02A86:  MOVLW  00
02A88:  ADDWFC 01,F
02A8A:  MOVF   xE2,W
02A8C:  MULWF  xE6
02A8E:  MOVF   FF3,W
02A90:  ADDWF  02,F
02A92:  MOVF   FF4,W
02A94:  ADDWFC 01,F
02A96:  INCF   00,F
02A98:  BTFSC  01.7
02A9A:  BRA    2AA6
02A9C:  RLCF   xEA,F
02A9E:  RLCF   03,F
02AA0:  RLCF   02,F
02AA2:  RLCF   01,F
02AA4:  DECF   00,F
02AA6:  MOVLW  00
02AA8:  BTFSS  xEA.7
02AAA:  BRA    2AC0
02AAC:  INCF   03,F
02AAE:  ADDWFC 02,F
02AB0:  ADDWFC 01,F
02AB2:  MOVF   01,W
02AB4:  BNZ   2AC0
02AB6:  MOVF   02,W
02AB8:  BNZ   2AC0
02ABA:  MOVF   03,W
02ABC:  BNZ   2AC0
02ABE:  INCF   00,F
02AC0:  BTFSC  xE9.7
02AC2:  BSF    01.7
02AC4:  BTFSS  xE9.7
02AC6:  BCF    01.7
02AC8:  BRA    2AD2
02ACA:  CLRF   00
02ACC:  CLRF   01
02ACE:  CLRF   02
02AD0:  CLRF   03
02AD2:  MOVLB  0
02AD4:  RETURN 0
02AD6:  MOVLB  7
02AD8:  MOVF   xBC,W
02ADA:  SUBLW  B6
02ADC:  MOVWF  xBC
02ADE:  CLRF   03
02AE0:  MOVFF  7BD,7C0
02AE4:  BSF    xBD.7
02AE6:  BCF    FD8.0
02AE8:  RRCF   xBD,F
02AEA:  RRCF   xBE,F
02AEC:  RRCF   xBF,F
02AEE:  RRCF   03,F
02AF0:  RRCF   02,F
02AF2:  RRCF   01,F
02AF4:  RRCF   00,F
02AF6:  DECFSZ xBC,F
02AF8:  BRA    2AE6
02AFA:  BTFSS  xC0.7
02AFC:  BRA    2B14
02AFE:  COMF   00,F
02B00:  COMF   01,F
02B02:  COMF   02,F
02B04:  COMF   03,F
02B06:  INCF   00,F
02B08:  BTFSC  FD8.2
02B0A:  INCF   01,F
02B0C:  BTFSC  FD8.2
02B0E:  INCF   02,F
02B10:  BTFSC  FD8.2
02B12:  INCF   03,F
02B14:  MOVLB  0
02B16:  GOTO   2C04 (RETURN)
02B1A:  BTFSC  FD8.1
02B1C:  BRA    2B26
02B1E:  MOVLW  07
02B20:  MOVWF  FEA
02B22:  MOVLW  C4
02B24:  MOVWF  FE9
02B26:  CLRF   00
02B28:  CLRF   01
02B2A:  CLRF   02
02B2C:  CLRF   03
02B2E:  MOVLB  7
02B30:  CLRF   xC4
02B32:  CLRF   xC5
02B34:  CLRF   xC6
02B36:  CLRF   xC7
02B38:  MOVF   xC3,W
02B3A:  IORWF  xC2,W
02B3C:  IORWF  xC1,W
02B3E:  IORWF  xC0,W
02B40:  BZ    2B9A
02B42:  MOVLW  20
02B44:  MOVWF  xC8
02B46:  BCF    FD8.0
02B48:  RLCF   xBC,F
02B4A:  RLCF   xBD,F
02B4C:  RLCF   xBE,F
02B4E:  RLCF   xBF,F
02B50:  RLCF   xC4,F
02B52:  RLCF   xC5,F
02B54:  RLCF   xC6,F
02B56:  RLCF   xC7,F
02B58:  MOVF   xC3,W
02B5A:  SUBWF  xC7,W
02B5C:  BNZ   2B6E
02B5E:  MOVF   xC2,W
02B60:  SUBWF  xC6,W
02B62:  BNZ   2B6E
02B64:  MOVF   xC1,W
02B66:  SUBWF  xC5,W
02B68:  BNZ   2B6E
02B6A:  MOVF   xC0,W
02B6C:  SUBWF  xC4,W
02B6E:  BNC   2B8E
02B70:  MOVF   xC0,W
02B72:  SUBWF  xC4,F
02B74:  MOVF   xC1,W
02B76:  BTFSS  FD8.0
02B78:  INCFSZ xC1,W
02B7A:  SUBWF  xC5,F
02B7C:  MOVF   xC2,W
02B7E:  BTFSS  FD8.0
02B80:  INCFSZ xC2,W
02B82:  SUBWF  xC6,F
02B84:  MOVF   xC3,W
02B86:  BTFSS  FD8.0
02B88:  INCFSZ xC3,W
02B8A:  SUBWF  xC7,F
02B8C:  BSF    FD8.0
02B8E:  RLCF   00,F
02B90:  RLCF   01,F
02B92:  RLCF   02,F
02B94:  RLCF   03,F
02B96:  DECFSZ xC8,F
02B98:  BRA    2B46
02B9A:  MOVFF  7C4,FEF
02B9E:  MOVFF  7C5,FEC
02BA2:  MOVFF  7C6,FEC
02BA6:  MOVFF  7C7,FEC
02BAA:  MOVLB  0
02BAC:  RETURN 0
02BAE:  MOVF   FE9,W
02BB0:  MOVLB  7
02BB2:  MOVWF  xB4
02BB4:  MOVF   xB3,W
02BB6:  MOVWF  xB6
02BB8:  BZ    2BF0
02BBA:  MOVFF  7B2,7E4
02BBE:  MOVFF  7B1,7E3
02BC2:  MOVFF  7B0,7E2
02BC6:  MOVFF  7AF,7E1
02BCA:  CLRF   xE8
02BCC:  CLRF   xE7
02BCE:  MOVLW  20
02BD0:  MOVWF  xE6
02BD2:  MOVLW  82
02BD4:  MOVWF  xE5
02BD6:  MOVLB  0
02BD8:  RCALL  29E0
02BDA:  MOVFF  03,7B2
02BDE:  MOVFF  02,7B1
02BE2:  MOVFF  01,7B0
02BE6:  MOVFF  00,7AF
02BEA:  MOVLB  7
02BEC:  DECFSZ xB6,F
02BEE:  BRA    2BBA
02BF0:  MOVFF  7B2,7BF
02BF4:  MOVFF  7B1,7BE
02BF8:  MOVFF  7B0,7BD
02BFC:  MOVFF  7AF,7BC
02C00:  MOVLB  0
02C02:  BRA    2AD6
02C04:  MOVFF  03,7B2
02C08:  MOVFF  02,7B1
02C0C:  MOVFF  01,7B0
02C10:  MOVFF  00,7AF
02C14:  MOVLB  7
02C16:  BTFSS  xB2.7
02C18:  BRA    2C34
02C1A:  DECF   xB4,F
02C1C:  BSF    xB4.5
02C1E:  COMF   xAF,F
02C20:  COMF   xB0,F
02C22:  COMF   xB1,F
02C24:  COMF   xB2,F
02C26:  INCF   xAF,F
02C28:  BTFSC  FD8.2
02C2A:  INCF   xB0,F
02C2C:  BTFSC  FD8.2
02C2E:  INCF   xB1,F
02C30:  BTFSC  FD8.2
02C32:  INCF   xB2,F
02C34:  MOVLW  3B
02C36:  MOVWF  xBB
02C38:  MOVLW  9A
02C3A:  MOVWF  xBA
02C3C:  MOVLW  CA
02C3E:  MOVWF  xB9
02C40:  CLRF   xB8
02C42:  MOVLW  0A
02C44:  MOVWF  xB6
02C46:  MOVF   xB3,W
02C48:  BTFSC  FD8.2
02C4A:  INCF   xB4,F
02C4C:  BSF    FD8.1
02C4E:  MOVLW  07
02C50:  MOVWF  FEA
02C52:  MOVLW  AF
02C54:  MOVWF  FE9
02C56:  MOVFF  7B2,7BF
02C5A:  MOVFF  7B1,7BE
02C5E:  MOVFF  7B0,7BD
02C62:  MOVFF  7AF,7BC
02C66:  MOVFF  7BB,7C3
02C6A:  MOVFF  7BA,7C2
02C6E:  MOVFF  7B9,7C1
02C72:  MOVFF  7B8,7C0
02C76:  MOVLB  0
02C78:  RCALL  2B1A
02C7A:  MOVF   01,W
02C7C:  MOVF   00,F
02C7E:  BNZ   2CA6
02C80:  MOVLB  7
02C82:  INCF   xB3,W
02C84:  SUBWF  xB6,W
02C86:  BTFSS  FD8.2
02C88:  BRA    2C8E
02C8A:  MOVLB  0
02C8C:  BRA    2CA6
02C8E:  MOVF   xB4,W
02C90:  BZ    2CAC
02C92:  ANDLW  0F
02C94:  SUBWF  xB6,W
02C96:  BZ    2C9A
02C98:  BC    2D22
02C9A:  BTFSC  xB4.7
02C9C:  BRA    2D22
02C9E:  BTFSC  xB4.6
02CA0:  BRA    2CAC
02CA2:  MOVLW  20
02CA4:  BRA    2D14
02CA6:  MOVLW  20
02CA8:  MOVLB  7
02CAA:  ANDWF  xB4,F
02CAC:  BTFSS  xB4.5
02CAE:  BRA    2CCE
02CB0:  BCF    xB4.5
02CB2:  MOVF   xB3,W
02CB4:  BTFSS  FD8.2
02CB6:  DECF   xB4,F
02CB8:  MOVF   00,W
02CBA:  MOVWF  xB4
02CBC:  MOVLW  2D
02CBE:  MOVWF  xBC
02CC0:  MOVLB  0
02CC2:  CALL   0F8C
02CC6:  MOVLB  7
02CC8:  MOVF   xB4,W
02CCA:  MOVWF  00
02CCC:  CLRF   xB4
02CCE:  MOVF   xB3,W
02CD0:  SUBWF  xB6,W
02CD2:  BNZ   2CEE
02CD4:  MOVF   00,W
02CD6:  MOVWF  xB4
02CD8:  MOVLW  2E
02CDA:  MOVWF  xBC
02CDC:  MOVLB  0
02CDE:  CALL   0F8C
02CE2:  MOVLB  7
02CE4:  MOVF   xB4,W
02CE6:  MOVWF  00
02CE8:  MOVLW  20
02CEA:  ANDWF  xB4,F
02CEC:  MOVLW  00
02CEE:  MOVLW  30
02CF0:  BTFSS  xB4.5
02CF2:  BRA    2D14
02CF4:  BCF    xB4.5
02CF6:  MOVF   xB3,W
02CF8:  BTFSS  FD8.2
02CFA:  DECF   xB4,F
02CFC:  MOVF   00,W
02CFE:  MOVWF  xB4
02D00:  MOVLW  2D
02D02:  MOVWF  xBC
02D04:  MOVLB  0
02D06:  CALL   0F8C
02D0A:  MOVLB  7
02D0C:  MOVF   xB4,W
02D0E:  MOVWF  00
02D10:  CLRF   xB4
02D12:  MOVLW  30
02D14:  ADDWF  00,F
02D16:  MOVFF  00,7BC
02D1A:  MOVLB  0
02D1C:  CALL   0F8C
02D20:  MOVLB  7
02D22:  BCF    FD8.1
02D24:  MOVFF  7BB,7BF
02D28:  MOVFF  7BA,7BE
02D2C:  MOVFF  7B9,7BD
02D30:  MOVFF  7B8,7BC
02D34:  CLRF   xC3
02D36:  CLRF   xC2
02D38:  CLRF   xC1
02D3A:  MOVLW  0A
02D3C:  MOVWF  xC0
02D3E:  MOVLB  0
02D40:  RCALL  2B1A
02D42:  MOVFF  03,7BB
02D46:  MOVFF  02,7BA
02D4A:  MOVFF  01,7B9
02D4E:  MOVFF  00,7B8
02D52:  MOVLB  7
02D54:  DECFSZ xB6,F
02D56:  BRA    2C4C
02D58:  MOVLB  0
02D5A:  RETURN 0
02D5C:  MOVFF  FEA,769
02D60:  MOVFF  FE9,768
02D64:  MOVLB  7
02D66:  BTFSS  x62.7
02D68:  BRA    2D7A
02D6A:  BSF    x68.7
02D6C:  BTFSS  x68.4
02D6E:  INCF   x68,F
02D70:  COMF   x61,F
02D72:  COMF   x62,F
02D74:  INCF   x61,F
02D76:  BTFSC  FD8.2
02D78:  INCF   x62,F
02D7A:  SWAPF  x62,W
02D7C:  IORLW  F0
02D7E:  MOVWF  x64
02D80:  ADDWF  x64,F
02D82:  ADDLW  E2
02D84:  MOVWF  x65
02D86:  ADDLW  32
02D88:  MOVWF  x67
02D8A:  MOVF   x62,W
02D8C:  ANDLW  0F
02D8E:  ADDWF  x65,F
02D90:  ADDWF  x65,F
02D92:  ADDWF  x67,F
02D94:  ADDLW  E9
02D96:  MOVWF  x66
02D98:  ADDWF  x66,F
02D9A:  ADDWF  x66,F
02D9C:  SWAPF  x61,W
02D9E:  ANDLW  0F
02DA0:  ADDWF  x66,F
02DA2:  ADDWF  x67,F
02DA4:  RLCF   x66,F
02DA6:  RLCF   x67,F
02DA8:  COMF   x67,F
02DAA:  RLCF   x67,F
02DAC:  MOVF   x61,W
02DAE:  ANDLW  0F
02DB0:  ADDWF  x67,F
02DB2:  RLCF   x64,F
02DB4:  MOVLW  07
02DB6:  MOVWF  x63
02DB8:  MOVLW  0A
02DBA:  DECF   x66,F
02DBC:  ADDWF  x67,F
02DBE:  BNC   2DBA
02DC0:  DECF   x65,F
02DC2:  ADDWF  x66,F
02DC4:  BNC   2DC0
02DC6:  DECF   x64,F
02DC8:  ADDWF  x65,F
02DCA:  BNC   2DC6
02DCC:  DECF   x63,F
02DCE:  ADDWF  x64,F
02DD0:  BNC   2DCC
02DD2:  MOVLW  07
02DD4:  MOVWF  FEA
02DD6:  MOVLW  63
02DD8:  MOVWF  FE9
02DDA:  MOVLW  07
02DDC:  ANDWF  x68,W
02DDE:  BCF    x68.6
02DE0:  MOVF   FED,F
02DE2:  ANDWF  x68,W
02DE4:  BNZ   2DF4
02DE6:  BTFSC  x68.4
02DE8:  MOVF   FEE,F
02DEA:  BTFSC  x68.4
02DEC:  BRA    2DF4
02DEE:  MOVLW  20
02DF0:  MOVWF  00
02DF2:  BRA    2E36
02DF4:  ADDWF  FE9,F
02DF6:  MOVLW  00
02DF8:  ADDWFC FEA,F
02DFA:  MOVF   FE9,W
02DFC:  SUBLW  67
02DFE:  BNZ   2E08
02E00:  MOVF   FEA,W
02E02:  SUBLW  07
02E04:  BNZ   2E08
02E06:  BSF    x68.6
02E08:  MOVF   FEF,W
02E0A:  MOVWF  00
02E0C:  BNZ   2E1E
02E0E:  BTFSC  x68.6
02E10:  BRA    2E1E
02E12:  BTFSC  x68.4
02E14:  BRA    2E52
02E16:  BTFSC  x68.3
02E18:  BRA    2E1E
02E1A:  MOVLW  20
02E1C:  BRA    2E34
02E1E:  BTFSS  x68.7
02E20:  BRA    2E2E
02E22:  MOVLW  2D
02E24:  MOVWF  00
02E26:  MOVF   FED,W
02E28:  BCF    x68.6
02E2A:  BCF    x68.7
02E2C:  BRA    2E36
02E2E:  BSF    x68.3
02E30:  BCF    x68.4
02E32:  MOVLW  30
02E34:  ADDWF  00,F
02E36:  MOVFF  FEA,762
02E3A:  MOVFF  FE9,761
02E3E:  MOVFF  00,7BC
02E42:  MOVLB  0
02E44:  CALL   0F8C
02E48:  MOVFF  762,FEA
02E4C:  MOVFF  761,FE9
02E50:  MOVLB  7
02E52:  MOVF   FEE,W
02E54:  BTFSS  x68.6
02E56:  BRA    2DFA
02E58:  MOVLB  0
02E5A:  GOTO   4864 (RETURN)
*
03058:  MOVLB  7
0305A:  MOVF   xDC,W
0305C:  XORWF  xDE,W
0305E:  ANDLW  80
03060:  MOVWF  xE0
03062:  BTFSS  xDC.7
03064:  BRA    3070
03066:  COMF   xDB,F
03068:  COMF   xDC,F
0306A:  INCF   xDB,F
0306C:  BTFSC  FD8.2
0306E:  INCF   xDC,F
03070:  BTFSS  xDE.7
03072:  BRA    307E
03074:  COMF   xDD,F
03076:  COMF   xDE,F
03078:  INCF   xDD,F
0307A:  BTFSC  FD8.2
0307C:  INCF   xDE,F
0307E:  MOVF   xDB,W
03080:  MULWF  xDD
03082:  MOVFF  FF3,01
03086:  MOVFF  FF4,00
0308A:  MULWF  xDE
0308C:  MOVF   FF3,W
0308E:  ADDWF  00,F
03090:  MOVF   xDC,W
03092:  MULWF  xDD
03094:  MOVF   FF3,W
03096:  ADDWFC 00,W
03098:  MOVWF  02
0309A:  BTFSS  xE0.7
0309C:  BRA    30A8
0309E:  COMF   01,F
030A0:  COMF   02,F
030A2:  INCF   01,F
030A4:  BTFSC  FD8.2
030A6:  INCF   02,F
030A8:  MOVLB  0
030AA:  GOTO   3338 (RETURN)
*
03404:  MOVLW  80
03406:  BTFSS  FD8.1
03408:  BRA    340E
0340A:  MOVLB  7
0340C:  XORWF  xE6,F
0340E:  MOVLB  7
03410:  CLRF   xEB
03412:  CLRF   xEC
03414:  MOVFF  7E2,7EA
03418:  MOVF   xE6,W
0341A:  XORWF  xEA,F
0341C:  MOVF   xE1,W
0341E:  BTFSC  FD8.2
03420:  BRA    35E0
03422:  MOVWF  xE9
03424:  MOVWF  00
03426:  MOVF   xE5,W
03428:  BTFSC  FD8.2
0342A:  BRA    35F2
0342C:  SUBWF  xE9,F
0342E:  BTFSC  FD8.2
03430:  BRA    3538
03432:  BNC   34B0
03434:  MOVFF  7E6,7EF
03438:  BSF    xEF.7
0343A:  MOVFF  7E7,7EE
0343E:  MOVFF  7E8,7ED
03442:  CLRF   xEC
03444:  BCF    FD8.0
03446:  RRCF   xEF,F
03448:  RRCF   xEE,F
0344A:  RRCF   xED,F
0344C:  RRCF   xEC,F
0344E:  DECFSZ xE9,F
03450:  BRA    3442
03452:  BTFSS  xEA.7
03454:  BRA    345C
03456:  BSF    xEB.0
03458:  BRA    361A
0345A:  BCF    xEB.0
0345C:  BCF    xE9.0
0345E:  BSF    xEB.4
03460:  MOVLW  07
03462:  MOVWF  FEA
03464:  MOVLW  E4
03466:  MOVWF  FE9
03468:  BRA    3640
0346A:  BCF    xEB.4
0346C:  BTFSC  xEA.7
0346E:  BRA    3484
03470:  BTFSS  xE9.0
03472:  BRA    349A
03474:  RRCF   xEF,F
03476:  RRCF   xEE,F
03478:  RRCF   xED,F
0347A:  RRCF   xEC,F
0347C:  INCF   00,F
0347E:  BTFSC  FD8.2
03480:  BRA    3610
03482:  BRA    349A
03484:  BTFSC  xEF.7
03486:  BRA    34A0
03488:  BCF    FD8.0
0348A:  RLCF   xEC,F
0348C:  RLCF   xED,F
0348E:  RLCF   xEE,F
03490:  RLCF   xEF,F
03492:  DECF   00,F
03494:  BTFSC  FD8.2
03496:  BRA    3610
03498:  BRA    3484
0349A:  BSF    xEB.6
0349C:  BRA    3578
0349E:  BCF    xEB.6
034A0:  MOVFF  7E2,7EA
034A4:  BTFSS  xE2.7
034A6:  BRA    34AC
034A8:  BSF    xEF.7
034AA:  BRA    3602
034AC:  BCF    xEF.7
034AE:  BRA    3602
034B0:  MOVFF  7E5,7E9
034B4:  MOVFF  7E5,00
034B8:  MOVF   xE1,W
034BA:  SUBWF  xE9,F
034BC:  MOVFF  7E2,7EF
034C0:  BSF    xEF.7
034C2:  MOVFF  7E3,7EE
034C6:  MOVFF  7E4,7ED
034CA:  CLRF   xEC
034CC:  BCF    FD8.0
034CE:  RRCF   xEF,F
034D0:  RRCF   xEE,F
034D2:  RRCF   xED,F
034D4:  RRCF   xEC,F
034D6:  DECFSZ xE9,F
034D8:  BRA    34CA
034DA:  BTFSS  xEA.7
034DC:  BRA    34E4
034DE:  BSF    xEB.1
034E0:  BRA    361A
034E2:  BCF    xEB.1
034E4:  BCF    xE9.0
034E6:  BSF    xEB.5
034E8:  MOVLW  07
034EA:  MOVWF  FEA
034EC:  MOVLW  E8
034EE:  MOVWF  FE9
034F0:  BRA    3640
034F2:  BCF    xEB.5
034F4:  BTFSC  xEA.7
034F6:  BRA    350C
034F8:  BTFSS  xE9.0
034FA:  BRA    3522
034FC:  RRCF   xEF,F
034FE:  RRCF   xEE,F
03500:  RRCF   xED,F
03502:  RRCF   xEC,F
03504:  INCF   00,F
03506:  BTFSC  FD8.2
03508:  BRA    3610
0350A:  BRA    3522
0350C:  BTFSC  xEF.7
0350E:  BRA    3528
03510:  BCF    FD8.0
03512:  RLCF   xEC,F
03514:  RLCF   xED,F
03516:  RLCF   xEE,F
03518:  RLCF   xEF,F
0351A:  DECF   00,F
0351C:  BTFSC  FD8.2
0351E:  BRA    3610
03520:  BRA    350C
03522:  BSF    xEB.7
03524:  BRA    3578
03526:  BCF    xEB.7
03528:  MOVFF  7E6,7EA
0352C:  BTFSS  xE6.7
0352E:  BRA    3534
03530:  BSF    xEF.7
03532:  BRA    3602
03534:  BCF    xEF.7
03536:  BRA    3602
03538:  MOVFF  7E6,7EF
0353C:  BSF    xEF.7
0353E:  MOVFF  7E7,7EE
03542:  MOVFF  7E8,7ED
03546:  BTFSS  xEA.7
03548:  BRA    3552
0354A:  BCF    xEF.7
0354C:  BSF    xEB.2
0354E:  BRA    361A
03550:  BCF    xEB.2
03552:  CLRF   xEC
03554:  BCF    xE9.0
03556:  MOVLW  07
03558:  MOVWF  FEA
0355A:  MOVLW  E4
0355C:  MOVWF  FE9
0355E:  BRA    3640
03560:  BTFSC  xEA.7
03562:  BRA    359C
03564:  MOVFF  7E2,7EA
03568:  BTFSS  xE9.0
0356A:  BRA    3578
0356C:  RRCF   xEF,F
0356E:  RRCF   xEE,F
03570:  RRCF   xED,F
03572:  RRCF   xEC,F
03574:  INCF   00,F
03576:  BZ    3610
03578:  BTFSS  xEC.7
0357A:  BRA    3592
0357C:  INCF   xED,F
0357E:  BNZ   3592
03580:  INCF   xEE,F
03582:  BNZ   3592
03584:  INCF   xEF,F
03586:  BNZ   3592
03588:  RRCF   xEF,F
0358A:  RRCF   xEE,F
0358C:  RRCF   xED,F
0358E:  INCF   00,F
03590:  BZ    3610
03592:  BTFSC  xEB.6
03594:  BRA    349E
03596:  BTFSC  xEB.7
03598:  BRA    3526
0359A:  BRA    35D4
0359C:  MOVLW  80
0359E:  XORWF  xEF,F
035A0:  BTFSS  xEF.7
035A2:  BRA    35AC
035A4:  BRA    361A
035A6:  MOVFF  7E6,7EA
035AA:  BRA    35C0
035AC:  MOVFF  7E2,7EA
035B0:  MOVF   xEF,F
035B2:  BNZ   35C0
035B4:  MOVF   xEE,F
035B6:  BNZ   35C0
035B8:  MOVF   xED,F
035BA:  BNZ   35C0
035BC:  CLRF   00
035BE:  BRA    3602
035C0:  BTFSC  xEF.7
035C2:  BRA    35D4
035C4:  BCF    FD8.0
035C6:  RLCF   xEC,F
035C8:  RLCF   xED,F
035CA:  RLCF   xEE,F
035CC:  RLCF   xEF,F
035CE:  DECFSZ 00,F
035D0:  BRA    35C0
035D2:  BRA    3610
035D4:  BTFSS  xEA.7
035D6:  BRA    35DC
035D8:  BSF    xEF.7
035DA:  BRA    3602
035DC:  BCF    xEF.7
035DE:  BRA    3602
035E0:  MOVFF  7E5,00
035E4:  MOVFF  7E6,7EF
035E8:  MOVFF  7E7,7EE
035EC:  MOVFF  7E8,7ED
035F0:  BRA    3602
035F2:  MOVFF  7E1,00
035F6:  MOVFF  7E2,7EF
035FA:  MOVFF  7E3,7EE
035FE:  MOVFF  7E4,7ED
03602:  MOVFF  7EF,01
03606:  MOVFF  7EE,02
0360A:  MOVFF  7ED,03
0360E:  BRA    3678
03610:  CLRF   00
03612:  CLRF   01
03614:  CLRF   02
03616:  CLRF   03
03618:  BRA    3678
0361A:  CLRF   xEC
0361C:  COMF   xED,F
0361E:  COMF   xEE,F
03620:  COMF   xEF,F
03622:  COMF   xEC,F
03624:  INCF   xEC,F
03626:  BNZ   3632
03628:  INCF   xED,F
0362A:  BNZ   3632
0362C:  INCF   xEE,F
0362E:  BNZ   3632
03630:  INCF   xEF,F
03632:  BTFSC  xEB.0
03634:  BRA    345A
03636:  BTFSC  xEB.1
03638:  BRA    34E2
0363A:  BTFSC  xEB.2
0363C:  BRA    3550
0363E:  BRA    35A6
03640:  MOVF   FEF,W
03642:  ADDWF  xED,F
03644:  BNC   3650
03646:  INCF   xEE,F
03648:  BNZ   3650
0364A:  INCF   xEF,F
0364C:  BTFSC  FD8.2
0364E:  BSF    xE9.0
03650:  MOVF   FED,F
03652:  MOVF   FEF,W
03654:  ADDWF  xEE,F
03656:  BNC   365E
03658:  INCF   xEF,F
0365A:  BTFSC  FD8.2
0365C:  BSF    xE9.0
0365E:  MOVF   FED,F
03660:  MOVF   FEF,W
03662:  BTFSC  FEF.7
03664:  BRA    3668
03666:  XORLW  80
03668:  ADDWF  xEF,F
0366A:  BTFSC  FD8.0
0366C:  BSF    xE9.0
0366E:  BTFSC  xEB.4
03670:  BRA    346A
03672:  BTFSC  xEB.5
03674:  BRA    34F2
03676:  BRA    3560
03678:  MOVLB  0
0367A:  RETURN 0
0367C:  MOVFF  7DE,7E5
03680:  MOVLB  7
03682:  MOVF   xE2,W
03684:  XORWF  xE5,F
03686:  BTFSS  xE5.7
03688:  BRA    3694
0368A:  BCF    FD8.2
0368C:  BCF    FD8.0
0368E:  BTFSC  xDE.7
03690:  BSF    FD8.0
03692:  BRA    36F2
03694:  MOVFF  7DE,7E5
03698:  MOVFF  7E1,7E6
0369C:  MOVF   xDD,W
0369E:  SUBWF  xE6,F
036A0:  BZ    36AE
036A2:  BTFSS  xE5.7
036A4:  BRA    36F2
036A6:  MOVF   FD8,W
036A8:  XORLW  01
036AA:  MOVWF  FD8
036AC:  BRA    36F2
036AE:  MOVFF  7E2,7E6
036B2:  MOVF   xDE,W
036B4:  SUBWF  xE6,F
036B6:  BZ    36C4
036B8:  BTFSS  xE5.7
036BA:  BRA    36F2
036BC:  MOVF   FD8,W
036BE:  XORLW  01
036C0:  MOVWF  FD8
036C2:  BRA    36F2
036C4:  MOVFF  7E3,7E6
036C8:  MOVF   xDF,W
036CA:  SUBWF  xE6,F
036CC:  BZ    36DA
036CE:  BTFSS  xE5.7
036D0:  BRA    36F2
036D2:  MOVF   FD8,W
036D4:  XORLW  01
036D6:  MOVWF  FD8
036D8:  BRA    36F2
036DA:  MOVFF  7E4,7E6
036DE:  MOVF   xE0,W
036E0:  SUBWF  xE6,F
036E2:  BZ    36F0
036E4:  BTFSS  xE5.7
036E6:  BRA    36F2
036E8:  MOVF   FD8,W
036EA:  XORLW  01
036EC:  MOVWF  FD8
036EE:  BRA    36F2
036F0:  BCF    FD8.0
036F2:  MOVLB  0
036F4:  RETURN 0
036F6:  MOVLW  8E
036F8:  MOVWF  00
036FA:  MOVLB  7
036FC:  MOVF   xDD,W
036FE:  SUBWF  00,F
03700:  MOVFF  7DE,02
03704:  MOVFF  7DF,01
03708:  BSF    02.7
0370A:  MOVF   00,F
0370C:  BZ    3720
0370E:  BCF    FD8.0
03710:  MOVF   02,F
03712:  BNZ   3718
03714:  MOVF   01,F
03716:  BZ    3720
03718:  RRCF   02,F
0371A:  RRCF   01,F
0371C:  DECFSZ 00,F
0371E:  BRA    370E
03720:  BTFSS  xDE.7
03722:  BRA    372E
03724:  COMF   01,F
03726:  COMF   02,F
03728:  INCF   01,F
0372A:  BTFSC  FD8.2
0372C:  INCF   02,F
0372E:  MOVLB  0
03730:  GOTO   37EE (RETURN)
*
03AB8:  MOVLB  7
03ABA:  MOVF   xAB,W
03ABC:  BTFSC  FD8.2
03ABE:  BRA    3C0A
03AC0:  MOVWF  xB7
03AC2:  MOVF   xAF,W
03AC4:  BTFSC  FD8.2
03AC6:  BRA    3C0A
03AC8:  SUBWF  xB7,F
03ACA:  BNC   3AD6
03ACC:  MOVLW  7F
03ACE:  ADDWF  xB7,F
03AD0:  BTFSC  FD8.0
03AD2:  BRA    3C0A
03AD4:  BRA    3AE2
03AD6:  MOVLW  81
03AD8:  SUBWF  xB7,F
03ADA:  BTFSS  FD8.0
03ADC:  BRA    3C0A
03ADE:  BTFSC  FD8.2
03AE0:  BRA    3C0A
03AE2:  MOVFF  7B7,00
03AE6:  CLRF   01
03AE8:  CLRF   02
03AEA:  CLRF   03
03AEC:  CLRF   xB6
03AEE:  MOVFF  7AC,7B5
03AF2:  BSF    xB5.7
03AF4:  MOVFF  7AD,7B4
03AF8:  MOVFF  7AE,7B3
03AFC:  MOVLW  19
03AFE:  MOVWF  xB7
03B00:  MOVF   xB2,W
03B02:  SUBWF  xB3,F
03B04:  BC    3B20
03B06:  MOVLW  01
03B08:  SUBWF  xB4,F
03B0A:  BC    3B20
03B0C:  SUBWF  xB5,F
03B0E:  BC    3B20
03B10:  SUBWF  xB6,F
03B12:  BC    3B20
03B14:  INCF   xB6,F
03B16:  INCF   xB5,F
03B18:  INCF   xB4,F
03B1A:  MOVF   xB2,W
03B1C:  ADDWF  xB3,F
03B1E:  BRA    3B70
03B20:  MOVF   xB1,W
03B22:  SUBWF  xB4,F
03B24:  BC    3B4A
03B26:  MOVLW  01
03B28:  SUBWF  xB5,F
03B2A:  BC    3B4A
03B2C:  SUBWF  xB6,F
03B2E:  BC    3B4A
03B30:  INCF   xB6,F
03B32:  INCF   xB5,F
03B34:  MOVF   xB1,W
03B36:  ADDWF  xB4,F
03B38:  MOVF   xB2,W
03B3A:  ADDWF  xB3,F
03B3C:  BNC   3B70
03B3E:  INCF   xB4,F
03B40:  BNZ   3B70
03B42:  INCF   xB5,F
03B44:  BNZ   3B70
03B46:  INCF   xB6,F
03B48:  BRA    3B70
03B4A:  MOVF   xB0,W
03B4C:  IORLW  80
03B4E:  SUBWF  xB5,F
03B50:  BC    3B6E
03B52:  MOVLW  01
03B54:  SUBWF  xB6,F
03B56:  BC    3B6E
03B58:  INCF   xB6,F
03B5A:  MOVF   xB0,W
03B5C:  IORLW  80
03B5E:  ADDWF  xB5,F
03B60:  MOVF   xB1,W
03B62:  ADDWF  xB4,F
03B64:  BNC   3B38
03B66:  INCF   xB5,F
03B68:  BNZ   3B38
03B6A:  INCF   xB6,F
03B6C:  BRA    3B38
03B6E:  BSF    03.0
03B70:  DECFSZ xB7,F
03B72:  BRA    3B76
03B74:  BRA    3B8C
03B76:  BCF    FD8.0
03B78:  RLCF   xB3,F
03B7A:  RLCF   xB4,F
03B7C:  RLCF   xB5,F
03B7E:  RLCF   xB6,F
03B80:  BCF    FD8.0
03B82:  RLCF   03,F
03B84:  RLCF   02,F
03B86:  RLCF   01,F
03B88:  RLCF   xB8,F
03B8A:  BRA    3B00
03B8C:  BTFSS  xB8.0
03B8E:  BRA    3B9C
03B90:  BCF    FD8.0
03B92:  RRCF   01,F
03B94:  RRCF   02,F
03B96:  RRCF   03,F
03B98:  RRCF   xB8,F
03B9A:  BRA    3BA0
03B9C:  DECF   00,F
03B9E:  BZ    3C0A
03BA0:  BTFSC  xB8.7
03BA2:  BRA    3BE0
03BA4:  BCF    FD8.0
03BA6:  RLCF   xB3,F
03BA8:  RLCF   xB4,F
03BAA:  RLCF   xB5,F
03BAC:  RLCF   xB6,F
03BAE:  MOVF   xB2,W
03BB0:  SUBWF  xB3,F
03BB2:  BC    3BC2
03BB4:  MOVLW  01
03BB6:  SUBWF  xB4,F
03BB8:  BC    3BC2
03BBA:  SUBWF  xB5,F
03BBC:  BC    3BC2
03BBE:  SUBWF  xB6,F
03BC0:  BNC   3BF6
03BC2:  MOVF   xB1,W
03BC4:  SUBWF  xB4,F
03BC6:  BC    3BD2
03BC8:  MOVLW  01
03BCA:  SUBWF  xB5,F
03BCC:  BC    3BD2
03BCE:  SUBWF  xB6,F
03BD0:  BNC   3BF6
03BD2:  MOVF   xB0,W
03BD4:  IORLW  80
03BD6:  SUBWF  xB5,F
03BD8:  BC    3BE0
03BDA:  MOVLW  01
03BDC:  SUBWF  xB6,F
03BDE:  BNC   3BF6
03BE0:  INCF   03,F
03BE2:  BNZ   3BF6
03BE4:  INCF   02,F
03BE6:  BNZ   3BF6
03BE8:  INCF   01,F
03BEA:  BNZ   3BF6
03BEC:  INCF   00,F
03BEE:  BZ    3C0A
03BF0:  RRCF   01,F
03BF2:  RRCF   02,F
03BF4:  RRCF   03,F
03BF6:  MOVFF  7AC,7B7
03BFA:  MOVF   xB0,W
03BFC:  XORWF  xB7,F
03BFE:  BTFSS  xB7.7
03C00:  BRA    3C06
03C02:  BSF    01.7
03C04:  BRA    3C12
03C06:  BCF    01.7
03C08:  BRA    3C12
03C0A:  CLRF   00
03C0C:  CLRF   01
03C0E:  CLRF   02
03C10:  CLRF   03
03C12:  MOVLB  0
03C14:  RETURN 0
*
03C66:  TBLRD*+
03C68:  MOVF   FF5,F
03C6A:  BZ    3C8E
03C6C:  MOVFF  FF6,7A7
03C70:  MOVFF  FF7,7A8
03C74:  MOVFF  FF8,7A9
03C78:  MOVFF  FF5,7BC
03C7C:  CALL   0F8C
03C80:  MOVFF  7A7,FF6
03C84:  MOVFF  7A8,FF7
03C88:  MOVFF  7A9,FF8
03C8C:  BRA    3C66
03C8E:  RETURN 0
*
041F6:  MOVLW  20
041F8:  MOVLB  7
041FA:  BTFSS  x62.4
041FC:  MOVLW  30
041FE:  MOVWF  x63
04200:  MOVFF  761,00
04204:  BTFSS  00.7
04206:  BRA    4218
04208:  COMF   00,F
0420A:  INCF   00,F
0420C:  MOVFF  00,761
04210:  MOVLW  2D
04212:  MOVWF  x63
04214:  BSF    x62.7
04216:  BSF    x62.0
04218:  MOVF   01,W
0421A:  CLRF   1B
0421C:  BTFSC  FF2.7
0421E:  BSF    1B.7
04220:  BCF    FF2.7
04222:  MOVFF  761,7F4
04226:  MOVLW  64
04228:  MOVWF  xF5
0422A:  MOVLB  0
0422C:  CALL   0642
04230:  BTFSC  1B.7
04232:  BSF    FF2.7
04234:  MOVFF  00,761
04238:  MOVLW  30
0423A:  ADDWF  01,W
0423C:  MOVLB  7
0423E:  MOVWF  x64
04240:  CLRF   1B
04242:  BTFSC  FF2.7
04244:  BSF    1B.7
04246:  BCF    FF2.7
04248:  MOVFF  761,7F4
0424C:  MOVLW  0A
0424E:  MOVWF  xF5
04250:  MOVLB  0
04252:  CALL   0642
04256:  BTFSC  1B.7
04258:  BSF    FF2.7
0425A:  MOVLW  30
0425C:  ADDWF  00,W
0425E:  MOVLB  7
04260:  MOVWF  x66
04262:  MOVLW  30
04264:  ADDWF  01,W
04266:  MOVWF  x65
04268:  MOVFF  763,00
0426C:  MOVLW  30
0426E:  SUBWF  x64,W
04270:  BZ    427A
04272:  BSF    x62.1
04274:  BTFSC  x62.7
04276:  BSF    x62.2
04278:  BRA    429E
0427A:  BTFSC  x62.2
0427C:  BRA    429E
0427E:  MOVFF  763,764
04282:  BTFSC  x62.1
04284:  BRA    428E
04286:  MOVLW  30
04288:  SUBWF  x65,W
0428A:  BZ    4294
0428C:  BSF    x62.0
0428E:  BTFSC  x62.7
04290:  BSF    x62.1
04292:  BRA    429E
04294:  BTFSS  FD8.2
04296:  BSF    x62.0
04298:  BTFSC  FD8.2
0429A:  MOVFF  764,765
0429E:  BTFSC  x62.2
042A0:  BRA    42AC
042A2:  BTFSC  x62.1
042A4:  BRA    42B6
042A6:  BTFSC  x62.0
042A8:  BRA    42C0
042AA:  BRA    42CA
042AC:  MOVFF  763,7BC
042B0:  MOVLB  0
042B2:  CALL   0F8C
042B6:  MOVFF  764,7BC
042BA:  MOVLB  0
042BC:  CALL   0F8C
042C0:  MOVFF  765,7BC
042C4:  MOVLB  0
042C6:  CALL   0F8C
042CA:  MOVFF  766,7BC
042CE:  MOVLB  0
042D0:  CALL   0F8C
042D4:  RETURN 0
*
04AD8:  CLRF   00
04ADA:  CLRF   01
04ADC:  MOVLB  7
04ADE:  MOVF   x46,W
04AE0:  BCF    FD8.0
04AE2:  BTFSC  x47.0
04AE4:  ADDWF  00,F
04AE6:  RRCF   00,F
04AE8:  RRCF   01,F
04AEA:  BTFSC  x47.1
04AEC:  ADDWF  00,F
04AEE:  RRCF   00,F
04AF0:  RRCF   01,F
04AF2:  BTFSC  x47.2
04AF4:  ADDWF  00,F
04AF6:  RRCF   00,F
04AF8:  RRCF   01,F
04AFA:  BTFSC  x47.3
04AFC:  ADDWF  00,F
04AFE:  RRCF   00,F
04B00:  RRCF   01,F
04B02:  BTFSC  x47.4
04B04:  ADDWF  00,F
04B06:  RRCF   00,F
04B08:  RRCF   01,F
04B0A:  BTFSC  x47.5
04B0C:  ADDWF  00,F
04B0E:  RRCF   00,F
04B10:  RRCF   01,F
04B12:  BTFSC  x47.6
04B14:  ADDWF  00,F
04B16:  RRCF   00,F
04B18:  RRCF   01,F
04B1A:  BTFSC  x47.7
04B1C:  ADDWF  00,F
04B1E:  RRCF   00,F
04B20:  RRCF   01,F
04B22:  MOVLB  0
04B24:  GOTO   4BF8 (RETURN)
*
0503C:  MOVF   01,W
0503E:  CLRF   1B
05040:  BTFSC  FF2.7
05042:  BSF    1B.7
05044:  BCF    FF2.7
05046:  MOVFF  748,7F4
0504A:  MOVLW  64
0504C:  MOVLB  7
0504E:  MOVWF  xF5
05050:  MOVLB  0
05052:  CALL   0642
05056:  BTFSC  1B.7
05058:  BSF    FF2.7
0505A:  MOVFF  00,748
0505E:  MOVF   01,W
05060:  MOVLW  30
05062:  BNZ   5074
05064:  MOVLB  7
05066:  BTFSS  x49.1
05068:  BRA    508A
0506A:  BTFSC  x49.3
0506C:  BRA    508A
0506E:  BTFSC  x49.4
05070:  MOVLW  20
05072:  BRA    507C
05074:  MOVLB  7
05076:  BCF    x49.3
05078:  BCF    x49.4
0507A:  BSF    x49.0
0507C:  ADDWF  01,F
0507E:  MOVFF  01,7BC
05082:  MOVLB  0
05084:  CALL   0F8C
05088:  MOVLB  7
0508A:  CLRF   1B
0508C:  BTFSC  FF2.7
0508E:  BSF    1B.7
05090:  BCF    FF2.7
05092:  MOVFF  748,7F4
05096:  MOVLW  0A
05098:  MOVWF  xF5
0509A:  MOVLB  0
0509C:  CALL   0642
050A0:  BTFSC  1B.7
050A2:  BSF    FF2.7
050A4:  MOVFF  00,748
050A8:  MOVF   01,W
050AA:  MOVLW  30
050AC:  BNZ   50BE
050AE:  MOVLB  7
050B0:  BTFSC  x49.3
050B2:  BRA    50CA
050B4:  BTFSS  x49.0
050B6:  BRA    50CA
050B8:  BTFSC  x49.4
050BA:  MOVLW  20
050BC:  MOVLB  0
050BE:  ADDWF  01,F
050C0:  MOVFF  01,7BC
050C4:  CALL   0F8C
050C8:  MOVLB  7
050CA:  MOVLW  30
050CC:  ADDWF  x48,F
050CE:  MOVFF  748,7BC
050D2:  MOVLB  0
050D4:  CALL   0F8C
050D8:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device adc=12
.................... #FUSES WDT_SW, WDT32768, INTRC_IO, SOSC_HIGH, NOPROTECT, NOIESO, BROWNOUT, PUT, NOCPD, STVREN, NODEBUG, NOWRT, NOWRTD, NOEBTR, NOCPB, NOEBTRB, NOWRTC, NOWRTB, FCMEN, NOXINST, MCLR, RTCOSC_T1
.................... #use delay(clock=16000000)
*
00F16:  MOVLW  07
00F18:  MOVWF  FEA
00F1A:  MOVLW  6D
00F1C:  MOVWF  FE9
00F1E:  MOVF   FEF,W
00F20:  BZ    0F3E
00F22:  MOVLW  05
00F24:  MOVWF  01
00F26:  CLRF   00
00F28:  DECFSZ 00,F
00F2A:  BRA    0F28
00F2C:  DECFSZ 01,F
00F2E:  BRA    0F26
00F30:  MOVLW  2E
00F32:  MOVWF  00
00F34:  DECFSZ 00,F
00F36:  BRA    0F34
00F38:  BRA    0F3A
00F3A:  DECFSZ FEF,F
00F3C:  BRA    0F22
00F3E:  RETURN 0
.................... 
.................... #use spi(MASTER, FORCE_HW, SPI1, MODE=1, BITS=8)
.................... #use i2c(MASTER, sda=PIN_D5, scl=PIN_D6)
*
04D06:  BCF    F67.7
04D08:  BCF    FA1.5
04D0A:  MOVFF  748,F6A
04D0E:  MOVLW  02
04D10:  BTFSC  F67.7
04D12:  BRA    4D1E
04D14:  BTFSS  FA1.5
04D16:  BRA    4D14
04D18:  MOVLW  00
04D1A:  BTFSC  F66.6
04D1C:  MOVLW  01
04D1E:  MOVWF  01
04D20:  RETURN 0
*
05000:  BCF    F67.6
05002:  BSF    F66.3
05004:  BTFSC  F66.3
05006:  BRA    5004
05008:  BTFSC  00.0
0500A:  BCF    F66.5
0500C:  BTFSS  00.0
0500E:  BSF    F66.5
05010:  BSF    F66.4
05012:  BTFSC  F66.4
05014:  BRA    5012
05016:  MOVFF  F6A,01
0501A:  GOTO   5166 (RETURN)
.................... 
.................... //#use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT2)
.................... #use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT1)
.................... 
.................... #use rs232(baud=57600, xmit=PIN_G4, rcv=PIN_G3, stream=RS232_BTD200)
*
014A8:  BSF    F98.3
014AA:  BTFSC  F86.3
014AC:  BRA    14AA
014AE:  MOVLW  08
014B0:  MOVWF  00
014B2:  MOVLB  7
014B4:  CLRF   x65
014B6:  BSF    00.7
014B8:  BRA    14D6
014BA:  BCF    00.7
014BC:  BRA    14D6
014BE:  BCF    FD8.0
014C0:  BTFSC  F86.3
014C2:  BSF    FD8.0
014C4:  RRCF   x65,F
014C6:  BSF    00.6
014C8:  BRA    14D6
014CA:  BCF    00.6
014CC:  DECFSZ 00,F
014CE:  BRA    14BE
014D0:  MOVFF  765,01
014D4:  BRA    14EE
014D6:  MOVLW  10
014D8:  BTFSC  00.7
014DA:  MOVLW  04
014DC:  MOVWF  01
014DE:  DECFSZ 01,F
014E0:  BRA    14DE
014E2:  BRA    14E4
014E4:  BTFSC  00.7
014E6:  BRA    14BA
014E8:  BTFSC  00.6
014EA:  BRA    14CA
014EC:  BRA    14BE
014EE:  MOVLB  0
014F0:  RETURN 0
*
01AF0:  BCF    F98.4
01AF2:  BCF    F8F.4
01AF4:  MOVLW  08
01AF6:  MOVWF  01
01AF8:  BRA    1AFA
01AFA:  NOP   
01AFC:  BSF    01.7
01AFE:  BRA    1B20
01B00:  BCF    01.7
01B02:  MOVLB  7
01B04:  RRCF   x90,F
01B06:  MOVLB  0
01B08:  BTFSC  FD8.0
01B0A:  BSF    F8F.4
01B0C:  BTFSS  FD8.0
01B0E:  BCF    F8F.4
01B10:  BSF    01.6
01B12:  BRA    1B20
01B14:  BCF    01.6
01B16:  DECFSZ 01,F
01B18:  BRA    1B02
01B1A:  BRA    1B1C
01B1C:  NOP   
01B1E:  BSF    F8F.4
01B20:  MOVLW  10
01B22:  MOVWF  FE9
01B24:  DECFSZ FE9,F
01B26:  BRA    1B24
01B28:  BRA    1B2A
01B2A:  NOP   
01B2C:  BTFSC  01.7
01B2E:  BRA    1B00
01B30:  BTFSC  01.6
01B32:  BRA    1B14
01B34:  RETURN 0
.................... #use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=GSM)
.................... //!#use rs232(baud=57600, xmit=TX_B, rcv=RX_B, stream=RS232_BTD200)
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+3);
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
*
03734:  MOVLB  7
03736:  CLRF   xC2
03738:  CLRF   xC1
0373A:  CLRF   xC0
0373C:  MOVLW  7F
0373E:  MOVWF  xBF
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
03740:  MOVLW  7E
03742:  MOVWF  xC9
03744:  MOVLW  80
03746:  MOVWF  xCA
03748:  CLRF   xCB
0374A:  CLRF   xCC
0374C:  MOVLW  7A
0374E:  MOVWF  xCD
03750:  MOVLW  2A
03752:  MOVWF  xCE
03754:  MOVLW  AA
03756:  MOVWF  xCF
03758:  MOVLW  A3
0375A:  MOVWF  xD0
0375C:  MOVLW  75
0375E:  MOVWF  xD1
03760:  MOVLW  B6
03762:  MOVWF  xD2
03764:  MOVLW  09
03766:  MOVWF  xD3
03768:  MOVLW  B4
0376A:  MOVWF  xD4
0376C:  MOVLW  6F
0376E:  MOVWF  xD5
03770:  MOVLW  4F
03772:  MOVWF  xD6
03774:  MOVLW  B6
03776:  MOVWF  xD7
03778:  MOVLW  AA
0377A:  MOVWF  xD8
0377C:  MOVLW  69
0377E:  MOVWF  xD9
03780:  MOVLW  8B
03782:  MOVWF  xDA
03784:  MOVLW  F6
03786:  MOVWF  xDB
03788:  MOVLW  E8
0378A:  MOVWF  xDC
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
0378C:  MOVFF  7B6,7E0
03790:  MOVFF  7B5,7DF
03794:  MOVFF  7B4,7DE
03798:  MOVFF  7B3,7DD
0379C:  CLRF   xE4
0379E:  CLRF   xE3
037A0:  CLRF   xE2
037A2:  CLRF   xE1
037A4:  MOVLB  0
037A6:  RCALL  367C
037A8:  BNC   37B4
037AA:  MOVLB  7
037AC:  MOVF   xB4,W
037AE:  XORLW  80
037B0:  MOVWF  xB4
037B2:  MOVLB  0
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
037B4:  MOVFF  7B6,7E4
037B8:  MOVFF  7B5,7E3
037BC:  MOVFF  7B4,7E2
037C0:  MOVFF  7B3,7E1
037C4:  MOVLW  83
037C6:  MOVLB  7
037C8:  MOVWF  xE8
037CA:  MOVLW  F9
037CC:  MOVWF  xE7
037CE:  MOVLW  22
037D0:  MOVWF  xE6
037D2:  MOVLW  7E
037D4:  MOVWF  xE5
037D6:  MOVLB  0
037D8:  CALL   29E0
037DC:  MOVFF  03,7E0
037E0:  MOVFF  02,7DF
037E4:  MOVFF  01,7DE
037E8:  MOVFF  00,7DD
037EC:  BRA    36F6
037EE:  MOVFF  01,7C3
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
037F2:  MOVFF  7B6,7E4
037F6:  MOVFF  7B5,7E3
037FA:  MOVFF  7B4,7E2
037FE:  MOVFF  7B3,7E1
03802:  MOVLW  83
03804:  MOVLB  7
03806:  MOVWF  xE8
03808:  MOVLW  F9
0380A:  MOVWF  xE7
0380C:  MOVLW  22
0380E:  MOVWF  xE6
03810:  MOVLW  7E
03812:  MOVWF  xE5
03814:  MOVLB  0
03816:  CALL   29E0
0381A:  MOVFF  03,7E0
0381E:  MOVFF  02,7DF
03822:  MOVFF  01,7DE
03826:  MOVFF  00,7DD
0382A:  MOVLB  7
0382C:  CLRF   xE2
0382E:  MOVFF  7C3,7E1
03832:  MOVLB  0
03834:  CALL   29AA
03838:  BSF    FD8.1
0383A:  MOVFF  7E0,7E4
0383E:  MOVFF  7DF,7E3
03842:  MOVFF  7DE,7E2
03846:  MOVFF  7DD,7E1
0384A:  MOVFF  03,7E8
0384E:  MOVFF  02,7E7
03852:  MOVFF  01,7E6
03856:  MOVFF  00,7E5
0385A:  RCALL  3404
0385C:  MOVFF  03,7C8
03860:  MOVFF  02,7C7
03864:  MOVFF  01,7C6
03868:  MOVFF  00,7C5
....................    quad = quad % 4;                    // quadrant (0 to 3)
0386C:  MOVLW  03
0386E:  MOVLB  7
03870:  ANDWF  xC3,F
.................... 
....................    if (quad == 0 || quad == 2)
03872:  MOVF   xC3,F
03874:  BZ    387C
03876:  MOVF   xC3,W
03878:  SUBLW  02
0387A:  BNZ   38B6
....................       t = frac * PI_DIV_BY_TWO;
0387C:  MOVFF  7C8,7E4
03880:  MOVFF  7C7,7E3
03884:  MOVFF  7C6,7E2
03888:  MOVFF  7C5,7E1
0388C:  MOVLW  DB
0388E:  MOVWF  xE8
03890:  MOVLW  0F
03892:  MOVWF  xE7
03894:  MOVLW  49
03896:  MOVWF  xE6
03898:  MOVLW  7F
0389A:  MOVWF  xE5
0389C:  MOVLB  0
0389E:  CALL   29E0
038A2:  MOVFF  03,7BE
038A6:  MOVFF  02,7BD
038AA:  MOVFF  01,7BC
038AE:  MOVFF  00,7BB
038B2:  BRA    398E
038B4:  MOVLB  7
....................    else if (quad == 1)
038B6:  DECFSZ xC3,W
038B8:  BRA    3926
....................       t = (1-frac) * PI_DIV_BY_TWO;
038BA:  BSF    FD8.1
038BC:  CLRF   xE4
038BE:  CLRF   xE3
038C0:  CLRF   xE2
038C2:  MOVLW  7F
038C4:  MOVWF  xE1
038C6:  MOVFF  7C8,7E8
038CA:  MOVFF  7C7,7E7
038CE:  MOVFF  7C6,7E6
038D2:  MOVFF  7C5,7E5
038D6:  MOVLB  0
038D8:  RCALL  3404
038DA:  MOVFF  03,7E0
038DE:  MOVFF  02,7DF
038E2:  MOVFF  01,7DE
038E6:  MOVFF  00,7DD
038EA:  MOVFF  03,7E4
038EE:  MOVFF  02,7E3
038F2:  MOVFF  01,7E2
038F6:  MOVFF  00,7E1
038FA:  MOVLW  DB
038FC:  MOVLB  7
038FE:  MOVWF  xE8
03900:  MOVLW  0F
03902:  MOVWF  xE7
03904:  MOVLW  49
03906:  MOVWF  xE6
03908:  MOVLW  7F
0390A:  MOVWF  xE5
0390C:  MOVLB  0
0390E:  CALL   29E0
03912:  MOVFF  03,7BE
03916:  MOVFF  02,7BD
0391A:  MOVFF  01,7BC
0391E:  MOVFF  00,7BB
03922:  BRA    398E
03924:  MOVLB  7
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
03926:  BSF    FD8.1
03928:  MOVFF  7C8,7E4
0392C:  MOVFF  7C7,7E3
03930:  MOVFF  7C6,7E2
03934:  MOVFF  7C5,7E1
03938:  CLRF   xE8
0393A:  CLRF   xE7
0393C:  CLRF   xE6
0393E:  MOVLW  7F
03940:  MOVWF  xE5
03942:  MOVLB  0
03944:  RCALL  3404
03946:  MOVFF  03,7E0
0394A:  MOVFF  02,7DF
0394E:  MOVFF  01,7DE
03952:  MOVFF  00,7DD
03956:  MOVFF  03,7E4
0395A:  MOVFF  02,7E3
0395E:  MOVFF  01,7E2
03962:  MOVFF  00,7E1
03966:  MOVLW  DB
03968:  MOVLB  7
0396A:  MOVWF  xE8
0396C:  MOVLW  0F
0396E:  MOVWF  xE7
03970:  MOVLW  49
03972:  MOVWF  xE6
03974:  MOVLW  7F
03976:  MOVWF  xE5
03978:  MOVLB  0
0397A:  CALL   29E0
0397E:  MOVFF  03,7BE
03982:  MOVFF  02,7BD
03986:  MOVFF  01,7BC
0398A:  MOVFF  00,7BB
.................... 
....................    y = 1.0;
0398E:  MOVLB  7
03990:  CLRF   xBA
03992:  CLRF   xB9
03994:  CLRF   xB8
03996:  MOVLW  7F
03998:  MOVWF  xB7
....................    t = t * t;
0399A:  MOVFF  7BE,7E4
0399E:  MOVFF  7BD,7E3
039A2:  MOVFF  7BC,7E2
039A6:  MOVFF  7BB,7E1
039AA:  MOVFF  7BE,7E8
039AE:  MOVFF  7BD,7E7
039B2:  MOVFF  7BC,7E6
039B6:  MOVFF  7BB,7E5
039BA:  MOVLB  0
039BC:  CALL   29E0
039C0:  MOVFF  03,7BE
039C4:  MOVFF  02,7BD
039C8:  MOVFF  01,7BC
039CC:  MOVFF  00,7BB
....................    for (i = 0; i <= 4; i++)
039D0:  MOVLB  7
039D2:  CLRF   xC4
039D4:  MOVF   xC4,W
039D6:  SUBLW  04
039D8:  BNC   3A94
....................    {
....................       t2 = t2 * t;
039DA:  MOVFF  7C2,7E4
039DE:  MOVFF  7C1,7E3
039E2:  MOVFF  7C0,7E2
039E6:  MOVFF  7BF,7E1
039EA:  MOVFF  7BE,7E8
039EE:  MOVFF  7BD,7E7
039F2:  MOVFF  7BC,7E6
039F6:  MOVFF  7BB,7E5
039FA:  MOVLB  0
039FC:  CALL   29E0
03A00:  MOVFF  03,7C2
03A04:  MOVFF  02,7C1
03A08:  MOVFF  01,7C0
03A0C:  MOVFF  00,7BF
....................       y = y + p[i] * t2;
03A10:  MOVLB  7
03A12:  MOVF   xC4,W
03A14:  MULLW  04
03A16:  MOVF   FF3,W
03A18:  CLRF   03
03A1A:  ADDLW  C9
03A1C:  MOVWF  FE9
03A1E:  MOVLW  07
03A20:  ADDWFC 03,W
03A22:  MOVWF  FEA
03A24:  MOVFF  FEF,7E1
03A28:  MOVFF  FEC,7E2
03A2C:  MOVFF  FEC,7E3
03A30:  MOVFF  FEC,7E4
03A34:  MOVFF  7C2,7E8
03A38:  MOVFF  7C1,7E7
03A3C:  MOVFF  7C0,7E6
03A40:  MOVFF  7BF,7E5
03A44:  MOVLB  0
03A46:  CALL   29E0
03A4A:  MOVFF  FEA,7DE
03A4E:  MOVFF  FE9,7DD
03A52:  BCF    FD8.1
03A54:  MOVFF  7BA,7E4
03A58:  MOVFF  7B9,7E3
03A5C:  MOVFF  7B8,7E2
03A60:  MOVFF  7B7,7E1
03A64:  MOVFF  03,7E8
03A68:  MOVFF  02,7E7
03A6C:  MOVFF  01,7E6
03A70:  MOVFF  00,7E5
03A74:  RCALL  3404
03A76:  MOVFF  7DE,FEA
03A7A:  MOVFF  7DD,FE9
03A7E:  MOVFF  03,7BA
03A82:  MOVFF  02,7B9
03A86:  MOVFF  01,7B8
03A8A:  MOVFF  00,7B7
03A8E:  MOVLB  7
03A90:  INCF   xC4,F
03A92:  BRA    39D4
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
03A94:  MOVF   xC3,W
03A96:  SUBLW  02
03A98:  BZ    3A9E
03A9A:  DECFSZ xC3,W
03A9C:  BRA    3AA4
....................       y = -y;  // correct sign
03A9E:  MOVF   xB8,W
03AA0:  XORLW  80
03AA2:  MOVWF  xB8
.................... 
....................    return (y);
03AA4:  MOVFF  7B7,00
03AA8:  MOVFF  7B8,01
03AAC:  MOVFF  7B9,02
03AB0:  MOVFF  7BA,03
03AB4:  MOVLB  0
03AB6:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
*
03C16:  BSF    FD8.1
03C18:  MOVFF  7AE,7E4
03C1C:  MOVFF  7AD,7E3
03C20:  MOVFF  7AC,7E2
03C24:  MOVFF  7AB,7E1
03C28:  MOVLW  DB
03C2A:  MOVLB  7
03C2C:  MOVWF  xE8
03C2E:  MOVLW  0F
03C30:  MOVWF  xE7
03C32:  MOVLW  49
03C34:  MOVWF  xE6
03C36:  MOVLW  7F
03C38:  MOVWF  xE5
03C3A:  MOVLB  0
03C3C:  CALL   3404
03C40:  MOVFF  03,7B2
03C44:  MOVFF  02,7B1
03C48:  MOVFF  01,7B0
03C4C:  MOVFF  00,7AF
03C50:  MOVFF  03,7B6
03C54:  MOVFF  02,7B5
03C58:  MOVFF  01,7B4
03C5C:  MOVFF  00,7B3
03C60:  RCALL  3734
03C62:  GOTO   3F54 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
0112C:  MOVFF  7A8,7AC
01130:  MOVFF  7A7,7AB
01134:  MOVFF  7AC,FEA
01138:  MOVLB  7
0113A:  MOVFF  7AB,FE9
0113E:  MOVF   FEF,F
01140:  BZ    114E
01142:  INCF   xAB,F
01144:  BTFSC  FD8.2
01146:  INCF   xAC,F
01148:  MOVLB  0
0114A:  BRA    1134
0114C:  MOVLB  7
....................    while(*s2 != '\0')
0114E:  MOVFF  7AA,FEA
01152:  MOVFF  7A9,FE9
01156:  MOVF   FEF,F
01158:  BZ    1180
....................    {
....................       *s = *s2;
0115A:  MOVFF  7AA,FEA
0115E:  MOVFF  7A9,FE9
01162:  MOVFF  FEF,7AF
01166:  MOVFF  7AC,FEA
0116A:  MOVFF  7AB,FE9
0116E:  MOVFF  7AF,FEF
....................       ++s;
01172:  INCF   xAB,F
01174:  BTFSC  FD8.2
01176:  INCF   xAC,F
....................       ++s2;
01178:  INCF   xA9,F
0117A:  BTFSC  FD8.2
0117C:  INCF   xAA,F
0117E:  BRA    114E
....................    }
.................... 
....................    *s = '\0';
01180:  MOVFF  7AC,FEA
01184:  MOVFF  7AB,FE9
01188:  CLRF   FEF
....................    return(s1);
0118A:  MOVFF  7A7,01
0118E:  MOVFF  7A8,02
01192:  MOVLB  0
01194:  RETURN 0
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
01196:  MOVFF  766,76C
0119A:  MOVFF  765,76B
0119E:  MOVFF  76C,FEA
011A2:  MOVLB  7
011A4:  MOVFF  76B,FE9
011A8:  MOVF   FEF,F
011AA:  BZ    11B8
011AC:  INCF   x6B,F
011AE:  BTFSC  FD8.2
011B0:  INCF   x6C,F
011B2:  MOVLB  0
011B4:  BRA    119E
011B6:  MOVLB  7
....................    while(*s2 != '\0' && 0<n)
011B8:  MOVFF  768,FEA
011BC:  MOVFF  767,FE9
011C0:  MOVF   FEF,F
011C2:  BZ    11FC
011C4:  MOVF   x6A,F
011C6:  BNZ   11CE
011C8:  MOVF   x69,W
011CA:  SUBLW  00
011CC:  BC    11FC
....................    {
....................       *s = *s2;
011CE:  MOVFF  768,FEA
011D2:  MOVFF  767,FE9
011D6:  MOVFF  FEF,76F
011DA:  MOVFF  76C,FEA
011DE:  MOVFF  76B,FE9
011E2:  MOVFF  76F,FEF
....................       ++s;
011E6:  INCF   x6B,F
011E8:  BTFSC  FD8.2
011EA:  INCF   x6C,F
....................       ++s2;
011EC:  INCF   x67,F
011EE:  BTFSC  FD8.2
011F0:  INCF   x68,F
....................       --n;
011F2:  MOVF   x69,W
011F4:  BTFSC  FD8.2
011F6:  DECF   x6A,F
011F8:  DECF   x69,F
011FA:  BRA    11B8
....................    }
.................... 
....................    *s = '\0';
011FC:  MOVFF  76C,FEA
01200:  MOVFF  76B,FE9
01204:  CLRF   FEF
....................    return(s1);
01206:  MOVFF  765,01
0120A:  MOVFF  766,02
0120E:  MOVLB  0
01210:  GOTO   12AC (RETURN)
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
0300E:  MOVFF  7DC,7DF
....................    for(su=s;0<n;++su,--n)
03012:  MOVFF  7DB,7E1
03016:  MOVFF  7DA,7E0
0301A:  MOVLB  7
0301C:  MOVF   xDE,F
0301E:  BNZ   3026
03020:  MOVF   xDD,W
03022:  SUBLW  00
03024:  BC    304E
....................       if(*su==uc)
03026:  MOVFF  7E1,FEA
0302A:  MOVFF  7E0,FE9
0302E:  MOVF   xDF,W
03030:  SUBWF  FEF,W
03032:  BNZ   303E
....................       return su;
03034:  MOVFF  7E0,01
03038:  MOVFF  7E1,02
0303C:  BRA    3054
0303E:  INCF   xE0,F
03040:  BTFSC  FD8.2
03042:  INCF   xE1,F
03044:  MOVF   xDD,W
03046:  BTFSC  FD8.2
03048:  DECF   xDE,F
0304A:  DECF   xDD,F
0304C:  BRA    301C
....................    return NULL;
0304E:  MOVLW  00
03050:  MOVWF  01
03052:  MOVWF  02
03054:  MOVLB  0
03056:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
02EE6:  MOVFF  7B0,7B4
02EEA:  MOVFF  7AF,7B3
02EEE:  MOVFF  7B4,FEA
02EF2:  MOVLB  7
02EF4:  MOVFF  7B3,FE9
02EF8:  MOVF   FEF,F
02EFA:  BZ    2F4C
....................       for (sc2 = s2; *sc2 != 0; sc2++)
02EFC:  MOVFF  7B2,7B6
02F00:  MOVFF  7B1,7B5
02F04:  MOVFF  7B6,FEA
02F08:  MOVFF  7B5,FE9
02F0C:  MOVF   FEF,F
02F0E:  BZ    2F40
....................          if (*sc1 == *sc2)
02F10:  MOVFF  7B4,03
02F14:  MOVFF  7B3,FE9
02F18:  MOVFF  03,FEA
02F1C:  MOVFF  FEF,7B7
02F20:  MOVFF  7B6,FEA
02F24:  MOVFF  7B5,FE9
02F28:  MOVF   FEF,W
02F2A:  SUBWF  xB7,W
02F2C:  BNZ   2F38
....................             return(sc1);
02F2E:  MOVFF  7B3,01
02F32:  MOVFF  7B4,02
02F36:  BRA    2F52
02F38:  INCF   xB5,F
02F3A:  BTFSC  FD8.2
02F3C:  INCF   xB6,F
02F3E:  BRA    2F04
02F40:  INCF   xB3,F
02F42:  BTFSC  FD8.2
02F44:  INCF   xB4,F
02F46:  MOVLB  0
02F48:  BRA    2EEE
02F4A:  MOVLB  7
....................    return(0);
02F4C:  MOVLW  00
02F4E:  MOVWF  01
02F50:  MOVWF  02
02F52:  MOVLB  0
02F54:  GOTO   2FBA (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
02E5E:  MOVFF  7B0,7B4
02E62:  MOVFF  7AF,7B3
02E66:  MOVFF  7B4,FEA
02E6A:  MOVLB  7
02E6C:  MOVFF  7B3,FE9
02E70:  MOVF   FEF,F
02E72:  BZ    2ECE
....................       for (sc2 = s2; ; sc2++)
02E74:  MOVFF  7B2,7B6
02E78:  MOVFF  7B1,7B5
....................     if (*sc2 == '\0')
02E7C:  MOVFF  7B6,FEA
02E80:  MOVFF  7B5,FE9
02E84:  MOVF   FEF,F
02E86:  BNZ   2E9E
....................        return(sc1 - s1);
02E88:  MOVF   xAF,W
02E8A:  SUBWF  xB3,W
02E8C:  MOVWF  00
02E8E:  MOVF   xB0,W
02E90:  SUBWFB xB4,W
02E92:  MOVWF  03
02E94:  MOVFF  00,01
02E98:  MOVWF  02
02E9A:  BRA    2EE0
02E9C:  BRA    2EBA
....................          else if (*sc1 == *sc2)
02E9E:  MOVFF  7B4,FEA
02EA2:  MOVFF  7B3,FE9
02EA6:  MOVFF  FEF,7B7
02EAA:  MOVFF  7B6,FEA
02EAE:  MOVFF  7B5,FE9
02EB2:  MOVF   FEF,W
02EB4:  SUBWF  xB7,W
02EB6:  BNZ   2EBA
....................             break;
02EB8:  BRA    2EC2
02EBA:  INCF   xB5,F
02EBC:  BTFSC  FD8.2
02EBE:  INCF   xB6,F
02EC0:  BRA    2E7C
02EC2:  INCF   xB3,F
02EC4:  BTFSC  FD8.2
02EC6:  INCF   xB4,F
02EC8:  MOVLB  0
02ECA:  BRA    2E66
02ECC:  MOVLB  7
....................    return(sc1 - s1);
02ECE:  MOVF   xAF,W
02ED0:  SUBWF  xB3,W
02ED2:  MOVWF  00
02ED4:  MOVF   xB0,W
02ED6:  SUBWFB xB4,W
02ED8:  MOVWF  03
02EDA:  MOVFF  00,01
02EDE:  MOVWF  02
02EE0:  MOVLB  0
02EE2:  GOTO   2F88 (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
015D6:  MOVFF  7B0,7B2
015DA:  MOVFF  7AF,7B1
015DE:  MOVFF  7B2,FEA
015E2:  MOVLB  7
015E4:  MOVFF  7B1,FE9
015E8:  MOVF   FEF,F
015EA:  BZ    15F8
015EC:  INCF   xB1,F
015EE:  BTFSC  FD8.2
015F0:  INCF   xB2,F
015F2:  MOVLB  0
015F4:  BRA    15DE
015F6:  MOVLB  7
....................    return(sc - s);
015F8:  MOVF   xAF,W
015FA:  SUBWF  xB1,W
015FC:  MOVWF  00
015FE:  MOVF   xB0,W
01600:  SUBWFB xB2,W
01602:  MOVWF  03
01604:  MOVFF  00,01
01608:  MOVWF  02
0160A:  MOVLB  0
0160C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
*
02F58:  MOVLB  7
02F5A:  MOVF   xA7,W
02F5C:  IORWF  xA8,W
02F5E:  BZ    2F68
02F60:  MOVFF  7A8,03
02F64:  MOVF   xA7,W
02F66:  BRA    2F6E
02F68:  MOVFF  1D,03
02F6C:  MOVF   1C,W
02F6E:  MOVWF  xAB
02F70:  MOVFF  03,7AC
....................    beg += strspn(beg, s2);
02F74:  MOVFF  7AC,7B0
02F78:  MOVFF  7AB,7AF
02F7C:  MOVFF  7AA,7B2
02F80:  MOVFF  7A9,7B1
02F84:  MOVLB  0
02F86:  BRA    2E5E
02F88:  MOVF   01,W
02F8A:  MOVLB  7
02F8C:  ADDWF  xAB,F
02F8E:  MOVF   02,W
02F90:  ADDWFC xAC,F
....................    if (*beg == '\0')
02F92:  MOVFF  7AC,FEA
02F96:  MOVFF  7AB,FE9
02F9A:  MOVF   FEF,F
02F9C:  BNZ   2FA6
....................       return(0);
02F9E:  MOVLW  00
02FA0:  MOVWF  01
02FA2:  MOVWF  02
02FA4:  BRA    300A
....................       
....................    end = strpbrk(beg, s2);
02FA6:  MOVFF  7AC,7B0
02FAA:  MOVFF  7AB,7AF
02FAE:  MOVFF  7AA,7B2
02FB2:  MOVFF  7A9,7B1
02FB6:  MOVLB  0
02FB8:  BRA    2EE6
02FBA:  MOVFF  02,7AE
02FBE:  MOVFF  01,7AD
....................    if (end != '\0')
02FC2:  MOVLB  7
02FC4:  MOVF   xAD,F
02FC6:  BNZ   2FCC
02FC8:  MOVF   xAE,F
02FCA:  BZ    2FE6
....................    {
....................       *end = '\0';
02FCC:  MOVFF  7AE,FEA
02FD0:  MOVFF  7AD,FE9
02FD4:  CLRF   FEF
....................       end++;
02FD6:  INCF   xAD,F
02FD8:  BTFSC  FD8.2
02FDA:  INCF   xAE,F
....................       save = end;
02FDC:  MOVFF  7AE,1D
02FE0:  MOVFF  7AD,1C
....................    }
02FE4:  BRA    3002
....................    else
....................       save = beg + strlen(beg);
02FE6:  MOVFF  7AC,7B0
02FEA:  MOVFF  7AB,7AF
02FEE:  MOVLB  0
02FF0:  CALL   15D6
02FF4:  MOVF   01,W
02FF6:  MOVLB  7
02FF8:  ADDWF  xAB,W
02FFA:  MOVWF  1C
02FFC:  MOVF   02,W
02FFE:  ADDWFC xAC,W
03000:  MOVWF  1D
....................    
....................    return(beg);
03002:  MOVFF  7AB,01
03006:  MOVFF  7AC,02
0300A:  MOVLB  0
0300C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
*
049CE:  MOVFF  69F,FEA
049D2:  MOVLB  6
049D4:  MOVFF  69E,FE9
049D8:  MOVFF  FEF,6A2
049DC:  MOVFF  6A1,FEA
049E0:  MOVFF  6A0,FE9
049E4:  MOVF   FEF,W
049E6:  SUBWF  xA2,W
049E8:  BZ    4A6A
049EA:  MOVFF  69F,FEA
049EE:  MOVFF  69E,FE9
049F2:  MOVFF  FEF,6A2
049F6:  MOVF   xA2,W
049F8:  SUBLW  40
049FA:  BC    4A02
049FC:  MOVF   xA2,W
049FE:  SUBLW  5A
04A00:  BC    4A0E
04A02:  MOVF   xA2,W
04A04:  SUBLW  60
04A06:  BC    4A94
04A08:  MOVF   xA2,W
04A0A:  SUBLW  7A
04A0C:  BNC   4A94
04A0E:  MOVFF  6A1,FEA
04A12:  MOVFF  6A0,FE9
04A16:  MOVFF  FEF,6A2
04A1A:  MOVF   xA2,W
04A1C:  SUBLW  40
04A1E:  BC    4A26
04A20:  MOVF   xA2,W
04A22:  SUBLW  5A
04A24:  BC    4A32
04A26:  MOVF   xA2,W
04A28:  SUBLW  60
04A2A:  BC    4A94
04A2C:  MOVF   xA2,W
04A2E:  SUBLW  7A
04A30:  BNC   4A94
04A32:  MOVFF  69F,FEA
04A36:  MOVFF  69E,FE9
04A3A:  MOVFF  FEF,6A2
04A3E:  MOVFF  6A1,FEA
04A42:  MOVFF  6A0,FE9
04A46:  MOVLW  20
04A48:  ADDWF  FEF,W
04A4A:  SUBWF  xA2,W
04A4C:  BZ    4A6A
04A4E:  MOVFF  6A1,FEA
04A52:  MOVFF  6A0,FE9
04A56:  MOVFF  FEF,6A2
04A5A:  MOVFF  69F,FEA
04A5E:  MOVFF  69E,FE9
04A62:  MOVLW  20
04A64:  ADDWF  FEF,W
04A66:  SUBWF  xA2,W
04A68:  BNZ   4A94
....................     s1++, s2++)
....................     if (*s1 == '\0')
04A6A:  MOVFF  69F,FEA
04A6E:  MOVFF  69E,FE9
04A72:  MOVF   FEF,F
04A74:  BNZ   4A7C
....................        return(0);
04A76:  MOVLW  00
04A78:  MOVWF  01
04A7A:  BRA    4ABE
04A7C:  MOVFF  69F,03
04A80:  MOVF   x9E,W
04A82:  INCF   x9E,F
04A84:  BTFSC  FD8.2
04A86:  INCF   x9F,F
04A88:  INCF   xA0,F
04A8A:  BTFSC  FD8.2
04A8C:  INCF   xA1,F
04A8E:  MOVLB  0
04A90:  BRA    49CE
04A92:  MOVLB  6
....................  return((*s1 < *s2) ? -1: 1);
04A94:  MOVFF  69F,03
04A98:  MOVFF  69E,FE9
04A9C:  MOVFF  03,FEA
04AA0:  MOVFF  FEF,6A2
04AA4:  MOVFF  6A1,03
04AA8:  MOVFF  6A0,FE9
04AAC:  MOVFF  03,FEA
04AB0:  MOVF   FEF,W
04AB2:  SUBWF  xA2,W
04AB4:  BC    4ABA
04AB6:  MOVLW  FF
04AB8:  BRA    4ABC
04ABA:  MOVLW  01
04ABC:  MOVWF  01
04ABE:  MOVLB  0
04AC0:  RETURN 0
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
04B28:  MOVLB  7
04B2A:  CLRF   x44
....................    sign = 0;
04B2C:  CLRF   x42
....................    base = 10;
04B2E:  MOVLW  0A
04B30:  MOVWF  x43
....................    result = 0;
04B32:  CLRF   x41
.................... 
....................    if (!s)
04B34:  MOVF   x3F,W
04B36:  IORWF  x40,W
04B38:  BNZ   4B40
....................       return 0;
04B3A:  MOVLW  00
04B3C:  MOVWF  01
04B3E:  BRA    4CB6
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
04B40:  MOVF   x44,W
04B42:  INCF   x44,F
04B44:  ADDWF  x3F,W
04B46:  MOVWF  FE9
04B48:  MOVLW  00
04B4A:  ADDWFC x40,W
04B4C:  MOVWF  FEA
04B4E:  MOVFF  FEF,745
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
04B52:  MOVF   x45,W
04B54:  SUBLW  2D
04B56:  BNZ   4B70
....................    {
....................       sign = 1;         // Set the sign to negative
04B58:  MOVLW  01
04B5A:  MOVWF  x42
....................       c = s[index++];
04B5C:  MOVF   x44,W
04B5E:  INCF   x44,F
04B60:  ADDWF  x3F,W
04B62:  MOVWF  FE9
04B64:  MOVLW  00
04B66:  ADDWFC x40,W
04B68:  MOVWF  FEA
04B6A:  MOVFF  FEF,745
....................    }
04B6E:  BRA    4B88
....................    else if (c == '+')
04B70:  MOVF   x45,W
04B72:  SUBLW  2B
04B74:  BNZ   4B88
....................    {
....................       c = s[index++];
04B76:  MOVF   x44,W
04B78:  INCF   x44,F
04B7A:  ADDWF  x3F,W
04B7C:  MOVWF  FE9
04B7E:  MOVLW  00
04B80:  ADDWFC x40,W
04B82:  MOVWF  FEA
04B84:  MOVFF  FEF,745
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
04B88:  MOVF   x45,W
04B8A:  SUBLW  2F
04B8C:  BTFSC  FD8.0
04B8E:  BRA    4CA6
04B90:  MOVF   x45,W
04B92:  SUBLW  39
04B94:  BTFSS  FD8.0
04B96:  BRA    4CA6
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
04B98:  MOVF   x45,W
04B9A:  SUBLW  30
04B9C:  BNZ   4BDA
04B9E:  MOVF   x44,W
04BA0:  ADDWF  x3F,W
04BA2:  MOVWF  FE9
04BA4:  MOVLW  00
04BA6:  ADDWFC x40,W
04BA8:  MOVWF  FEA
04BAA:  MOVF   FEF,W
04BAC:  SUBLW  78
04BAE:  BZ    4BC2
04BB0:  MOVF   x44,W
04BB2:  ADDWF  x3F,W
04BB4:  MOVWF  FE9
04BB6:  MOVLW  00
04BB8:  ADDWFC x40,W
04BBA:  MOVWF  FEA
04BBC:  MOVF   FEF,W
04BBE:  SUBLW  58
04BC0:  BNZ   4BDA
....................       {
....................          base = 16;
04BC2:  MOVLW  10
04BC4:  MOVWF  x43
....................          index++;
04BC6:  INCF   x44,F
....................          c = s[index++];
04BC8:  MOVF   x44,W
04BCA:  INCF   x44,F
04BCC:  ADDWF  x3F,W
04BCE:  MOVWF  FE9
04BD0:  MOVLW  00
04BD2:  ADDWFC x40,W
04BD4:  MOVWF  FEA
04BD6:  MOVFF  FEF,745
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
04BDA:  MOVF   x43,W
04BDC:  SUBLW  0A
04BDE:  BNZ   4C18
....................       {
....................          while (c >= '0' && c <= '9')
04BE0:  MOVF   x45,W
04BE2:  SUBLW  2F
04BE4:  BC    4C16
04BE6:  MOVF   x45,W
04BE8:  SUBLW  39
04BEA:  BNC   4C16
....................          {
....................             result = 10*result + (c - '0');
04BEC:  MOVLW  0A
04BEE:  MOVWF  x46
04BF0:  MOVFF  741,747
04BF4:  MOVLB  0
04BF6:  BRA    4AD8
04BF8:  MOVLW  30
04BFA:  MOVLB  7
04BFC:  SUBWF  x45,W
04BFE:  ADDWF  01,W
04C00:  MOVWF  x41
....................             c = s[index++];
04C02:  MOVF   x44,W
04C04:  INCF   x44,F
04C06:  ADDWF  x3F,W
04C08:  MOVWF  FE9
04C0A:  MOVLW  00
04C0C:  ADDWFC x40,W
04C0E:  MOVWF  FEA
04C10:  MOVFF  FEF,745
04C14:  BRA    4BE0
....................          }
....................       }
04C16:  BRA    4CA6
....................       else if (base == 16)    // The number is a hexa number
04C18:  MOVF   x43,W
04C1A:  SUBLW  10
04C1C:  BNZ   4CA6
....................       {
....................          c = toupper(c);
04C1E:  MOVF   x45,W
04C20:  SUBLW  60
04C22:  BC    4C30
04C24:  MOVF   x45,W
04C26:  SUBLW  7A
04C28:  BNC   4C30
04C2A:  MOVF   x45,W
04C2C:  ANDLW  DF
04C2E:  BRA    4C32
04C30:  MOVF   x45,W
04C32:  MOVWF  x45
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
04C34:  MOVF   x45,W
04C36:  SUBLW  2F
04C38:  BC    4C40
04C3A:  MOVF   x45,W
04C3C:  SUBLW  39
04C3E:  BC    4C4C
04C40:  MOVF   x45,W
04C42:  SUBLW  40
04C44:  BC    4CA6
04C46:  MOVF   x45,W
04C48:  SUBLW  46
04C4A:  BNC   4CA6
....................          {
....................             if (c >= '0' && c <= '9')
04C4C:  MOVF   x45,W
04C4E:  SUBLW  2F
04C50:  BC    4C6A
04C52:  MOVF   x45,W
04C54:  SUBLW  39
04C56:  BNC   4C6A
....................                result = (result << 4) + (c - '0');
04C58:  SWAPF  x41,W
04C5A:  MOVWF  x46
04C5C:  MOVLW  F0
04C5E:  ANDWF  x46,F
04C60:  MOVLW  30
04C62:  SUBWF  x45,W
04C64:  ADDWF  x46,W
04C66:  MOVWF  x41
04C68:  BRA    4C7C
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
04C6A:  SWAPF  x41,W
04C6C:  MOVWF  x46
04C6E:  MOVLW  F0
04C70:  ANDWF  x46,F
04C72:  MOVLW  41
04C74:  SUBWF  x45,W
04C76:  ADDLW  0A
04C78:  ADDWF  x46,W
04C7A:  MOVWF  x41
.................... 
....................             c = s[index++];
04C7C:  MOVF   x44,W
04C7E:  INCF   x44,F
04C80:  ADDWF  x3F,W
04C82:  MOVWF  FE9
04C84:  MOVLW  00
04C86:  ADDWFC x40,W
04C88:  MOVWF  FEA
04C8A:  MOVFF  FEF,745
....................             c = toupper(c);
04C8E:  MOVF   x45,W
04C90:  SUBLW  60
04C92:  BC    4CA0
04C94:  MOVF   x45,W
04C96:  SUBLW  7A
04C98:  BNC   4CA0
04C9A:  MOVF   x45,W
04C9C:  ANDLW  DF
04C9E:  BRA    4CA2
04CA0:  MOVF   x45,W
04CA2:  MOVWF  x45
04CA4:  BRA    4C34
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
04CA6:  DECFSZ x42,W
04CA8:  BRA    4CB2
04CAA:  MOVF   x43,W
04CAC:  SUBLW  0A
04CAE:  BNZ   4CB2
....................        result = -result;
04CB0:  NEGF   x41
.................... 
....................    return(result);
04CB2:  MOVFF  741,01
04CB6:  MOVLB  0
04CB8:  RETURN 0
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
*
01D66:  MOVLB  7
01D68:  CLRF   xA8
01D6A:  CLRF   xA7
01D6C:  CLRF   xA6
01D6E:  MOVLW  01
01D70:  MOVWF  xA5
01D72:  CLRF   xAA
01D74:  CLRF   xAB
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
01D76:  BTFSS  xA1.7
01D78:  BRA    1DAC
....................          sign=1;        // Check for negative number
01D7A:  MOVLW  01
01D7C:  MOVWF  xAA
....................          num*=-1;
01D7E:  MOVFF  7A1,7B0
01D82:  MOVFF  7A0,7AF
01D86:  MOVFF  79F,7AE
01D8A:  MOVFF  79E,7AD
01D8E:  SETF   xB4
01D90:  SETF   xB3
01D92:  SETF   xB2
01D94:  SETF   xB1
01D96:  MOVLB  0
01D98:  BRA    1C1E
01D9A:  MOVFF  03,7A1
01D9E:  MOVFF  02,7A0
01DA2:  MOVFF  01,79F
01DA6:  MOVFF  00,79E
01DAA:  MOVLB  7
....................      }
.................... 
....................      while(temp>0) {
01DAC:  MOVF   xA5,F
01DAE:  BNZ   1DBC
01DB0:  MOVF   xA6,F
01DB2:  BNZ   1DBC
01DB4:  MOVF   xA7,F
01DB6:  BNZ   1DBC
01DB8:  MOVF   xA8,F
01DBA:  BZ    1E90
....................          temp=(num/base);
01DBC:  BCF    FD8.1
01DBE:  MOVFF  7A1,7B8
01DC2:  MOVFF  7A0,7B7
01DC6:  MOVFF  79F,7B6
01DCA:  MOVFF  79E,7B5
01DCE:  CLRF   xBC
01DD0:  CLRF   xBB
01DD2:  CLRF   xBA
01DD4:  MOVFF  7A2,7B9
01DD8:  MOVLB  0
01DDA:  RCALL  1C7C
01DDC:  MOVFF  03,7A8
01DE0:  MOVFF  02,7A7
01DE4:  MOVFF  01,7A6
01DE8:  MOVFF  00,7A5
....................          s[cnt]=(num%base)+'0';    // Conversion
01DEC:  MOVLB  7
01DEE:  MOVF   xAB,W
01DF0:  ADDWF  xA3,W
01DF2:  MOVWF  01
01DF4:  MOVLW  00
01DF6:  ADDWFC xA4,W
01DF8:  MOVWF  03
01DFA:  MOVFF  01,7AD
01DFE:  MOVWF  xAE
01E00:  MOVFF  FEA,7B0
01E04:  MOVFF  FE9,7AF
01E08:  BSF    FD8.1
01E0A:  MOVLW  07
01E0C:  MOVWF  FEA
01E0E:  MOVLW  B1
01E10:  MOVWF  FE9
01E12:  MOVFF  7A1,7B8
01E16:  MOVFF  7A0,7B7
01E1A:  MOVFF  79F,7B6
01E1E:  MOVFF  79E,7B5
01E22:  CLRF   xBC
01E24:  CLRF   xBB
01E26:  CLRF   xBA
01E28:  MOVFF  7A2,7B9
01E2C:  MOVLB  0
01E2E:  RCALL  1C7C
01E30:  MOVFF  7B0,FEA
01E34:  MOVFF  7AF,FE9
01E38:  MOVLW  30
01E3A:  MOVLB  7
01E3C:  ADDWF  xB1,W
01E3E:  MOVWF  00
01E40:  MOVLW  00
01E42:  ADDWFC xB2,W
01E44:  MOVLW  00
01E46:  ADDWFC xB3,W
01E48:  MOVLW  00
01E4A:  ADDWFC xB4,W
01E4C:  MOVFF  7AE,FEA
01E50:  MOVFF  7AD,FE9
01E54:  MOVFF  00,FEF
.................... 
....................          if(s[cnt]>0x39)
01E58:  MOVF   xAB,W
01E5A:  ADDWF  xA3,W
01E5C:  MOVWF  FE9
01E5E:  MOVLW  00
01E60:  ADDWFC xA4,W
01E62:  MOVWF  FEA
01E64:  MOVF   FEF,W
01E66:  SUBLW  39
01E68:  BC    1E7C
....................             s[cnt]+=0x7;
01E6A:  MOVF   xAB,W
01E6C:  ADDWF  xA3,W
01E6E:  MOVWF  FE9
01E70:  MOVLW  00
01E72:  ADDWFC xA4,W
01E74:  MOVWF  FEA
01E76:  MOVLW  07
01E78:  ADDWF  FEF,W
01E7A:  MOVWF  FEF
.................... 
....................          cnt++;
01E7C:  INCF   xAB,F
....................          num=temp;
01E7E:  MOVFF  7A8,7A1
01E82:  MOVFF  7A7,7A0
01E86:  MOVFF  7A6,79F
01E8A:  MOVFF  7A5,79E
01E8E:  BRA    1DAC
....................      }
.................... 
....................      if(sign==1) {
01E90:  DECFSZ xAA,W
01E92:  BRA    1EA6
....................          s[cnt]=0x2D;      // Negative sign
01E94:  MOVF   xAB,W
01E96:  ADDWF  xA3,W
01E98:  MOVWF  FE9
01E9A:  MOVLW  00
01E9C:  ADDWFC xA4,W
01E9E:  MOVWF  FEA
01EA0:  MOVLW  2D
01EA2:  MOVWF  FEF
....................          cnt++;
01EA4:  INCF   xAB,F
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
01EA6:  CLRF   xA9
01EA8:  BCF    FD8.0
01EAA:  RRCF   xAB,W
01EAC:  SUBWF  xA9,W
01EAE:  BC    1F04
.................... 
....................          c=s[i];
01EB0:  MOVF   xA9,W
01EB2:  ADDWF  xA3,W
01EB4:  MOVWF  FE9
01EB6:  MOVLW  00
01EB8:  ADDWFC xA4,W
01EBA:  MOVWF  FEA
01EBC:  MOVFF  FEF,7AC
....................          s[i]=s[cnt-i-1];        // Reverse the number
01EC0:  MOVF   xA9,W
01EC2:  ADDWF  xA3,W
01EC4:  MOVWF  01
01EC6:  MOVLW  00
01EC8:  ADDWFC xA4,W
01ECA:  MOVWF  03
01ECC:  MOVF   xA9,W
01ECE:  SUBWF  xAB,W
01ED0:  ADDLW  FF
01ED2:  ADDWF  xA3,W
01ED4:  MOVWF  FE9
01ED6:  MOVLW  00
01ED8:  ADDWFC xA4,W
01EDA:  MOVWF  FEA
01EDC:  MOVFF  FEF,7AF
01EE0:  MOVFF  03,FEA
01EE4:  MOVFF  01,FE9
01EE8:  MOVFF  7AF,FEF
....................          s[cnt-i-1]=c;
01EEC:  MOVF   xA9,W
01EEE:  SUBWF  xAB,W
01EF0:  ADDLW  FF
01EF2:  ADDWF  xA3,W
01EF4:  MOVWF  FE9
01EF6:  MOVLW  00
01EF8:  ADDWFC xA4,W
01EFA:  MOVWF  FEA
01EFC:  MOVFF  7AC,FEF
01F00:  INCF   xA9,F
01F02:  BRA    1EA8
....................      }
....................      s[cnt]='\0';     // End the string
01F04:  MOVF   xAB,W
01F06:  ADDWF  xA3,W
01F08:  MOVWF  FE9
01F0A:  MOVLW  00
01F0C:  ADDWFC xA4,W
01F0E:  MOVWF  FEA
01F10:  CLRF   FEF
....................      return s;
01F12:  MOVFF  7A3,01
01F16:  MOVFF  7A4,02
01F1A:  MOVLB  0
01F1C:  GOTO   1FD2 (RETURN)
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
*
030AE:  MOVLB  7
030B0:  CLRF   xB3
030B2:  CLRF   xB2
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
030B4:  MOVLW  30
030B6:  MOVWF  xB5
030B8:  MOVLW  31
030BA:  MOVWF  xB6
030BC:  MOVLW  32
030BE:  MOVWF  xB7
030C0:  MOVLW  33
030C2:  MOVWF  xB8
030C4:  MOVLW  34
030C6:  MOVWF  xB9
030C8:  MOVLW  35
030CA:  MOVWF  xBA
030CC:  MOVLW  36
030CE:  MOVWF  xBB
030D0:  MOVLW  37
030D2:  MOVWF  xBC
030D4:  MOVLW  38
030D6:  MOVWF  xBD
030D8:  MOVLW  39
030DA:  MOVWF  xBE
030DC:  MOVLW  61
030DE:  MOVWF  xBF
030E0:  MOVLW  62
030E2:  MOVWF  xC0
030E4:  MOVLW  63
030E6:  MOVWF  xC1
030E8:  MOVLW  64
030EA:  MOVWF  xC2
030EC:  MOVLW  65
030EE:  MOVWF  xC3
030F0:  MOVLW  66
030F2:  MOVWF  xC4
030F4:  MOVLW  67
030F6:  MOVWF  xC5
030F8:  MOVLW  68
030FA:  MOVWF  xC6
030FC:  MOVLW  69
030FE:  MOVWF  xC7
03100:  MOVLW  6A
03102:  MOVWF  xC8
03104:  MOVLW  6B
03106:  MOVWF  xC9
03108:  MOVLW  6C
0310A:  MOVWF  xCA
0310C:  MOVLW  6D
0310E:  MOVWF  xCB
03110:  MOVLW  6E
03112:  MOVWF  xCC
03114:  MOVLW  6F
03116:  MOVWF  xCD
03118:  MOVLW  70
0311A:  MOVWF  xCE
0311C:  MOVLW  71
0311E:  MOVWF  xCF
03120:  MOVLW  73
03122:  MOVWF  xD0
03124:  MOVLW  74
03126:  MOVWF  xD1
03128:  MOVLW  75
0312A:  MOVWF  xD2
0312C:  MOVLW  76
0312E:  MOVWF  xD3
03130:  MOVLW  77
03132:  MOVWF  xD4
03134:  MOVLW  78
03136:  MOVWF  xD5
03138:  MOVLW  79
0313A:  MOVWF  xD6
0313C:  MOVLW  7A
0313E:  MOVWF  xD7
03140:  CLRF   xD8
....................    for(sc=s;isspace(*sc);++sc);
03142:  MOVFF  7A8,7AD
03146:  MOVFF  7A7,7AC
0314A:  MOVFF  7AD,FEA
0314E:  MOVFF  7AC,FE9
03152:  MOVF   FEF,W
03154:  SUBLW  20
03156:  BNZ   3160
03158:  INCF   xAC,F
0315A:  BTFSC  FD8.2
0315C:  INCF   xAD,F
0315E:  BRA    314A
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
03160:  MOVFF  7AD,03
03164:  MOVFF  7AC,FE9
03168:  MOVFF  03,FEA
0316C:  MOVF   FEF,W
0316E:  SUBLW  2D
03170:  BZ    3180
03172:  MOVFF  7AD,FEA
03176:  MOVFF  7AC,FE9
0317A:  MOVF   FEF,W
0317C:  SUBLW  2B
0317E:  BNZ   3192
03180:  MOVFF  7AD,FEA
03184:  MOVF   xAC,W
03186:  INCF   xAC,F
03188:  BTFSC  FD8.2
0318A:  INCF   xAD,F
0318C:  MOVWF  FE9
0318E:  MOVF   FEF,W
03190:  BRA    3194
03192:  MOVLW  2B
03194:  MOVWF  xB4
....................    if (base <0 || base ==1|| base >36) // invalid base
03196:  BTFSC  xAB.7
03198:  BRA    31AA
0319A:  DECFSZ xAB,W
0319C:  BRA    31A0
0319E:  BRA    31AA
031A0:  BTFSC  xAB.7
031A2:  BRA    31AE
031A4:  MOVF   xAB,W
031A6:  SUBLW  24
031A8:  BC    31AE
....................    goto StrtolGO;
031AA:  BRA    33AC
031AC:  BRA    32A6
....................    else if (base)
031AE:  MOVF   xAB,F
031B0:  BZ    323E
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
031B2:  MOVF   xAB,W
031B4:  SUBLW  10
031B6:  BNZ   31F2
031B8:  MOVFF  7AD,FEA
031BC:  MOVFF  7AC,FE9
031C0:  MOVF   FEF,W
031C2:  SUBLW  30
031C4:  BNZ   31F2
031C6:  MOVLW  01
031C8:  ADDWF  xAC,W
031CA:  MOVWF  FE9
031CC:  MOVLW  00
031CE:  ADDWFC xAD,W
031D0:  MOVWF  FEA
031D2:  MOVF   FEF,W
031D4:  SUBLW  78
031D6:  BZ    31EA
031D8:  MOVLW  01
031DA:  ADDWF  xAC,W
031DC:  MOVWF  FE9
031DE:  MOVLW  00
031E0:  ADDWFC xAD,W
031E2:  MOVWF  FEA
031E4:  MOVF   FEF,W
031E6:  SUBLW  58
031E8:  BNZ   31F2
....................          sc+=2;
031EA:  MOVLW  02
031EC:  ADDWF  xAC,F
031EE:  MOVLW  00
031F0:  ADDWFC xAD,F
....................       if(base==8 && *sc =='0')
031F2:  MOVF   xAB,W
031F4:  SUBLW  08
031F6:  BNZ   320E
031F8:  MOVFF  7AD,FEA
031FC:  MOVFF  7AC,FE9
03200:  MOVF   FEF,W
03202:  SUBLW  30
03204:  BNZ   320E
....................          sc+=1;
03206:  MOVLW  01
03208:  ADDWF  xAC,F
0320A:  MOVLW  00
0320C:  ADDWFC xAD,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
0320E:  MOVF   xAB,W
03210:  SUBLW  02
03212:  BNZ   323C
03214:  MOVFF  7AD,FEA
03218:  MOVFF  7AC,FE9
0321C:  MOVF   FEF,W
0321E:  SUBLW  30
03220:  BNZ   323C
03222:  MOVLW  01
03224:  ADDWF  xAC,W
03226:  MOVWF  FE9
03228:  MOVLW  00
0322A:  ADDWFC xAD,W
0322C:  MOVWF  FEA
0322E:  MOVF   FEF,W
03230:  SUBLW  62
03232:  BNZ   323C
....................          sc+=2;
03234:  MOVLW  02
03236:  ADDWF  xAC,F
03238:  MOVLW  00
0323A:  ADDWFC xAD,F
.................... 
....................    }
0323C:  BRA    32A6
....................    else if(*sc!='0') // base is 0, find base
0323E:  MOVFF  7AD,FEA
03242:  MOVFF  7AC,FE9
03246:  MOVF   FEF,W
03248:  SUBLW  30
0324A:  BZ    3252
....................       base=10;
0324C:  MOVLW  0A
0324E:  MOVWF  xAB
03250:  BRA    32A6
....................    else if (sc[1]=='x' || sc[1]=='X')
03252:  MOVLW  01
03254:  ADDWF  xAC,W
03256:  MOVWF  FE9
03258:  MOVLW  00
0325A:  ADDWFC xAD,W
0325C:  MOVWF  FEA
0325E:  MOVF   FEF,W
03260:  SUBLW  78
03262:  BZ    3276
03264:  MOVLW  01
03266:  ADDWF  xAC,W
03268:  MOVWF  FE9
0326A:  MOVLW  00
0326C:  ADDWFC xAD,W
0326E:  MOVWF  FEA
03270:  MOVF   FEF,W
03272:  SUBLW  58
03274:  BNZ   3284
....................       base =16,sc+=2;
03276:  MOVLW  10
03278:  MOVWF  xAB
0327A:  MOVLW  02
0327C:  ADDWF  xAC,F
0327E:  MOVLW  00
03280:  ADDWFC xAD,F
03282:  BRA    32A6
....................    else if(sc[1]=='b')
03284:  MOVLW  01
03286:  ADDWF  xAC,W
03288:  MOVWF  FE9
0328A:  MOVLW  00
0328C:  ADDWFC xAD,W
0328E:  MOVWF  FEA
03290:  MOVF   FEF,W
03292:  SUBLW  62
03294:  BNZ   32A2
....................       base=2,sc+=2;
03296:  MOVLW  02
03298:  MOVWF  xAB
0329A:  ADDWF  xAC,F
0329C:  MOVLW  00
0329E:  ADDWFC xAD,F
032A0:  BRA    32A6
....................    else
....................       base=8;
032A2:  MOVLW  08
032A4:  MOVWF  xAB
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
032A6:  MOVFF  7AD,7AF
032AA:  MOVFF  7AC,7AE
032AE:  MOVFF  7AD,FEA
032B2:  MOVFF  7AC,FE9
032B6:  MOVF   FEF,W
032B8:  SUBLW  30
032BA:  BNZ   32C4
032BC:  INCF   xAC,F
032BE:  BTFSC  FD8.2
032C0:  INCF   xAD,F
032C2:  BRA    32AE
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
032C4:  MOVFF  7AD,03
032C8:  MOVFF  7AC,FE9
032CC:  MOVFF  03,FEA
032D0:  MOVFF  FEF,7D9
032D4:  MOVF   xD9,W
032D6:  SUBLW  40
032D8:  BC    32E6
032DA:  MOVF   xD9,W
032DC:  SUBLW  5A
032DE:  BNC   32E6
032E0:  MOVF   xD9,W
032E2:  IORLW  20
032E4:  BRA    32E8
032E6:  MOVF   xD9,W
032E8:  MOVWF  xD9
032EA:  MOVLW  07
032EC:  MOVWF  xDB
032EE:  MOVLW  B5
032F0:  MOVWF  xDA
032F2:  MOVFF  7D9,7DC
032F6:  CLRF   xDE
032F8:  MOVFF  7AB,7DD
032FC:  BTFSC  xDD.7
032FE:  DECF   xDE,F
03300:  MOVLB  0
03302:  RCALL  300E
03304:  MOVFF  02,7B1
03308:  MOVFF  01,7B0
....................    for(;sd!=0;)
0330C:  MOVLB  7
0330E:  MOVF   xB0,F
03310:  BNZ   3316
03312:  MOVF   xB1,F
03314:  BZ    33A0
....................    {
....................       x=x*base+(int16)(sd-digits);
03316:  CLRF   03
03318:  MOVF   xAB,W
0331A:  MOVWF  00
0331C:  BTFSC  FE8.7
0331E:  DECF   03,F
03320:  MOVWF  xD9
03322:  MOVFF  03,7DA
03326:  MOVFF  7B3,7DC
0332A:  MOVFF  7B2,7DB
0332E:  MOVFF  03,7DE
03332:  MOVWF  xDD
03334:  MOVLB  0
03336:  BRA    3058
03338:  MOVLW  B5
0333A:  MOVLB  7
0333C:  SUBWF  xB0,W
0333E:  MOVWF  00
03340:  MOVLW  07
03342:  SUBWFB xB1,W
03344:  MOVWF  03
03346:  MOVF   00,W
03348:  ADDWF  01,W
0334A:  MOVWF  xB2
0334C:  MOVF   03,W
0334E:  ADDWFC 02,W
03350:  MOVWF  xB3
....................       ++sc;
03352:  INCF   xAC,F
03354:  BTFSC  FD8.2
03356:  INCF   xAD,F
....................       sd=memchr(digits,tolower(*sc),base);
03358:  MOVFF  7AD,FEA
0335C:  MOVFF  7AC,FE9
03360:  MOVFF  FEF,7D9
03364:  MOVF   xD9,W
03366:  SUBLW  40
03368:  BC    3376
0336A:  MOVF   xD9,W
0336C:  SUBLW  5A
0336E:  BNC   3376
03370:  MOVF   xD9,W
03372:  IORLW  20
03374:  BRA    3378
03376:  MOVF   xD9,W
03378:  MOVWF  xD9
0337A:  MOVLW  07
0337C:  MOVWF  xDB
0337E:  MOVLW  B5
03380:  MOVWF  xDA
03382:  MOVFF  7D9,7DC
03386:  CLRF   xDE
03388:  MOVFF  7AB,7DD
0338C:  BTFSC  xDD.7
0338E:  DECF   xDE,F
03390:  MOVLB  0
03392:  RCALL  300E
03394:  MOVFF  02,7B1
03398:  MOVFF  01,7B0
0339C:  BRA    330C
0339E:  MOVLB  7
....................    }
....................    if(s1==sc)
033A0:  MOVF   xAC,W
033A2:  SUBWF  xAE,W
033A4:  BNZ   33CE
033A6:  MOVF   xAD,W
033A8:  SUBWF  xAF,W
033AA:  BNZ   33CE
....................    {
....................    StrtolGO:
....................       if (endptr)
033AC:  MOVLB  7
033AE:  MOVF   xA9,W
033B0:  IORWF  xAA,W
033B2:  BZ    33C6
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
033B4:  MOVFF  7AA,FEA
033B8:  MOVFF  7A9,FE9
033BC:  MOVFF  7A8,FEC
033C0:  MOVF   FED,F
033C2:  MOVFF  7A7,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
033C6:  MOVLW  00
033C8:  MOVWF  01
033CA:  MOVWF  02
033CC:  BRA    33FE
....................    }
....................    if(sign=='-')
033CE:  MOVF   xB4,W
033D0:  SUBLW  2D
033D2:  BNZ   33DE
....................       x  =-x;
033D4:  COMF   xB2,F
033D6:  COMF   xB3,F
033D8:  INCF   xB2,F
033DA:  BTFSC  FD8.2
033DC:  INCF   xB3,F
....................    if (endptr)
033DE:  MOVF   xA9,W
033E0:  IORWF  xAA,W
033E2:  BZ    33F6
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
033E4:  MOVFF  7AA,FEA
033E8:  MOVFF  7A9,FE9
033EC:  MOVFF  7AD,FEC
033F0:  MOVF   FED,F
033F2:  MOVFF  7AC,FEF
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
033F6:  MOVFF  7B2,01
033FA:  MOVFF  7B3,02
033FE:  MOVLB  0
03400:  GOTO   3D46 (RETURN)
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... /// TODO
.................... 
.................... /// intmax_t uintmax_t
.................... 
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX
.................... 
.................... /// INTMAX_C(value) UINTMAX_C(value)
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <arQ1010/globalVariables.h>
.................... #define BUFFER_SIZE      255
.................... 
.................... //reusable variables
.................... //int timeOut=0;
.................... //int try=0;
.................... char TOKEN[10]={};
.................... 
.................... //char funcReturnVar[BUFFER_SIZE]={}; //Global string variable used for functions returning string values 
.................... 
.................... //Variables for BTD200
.................... //Variables for USB Serial Interrupt RDA2
.................... char INTERRUPTUSB_Rxd[20]={};
.................... int1 InterruptUSB_Flag=0;
.................... int InterruptUSB_Counter=0;
.................... 
.................... //Variables for USB Serial Interrupt RDA2
.................... char InterruptGSM_Rxd[BUFFER_SIZE]={};
.................... int1 InterruptGSM_Flag=0;
.................... int InterruptGSM_Counter=0;
.................... int READ_CNTR = 0;
.................... 
.................... //Variables for gsm.c
.................... int NETWORK=0; //Registered GSM Network
.................... char SERVERNUMBER[15]={};
.................... char MYNUMBER1[15]={};
.................... char MYNUMBER2[15]={};
.................... char SMS_RCV[BUFFER_SIZE] = {};
.................... //char SMS_TOBE_SENT[BUFFER_SIZE]={};
.................... int1 EXT_FLAG=0;
.................... char GSM_RESPONSE[BUFFER_SIZE]={};
.................... char DESIRED_RESPONSE[17]={};
.................... //char BTDmessage[255] = {};
.................... 
.................... 
.................... 
.................... 
.................... //char cx[90] = {0xff, 0xff, 0x57, 0x00, 0x20, 0x00, 0x04, 0x26, 0x01, 0x04, 0x28, 0x0f, 0x01, 0x04, 0x16, 0x84, 0x00, 0x81, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x0c, 0xaf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0xde, 0x4d, 0x89, 0x3c}; 
.................... //char cx[90] = {0xff, 0xff, 0x57, 0x00, 0x20, 0x00, 0x04, 0x26, 0x01, 0x04, 0x28, 0x0f, 0x01, 0x04, 0x16, 0x84, 0x00, 0x81, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0xfe, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0x4d, 0x01, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0x68, 0x01, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0xdd, 0x00, 0x01, 0x01, 0x00, 0xde, 0x4d, 0x89, 0x3c};
.................... //char cx[90] = {};
.................... 
.................... int SEC=0;
.................... int MIN=0;
.................... int HOUR=0;
.................... int DAY=0;
.................... int MONTH=0;
.................... int YEAR=0;
.................... int YEAR_PREV=0;
.................... //char globalDT[20]={};
.................... 
.................... //char cx[100] = {};
.................... char strDateTime[20]={};
.................... char biralBT[20]={};
.................... char BTDLaLo[150]={};
.................... char distDir[10] = {};
.................... //char DTindex[5] = {};
.................... Char flashCount[10] = {};
.................... char strBTD_con [10] = {};
.................... char strBTD_info [20] = {};
.................... char btdCode[20] = {};
.................... //int BTDhealth[2] = {};
.................... 
.................... //long int reCounter = 0;
.................... //char btdRestart[2] = {};
.................... 
.................... 
.................... //char message[255]={};
.................... int powerGSMready = 0;
.................... 
.................... int SENDING_TIME=15;
.................... int1 SAMPLINGFLAG=FALSE;
.................... int1 CHECKMINUTE=0;
.................... int HOUROLD=0;
.................... int1 RESETCPU=0;
.................... 
.................... int1 TESTFLAG=0;
.................... int1 SYNCFLAG=0;
.................... int1 RESETFLAG=0;
.................... //!
.................... //!//int const CONNECT = 0xE0;
.................... //!int const DATETIME = 0xE1;
.................... //!int const SENSORTEST = 0xE2;
.................... //!int const FIRMWAREMODE = 0xE3;
.................... //!int const EXITCONFIG = 0xE4;
.................... //!int const FIRMWARECHAR = 0xE5;
.................... //!int const GOOD_DATA = 0xE6;
.................... //!int const BAD_DATA = 0xE7;
.................... //!int const SENSORINI = 0xE8;
.................... //!int const CONFIGSET = 0xEA;
.................... //!int const REDOWNLOADFIRMWARE = 0xEB;
.................... //!int const FIRMWAREFLASHDOWNLOAD = 0xEC;
.................... //!int const GSMTEST = 0xED;
.................... //!int const SATELLITE_TEST = 0xEE;
.................... 
.................... 
.................... 
.................... #include <arQ1010/pinDefinitions.c>
.................... 
.................... //**** RS485 *****//
.................... #define  TX2_RS485        PIN_E4
.................... #define  RX2_RS485        PIN_E7
.................... #define  EN_DE_RS485        PIN_E5
.................... #define  EN_RE_RS485        PIN_E6
.................... 
.................... //**** EXPOSED PIN FOR RS232
.................... #define  EN_UART        PIN_D1
.................... 
.................... //**** I2C PINS 
.................... #define  EN_I2C   PIN_D4
.................... #define  SDA_I2C  PIN_D5
.................... #define  SCL_I2C  PIN_D6
.................... 
.................... //**** SWITCH TO SELECT WHAT BATTERY TO USE
.................... #define  ENBA     PIN_J2
.................... #define  ENBB     PIN_J3
.................... 
.................... //**** GSM
.................... #define  RING_OUT    PIN_B1
.................... #define  RTS      PIN_A6
.................... #define  pin_CTS      PIN_A7
.................... #define  IGT      PIN_C2
.................... 
.................... //**** HARDWARE UART
.................... #define  RX_INT      PIN_C6
.................... #define  TX_INT      PIN_C5
.................... 
.................... #define  RX_USB       PIN_G2
.................... #define  TX_USB       PIN_G1
.................... 
.................... //**** RS232
.................... #define  TX_B        PIN_G4
.................... #define  RX_B        PIN_G3
.................... 
.................... //**** DIGITAL OUT
.................... #define  pin_OUT1        PIN_A3
.................... #define  OUT2        PIN_A2
.................... #define  OUT3        PIN_A1
.................... 
.................... //**** DIGITAL INPUTS
.................... #define  INTRUP4     PIN_D7
.................... #define  INTRUP1     PIN_B0
.................... #define  INTRUP2     PIN_B2
.................... #define  INTRUP3     PIN_B3
.................... 
.................... //**** SPI
.................... #define  SDO1        PIN_C5
.................... #define  SDA1        PIN_C4
.................... #define  SCK1        PIN_C3
.................... #define  EN1         PIN_F4
.................... #define  CS1         PIN_F5
.................... 
.................... //#define THUNDER_CS PIN_F4
.................... //#define SCP_CSB PIN_F4
.................... 
.................... //**** FLASH CHIP ENABLE
.................... #define  CS          PIN_E0
.................... 
.................... //**** USB PIN CHECK
.................... #define  pin_USB_STAT    PIN_G0
.................... 
.................... //**** DUAL COLOR LED
.................... #define  LED_STAT_A     PIN_E1
.................... #define  LED_STAT_B     PIN_H3
.................... 
.................... //**** SHT11
.................... #define  SHT_DATA_PIN       PIN_H2
.................... #define  SHT_CLK_PIN         PIN_B4
.................... 
.................... 
.................... //**** RESET
.................... #define  MCLR        PIN_G5
.................... 
.................... //**** ADC
.................... #define  VBAT_ADC       PIN_F7  //channel 5 3.3V MONITORING
.................... #define  IBOOST_ADC     PIN_H4  //channel 12 BOOST MONITORING
.................... #define  VBOOST_ADC     PIN_H5  //channel 13 BOOST MONITORING
.................... #define  IBOOST2_ADC    PIN_H7  //channel 15 BOOST MONITORING
.................... #define  VBOOST2_ADC    PIN_H6  //channel 14 BOOST MONITORING
.................... #define  VEXT1_ADC      PIN_F3  //channel 8 EXTERNAL ADC1
.................... #define  VEXT2_ADC      PIN_F2  //channel 7 EXTERNAL ADC2
.................... #define  INA_ADC        PIN_A5  //channel 4 INPUT VOLTAGE MONITORING 1
.................... #define  INB_ADC        PIN_A0  //channel 0 INPUT VOLTAGE MONITORING 2
.................... 
.................... #define  channel_VBAT_ADC       5  //channel 5 3.3V MONITORING
.................... #define  channel_IBOOST_ADC     12 //channel 12 BOOST MONITORING
.................... #define  channel_VBOOST_ADC     13  //channel 13 BOOST MONITORING
.................... #define  channel_IBOOST2_ADC    15  //channel 15 BOOST MONITORING
.................... #define  channel_VBOOST2_ADC    14  //channel 14 BOOST MONITORING
.................... #define  channel_VEXT1_ADC      8  //channel 8 EXTERNAL ADC1
.................... #define  channel_VEXT2_ADC      7  //channel 7 EXTERNAL ADC2
.................... #define  channel_INA_ADC        4  //channel 4 INPUT VOLTAGE MONITORING 1
.................... #define  channel_INB_ADC        0  //channel 0 INPUT VOLTAGE MONITORING 2
.................... 
.................... 
.................... //**** POWER BOARD PINS
.................... #define  pin_BOOST1          PIN_D0  //BOOST SWITCH
.................... #define  pin_BOOST2          PIN_F1  //BOOST SWITCH
.................... #define  pin_CHRG_STAT1     PIN_J7
.................... #define  pin_FAULT_STAT1    PIN_J6
.................... #define  pin_CHRG_STAT2     PIN_J4
.................... #define  pin_FAULT_STAT2    PIN_J5
.................... 
.................... 
.................... 
.................... #include <arQ1010/interruptSerial2_USB.c>
.................... #use rs232(baud=57600, xmit=TX_USB, rcv=RX_USB, stream=USB)
.................... 
.................... #int_rda2 //RS232 receive data available in buffer 2
.................... 
.................... void rda2_isr(void){
....................    InterruptUSB_Flag = 1;
*
002C4:  BSF    40.0
....................    InterruptUSB_Rxd[InterruptUSB_Counter++]=fgetc(USB);
002C6:  MOVF   41,W
002C8:  INCF   41,F
002CA:  CLRF   03
002CC:  ADDLW  2C
002CE:  MOVWF  FE9
002D0:  MOVLW  00
002D2:  ADDWFC 03,W
002D4:  MOVWF  FEA
002D6:  BTFSS  FA4.5
002D8:  BRA    02D6
002DA:  MOVLB  F
002DC:  MOVFF  F1D,FEF
....................    InterruptUSB_Rxd[InterruptUSB_Counter]=0x00; //'\0' or 'NULL' terminating character 
002E0:  CLRF   03
002E2:  MOVF   41,W
002E4:  ADDLW  2C
002E6:  MOVWF  FE9
002E8:  MOVLW  00
002EA:  ADDWFC 03,W
002EC:  MOVWF  FEA
002EE:  CLRF   FEF
002F0:  BCF    FA4.5
002F2:  MOVLB  0
002F4:  GOTO   0098
.................... }
.................... 
.................... void clear_InterruptUSB(){  
....................    //InterruptUSB_Rxd[0]='\0';
....................    strcpy(InterruptUSB_Rxd,"");
*
00F6E:  CLRF   FEA
00F70:  MOVLW  2C
00F72:  MOVWF  FE9
00F74:  MOVLW  00
00F76:  CALL   00EE
00F7A:  TBLRD*-
00F7C:  TBLRD*+
00F7E:  MOVF   FF5,W
00F80:  MOVWF  FEE
00F82:  IORLW  00
00F84:  BNZ   0F7C
....................    InterruptUSB_Flag=0;
00F86:  BCF    40.0
....................    InterruptUSB_Counter=0;
00F88:  CLRF   41
00F8A:  RETURN 0
.................... }
.................... 
.................... 
.................... void getDataFromUSB(){
....................    clear_InterruptUSB();
*
04AC2:  CALL   0F6E
....................    while(!InterruptUSB_Flag);
04AC6:  BTFSS  40.0
04AC8:  BRA    4AC6
....................    delay_ms(50); //needed to stabilize USB input
04ACA:  MOVLW  32
04ACC:  MOVLB  7
04ACE:  MOVWF  x6D
04AD0:  MOVLB  0
04AD2:  CALL   0F16
04AD6:  RETURN 0
.................... }
.................... 
.................... 
.................... #include <arQ1010/InterruptSerial1_GSM.c>
.................... //#use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=GSM)
.................... 
.................... #int_rda
.................... void rda_isr(void)
.................... {
....................    InterruptGSM_Flag = 1;
*
002F8:  BSF    40.1
....................    InterruptGSM_Rxd[InterruptGSM_Counter++]=fgetc(GSM);
002FA:  MOVLB  1
002FC:  MOVF   x41,W
002FE:  INCF   x41,F
00300:  CLRF   03
00302:  ADDLW  42
00304:  MOVWF  FE9
00306:  MOVLW  00
00308:  ADDWFC 03,W
0030A:  MOVWF  FEA
0030C:  BTFSS  F9E.5
0030E:  BRA    030C
00310:  MOVFF  FAE,FEF
....................    //InterruptGSM_Rxd[InterruptGSM_Counter]=0x00;
00314:  BCF    F9E.5
00316:  MOVLB  0
00318:  GOTO   0098
.................... }
.................... 
.................... void clear_InterruptGSM()
*
0153E:  MOVLB  7
01540:  CLRF   x6A
.................... {
....................    int i=0;
....................    
....................    for (i=0;i<BUFFER_SIZE;i++)
01542:  CLRF   x6A
01544:  INCFSZ x6A,W
01546:  BRA    154A
01548:  BRA    156E
....................    {
....................       InterruptGSM_Rxd[i]=NULL;
0154A:  CLRF   03
0154C:  MOVF   x6A,W
0154E:  ADDLW  42
01550:  MOVWF  FE9
01552:  MOVLW  00
01554:  ADDWFC 03,W
01556:  MOVWF  FEA
01558:  CLRF   FEF
....................       GSM_RESPONSE[i]=NULL;
0155A:  CLRF   03
0155C:  MOVF   x6A,W
0155E:  ADDLW  70
01560:  MOVWF  FE9
01562:  MOVLW  02
01564:  ADDWFC 03,W
01566:  MOVWF  FEA
01568:  CLRF   FEF
0156A:  INCF   x6A,F
0156C:  BRA    1544
....................    }
.................... 
....................    InterruptGSM_Counter=0;
0156E:  MOVLB  1
01570:  CLRF   x41
....................    READ_CNTR=0;
01572:  CLRF   x42
....................    InterruptGSM_Flag=0;
01574:  BCF    40.1
01576:  MOVLB  0
01578:  RETURN 0
.................... }
.................... 
.................... void getDataFromGSM()
.................... {
....................    clear_InterruptGSM();
....................    while(!InterruptGSM_Flag);
....................    delay_ms(50); //needed to stabilize USB input
.................... }
.................... 
.................... //!void clear_InterruptGSM()
.................... //!{  
.................... //!   strcpy(InterruptGSM_Rxd,"");
.................... //!   InterruptGSM_Flag=0;
.................... //!   InterruptGSM_Counter=0;
.................... //!   READ_CNTR=0;
.................... //!
.................... //!}
.................... 
.................... 
.................... char *GetResponse(void)
*
0160E:  MOVLB  7
01610:  CLRF   x6A
01612:  CLRF   x6B
01614:  CLRF   x6C
.................... {
....................    int tempCntr = 0;
....................    int i=0, len=0;
....................    
....................    len = strlen(DESIRED_RESPONSE);
01616:  MOVLW  03
01618:  MOVWF  xB0
0161A:  MOVLW  6F
0161C:  MOVWF  xAF
0161E:  MOVLB  0
01620:  RCALL  15D6
01622:  MOVFF  01,76C
....................    while(((InterruptGSM_Counter - READ_CNTR) < len) && ++tempCntr < 30) delay_ms(100);
01626:  MOVLB  1
01628:  MOVF   x42,W
0162A:  SUBWF  x41,W
0162C:  MOVLB  7
0162E:  SUBWF  x6C,W
01630:  BZ    1648
01632:  BNC   1648
01634:  INCF   x6A,F
01636:  MOVF   x6A,W
01638:  SUBLW  1D
0163A:  BNC   1648
0163C:  MOVLW  64
0163E:  MOVWF  x6D
01640:  MOVLB  0
01642:  RCALL  0F16
01644:  BRA    1626
01646:  MOVLB  7
.................... 
....................    len = READ_CNTR;
01648:  MOVFF  142,76C
....................    if(tempCntr < 30)
0164C:  MOVF   x6A,W
0164E:  SUBLW  1D
01650:  BTFSS  FD8.0
01652:  BRA    17D8
....................    {
....................       tempCntr = 0;
01654:  CLRF   x6A
....................       do
....................       {
....................          do
....................          {                                                                                      
....................             for(; (READ_CNTR != InterruptGSM_Counter) && (InterruptGSM_Rxd[READ_CNTR] != DESIRED_RESPONSE[0]); READ_CNTR=(READ_CNTR+1) % BUFFER_SIZE);
01656:  MOVLB  1
01658:  MOVF   x41,W
0165A:  SUBWF  x42,W
0165C:  BZ    16A4
0165E:  CLRF   03
01660:  MOVF   x42,W
01662:  ADDLW  42
01664:  MOVWF  FE9
01666:  MOVLW  00
01668:  ADDWFC 03,W
0166A:  MOVWF  FEA
0166C:  MOVLB  3
0166E:  MOVF   x6F,W
01670:  SUBWF  FEF,W
01672:  BTFSS  FD8.2
01674:  BRA    167A
01676:  MOVLB  1
01678:  BRA    16A4
0167A:  MOVLW  01
0167C:  MOVLB  1
0167E:  ADDWF  x42,W
01680:  MOVLB  7
01682:  MOVWF  x6E
01684:  CLRF   1B
01686:  BTFSC  FF2.7
01688:  BSF    1B.7
0168A:  BCF    FF2.7
0168C:  MOVWF  xF4
0168E:  SETF   xF5
01690:  MOVLB  0
01692:  CALL   0642
01696:  BTFSC  1B.7
01698:  BSF    FF2.7
0169A:  MOVFF  00,142
0169E:  MOVLB  7
016A0:  BRA    1656
016A2:  MOVLB  1
....................             for(i = 0; (READ_CNTR != InterruptGSM_Counter) && (InterruptGSM_Rxd[READ_CNTR] == DESIRED_RESPONSE[i]) && (DESIRED_RESPONSE[i] != 0); i++, READ_CNTR=(READ_CNTR+1) % BUFFER_SIZE);
016A4:  MOVLB  7
016A6:  CLRF   x6B
016A8:  MOVLB  1
016AA:  MOVF   x41,W
016AC:  SUBWF  x42,W
016AE:  BZ    1724
016B0:  CLRF   03
016B2:  MOVF   x42,W
016B4:  ADDLW  42
016B6:  MOVWF  FE9
016B8:  MOVLW  00
016BA:  ADDWFC 03,W
016BC:  MOVWF  FEA
016BE:  MOVFF  FEF,76D
016C2:  CLRF   03
016C4:  MOVLB  7
016C6:  MOVF   x6B,W
016C8:  ADDLW  6F
016CA:  MOVWF  FE9
016CC:  MOVLW  03
016CE:  ADDWFC 03,W
016D0:  MOVWF  FEA
016D2:  MOVF   FEF,W
016D4:  SUBWF  x6D,W
016D6:  BTFSC  FD8.2
016D8:  BRA    16DE
016DA:  MOVLB  1
016DC:  BRA    1724
016DE:  CLRF   03
016E0:  MOVF   x6B,W
016E2:  ADDLW  6F
016E4:  MOVWF  FE9
016E6:  MOVLW  03
016E8:  ADDWFC 03,W
016EA:  MOVWF  FEA
016EC:  MOVF   FEF,F
016EE:  BTFSS  FD8.2
016F0:  BRA    16F6
016F2:  MOVLB  1
016F4:  BRA    1724
016F6:  MOVF   x6B,W
016F8:  INCF   x6B,F
016FA:  MOVLW  01
016FC:  MOVLB  1
016FE:  ADDWF  x42,W
01700:  MOVLB  7
01702:  MOVWF  x6E
01704:  CLRF   1B
01706:  BTFSC  FF2.7
01708:  BSF    1B.7
0170A:  BCF    FF2.7
0170C:  MOVWF  xF4
0170E:  SETF   xF5
01710:  MOVLB  0
01712:  CALL   0642
01716:  BTFSC  1B.7
01718:  BSF    FF2.7
0171A:  MOVFF  00,142
0171E:  MOVLB  7
01720:  BRA    16A8
01722:  MOVLB  1
....................             if(DESIRED_RESPONSE[i] == 0)
01724:  CLRF   03
01726:  MOVLB  7
01728:  MOVF   x6B,W
0172A:  ADDLW  6F
0172C:  MOVWF  FE9
0172E:  MOVLW  03
01730:  ADDWFC 03,W
01732:  MOVWF  FEA
01734:  MOVF   FEF,F
01736:  BNZ   17A0
....................             {
....................                // TODO: insert delay if necessary
....................                InterruptGSM_Rxd[InterruptGSM_Counter] = 0; // terminate string
01738:  CLRF   03
0173A:  MOVLB  1
0173C:  MOVF   x41,W
0173E:  ADDLW  42
01740:  MOVWF  FE9
01742:  MOVLW  00
01744:  ADDWFC 03,W
01746:  MOVWF  FEA
01748:  CLRF   FEF
....................                len = (InterruptGSM_Counter - READ_CNTR);
0174A:  MOVF   x42,W
0174C:  SUBWF  x41,W
0174E:  MOVLB  7
01750:  MOVWF  x6C
....................                for(i = 0; i <= len; i++)
01752:  CLRF   x6B
01754:  MOVF   x6B,W
01756:  SUBWF  x6C,W
01758:  BNC   1792
....................                {
....................                   GSM_RESPONSE[i] = InterruptGSM_Rxd[READ_CNTR + i];
0175A:  CLRF   03
0175C:  MOVF   x6B,W
0175E:  ADDLW  70
01760:  MOVWF  01
01762:  MOVLW  02
01764:  ADDWFC 03,F
01766:  MOVFF  03,76E
0176A:  MOVF   x6B,W
0176C:  MOVLB  1
0176E:  ADDWF  x42,W
01770:  CLRF   03
01772:  ADDLW  42
01774:  MOVWF  FE9
01776:  MOVLW  00
01778:  ADDWFC 03,W
0177A:  MOVWF  FEA
0177C:  MOVFF  FEF,76F
01780:  MOVLB  7
01782:  MOVFF  76E,FEA
01786:  MOVFF  01,FE9
0178A:  MOVFF  76F,FEF
0178E:  INCF   x6B,F
01790:  BRA    1754
....................                   //fprintf(USB,"%c",GSM_RESPONSE[i]);
....................                }
....................                READ_CNTR = InterruptGSM_Counter;
01792:  MOVFF  141,142
....................                return &GSM_RESPONSE[0];
01796:  MOVLW  70
01798:  MOVWF  01
0179A:  MOVLW  02
0179C:  MOVWF  02
0179E:  BRA    17E2
....................                
....................             }
....................          } while((DESIRED_RESPONSE[i] != 0) && (READ_CNTR != InterruptGSM_Counter));
017A0:  CLRF   03
017A2:  MOVF   x6B,W
017A4:  ADDLW  6F
017A6:  MOVWF  FE9
017A8:  MOVLW  03
017AA:  ADDWFC 03,W
017AC:  MOVWF  FEA
017AE:  MOVF   FEF,F
017B0:  BZ    17BE
017B2:  MOVLB  1
017B4:  MOVF   x41,W
017B6:  SUBWF  x42,W
017B8:  BTFSS  FD8.2
017BA:  BRA    1658
017BC:  MOVLB  7
....................          delay_ms(100);
017BE:  MOVLW  64
017C0:  MOVWF  x6D
017C2:  MOVLB  0
017C4:  CALL   0F16
....................          READ_CNTR = len;
017C8:  MOVFF  76C,142
....................       } while(++tempCntr < 10);
017CC:  MOVLB  7
017CE:  INCF   x6A,F
017D0:  MOVF   x6A,W
017D2:  SUBLW  09
017D4:  BTFSC  FD8.0
017D6:  BRA    1656
....................    }
.................... 
....................    READ_CNTR = InterruptGSM_Counter;
017D8:  MOVFF  141,142
.................... 
.................... //    TODO: for debugging purposes, to be removed
.................... //   fprintf(PC, "\r\nMessage Received:");
.................... //   for(; len != InterruptGSM_Cunter; len++)
.................... //   {
.................... //      fprintf(PC, "%c", RXD_DATA[len]);
.................... //   }
.................... //   fprintf(PC, "READ_CNTR=%i\n", read_cntr);
.................... //   fprintf(PC, "InterruptGSM_Counter=%i\n", write_cntr);
....................    return NULL; // no match found
017DC:  MOVLW  00
017DE:  MOVWF  01
017E0:  MOVWF  02
017E2:  MOVLB  0
017E4:  GOTO   181C (RETURN)
....................  }
.................... 
.................... 
.................... #include <arQ1010/interruptExt1_GSM.c>
.................... 
.................... #int_ext1
.................... void ext_isr1(void)
.................... {
....................    EXT_FLAG=1;
*
0031C:  BSF    40.2
....................    strcpy(SMS_RCV,InterruptGSM_Rxd);
0031E:  MOVLW  01
00320:  MOVWF  FEA
00322:  MOVLW  71
00324:  MOVWF  FE9
00326:  CLRF   FE2
00328:  MOVLW  42
0032A:  MOVWF  FE1
0032C:  MOVF   FE7,F
0032E:  MOVFF  FE6,FEE
00332:  BNZ   032C
.................... }
.................... 
00334:  BCF    FF0.0
00336:  GOTO   0098
.................... #include <arQ1010/interruptExt2_IN2.c>
.................... int1 InterruptInput2_Flag = 0;
.................... 
.................... #int_ext2 //when interrupt is enables on the main code the code is redirected on this include file
.................... void ext_isr2(void)
.................... {//if (input(PIN_B0))
.................... //fprintf(USB, "INTEEERRRRRUPPTTT"); 
....................    {
....................      InterruptInput2_Flag=1;
0033A:  MOVLB  4
0033C:  BSF    x8E.1
....................      //fprintf(USB, "Interrupt!\n");
....................    }
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/dualColorLED.c>
.................... #define LED_OFF 0
.................... #define LED_GREEN 1
0033E:  BCF    FF0.1
00340:  MOVLB  0
00342:  GOTO   0098
.................... #define LED_RED 2
.................... 
.................... void ledConfig(int mode)
.................... {
....................    switch (mode) {
*
049A0:  MOVLB  6
049A2:  MOVF   x9F,W
049A4:  XORLW  02
049A6:  MOVLB  0
049A8:  BZ    49B0
049AA:  XORLW  03
049AC:  BZ    49BA
049AE:  BRA    49C4
....................       case LED_RED:
....................          output_high(LED_STAT_A);
049B0:  BCF    F96.1
049B2:  BSF    F8D.1
....................          output_low(LED_STAT_B);
049B4:  BCF    F99.3
049B6:  BCF    F90.3
....................          break;
049B8:  BRA    49CC
....................       case LED_GREEN:
....................          output_low(LED_STAT_A);
049BA:  BCF    F96.1
049BC:  BCF    F8D.1
....................          output_high(LED_STAT_B);
049BE:  BCF    F99.3
049C0:  BSF    F90.3
....................          //output_low(LED_STAT_B);
....................          break;
049C2:  BRA    49CC
....................       default:
....................          output_low(LED_STAT_A);
049C4:  BCF    F96.1
049C6:  BCF    F8D.1
....................          output_low(LED_STAT_B);
049C8:  BCF    F99.3
049CA:  BCF    F90.3
....................          break;
....................    }
049CC:  RETURN 0
.................... }
.................... 
.................... void ledToggle(int1 color)
.................... {
....................    static int1 toggle=0;
....................    if (toggle==0)
*
05694:  MOVLB  4
05696:  BTFSC  x8E.2
05698:  BRA    56C6
....................    {
....................       if (color == LED_GREEN)
0569A:  MOVLB  6
0569C:  DECFSZ x9E,W
0569E:  BRA    56AE
....................          ledConfig(LED_GREEN);
056A0:  MOVLW  01
056A2:  MOVWF  x9F
056A4:  MOVLB  0
056A6:  CALL   49A0
056AA:  BRA    56BE
056AC:  MOVLB  6
....................       else if (color == LED_RED)
056AE:  MOVF   x9E,W
056B0:  SUBLW  02
056B2:  BNZ   56C0
....................          ledConfig(LED_RED);
056B4:  MOVLW  02
056B6:  MOVWF  x9F
056B8:  MOVLB  0
056BA:  CALL   49A0
056BE:  MOVLB  6
....................       toggle=1;
056C0:  MOVLB  4
056C2:  BSF    x8E.2
....................    }
056C4:  BRA    56D4
....................    else
....................    {
....................       ledConfig(LED_OFF);
056C6:  MOVLB  6
056C8:  CLRF   x9F
056CA:  MOVLB  0
056CC:  CALL   49A0
....................       toggle=0;
056D0:  MOVLB  4
056D2:  BCF    x8E.2
....................    }
056D4:  MOVLB  0
056D6:  GOTO   5C1E (RETURN)
.................... }
.................... 
.................... #include <arQ1010/gsm.c>
.................... 
.................... char *getNetworkOperator(){
....................    char *temp=NULL;
....................    char SMART = "SMART";
....................    char TalkNText = "TalkNText";
....................    char GLOBE = "Globe Telecom-PH";
....................    
....................    clear_InterruptGSM();
....................    strcpy(DESIRED_RESPONSE, "+COPS:");
....................    strcpy(TOKEN,"\"");
....................    fprintf(GSM,"AT+COPS?\r");
....................    strtok(GetResponse(),TOKEN);
....................    temp=strtok(0,TOKEN);
....................    //fprintf(USB,"cops = %s\n",temp);
....................    if ((strcmp(temp,SMART)==0) || (strcmp(temp,TalkNText)==0)){
....................       NETWORK=0;
....................       //fprintf(USB, "SMART Network\n");
....................    }
....................    else if(strcmp(temp,GLOBE)==0){
....................       NETWORK=1;
....................       //fprintf(USB, "GLOBE Network\n");
....................    }
....................    
....................    else{  
....................       NETWORK=2;
....................       //fprintf(USB,"%s\n",temp);
....................    }
....................    
....................    //fprintf(USB,"Network: %s\n", temp);
....................    return temp;
.................... }
....................    
....................    
.................... 
.................... 
.................... int checkNetworkRegistration(void){//serves to verify the network registration status
....................    //int counter = 0;
....................    //int1 status=FALSE;
....................    char *temp=NULL;
....................    
....................    clear_InterruptGSM();
....................    strcpy(DESIRED_RESPONSE, "+CREG: ");
....................    strcpy(TOKEN, "\r\n");
....................    fprintf(GSM, "AT+CREG?\r");
....................    delay_ms(100);
....................    //fprintf(USB, "RXD: %s\n",InterruptGSM_Rxd);
....................    temp = strtok(GetResponse(), TOKEN);
....................    //fprintf(USB, "Network: %s\n",temp);
....................    
....................    if (temp[2] == '1'){
....................       //fprintf(USB, "Network Registration Successful\n");
....................       return TRUE;
....................    }
....................    
....................    else{   
....................       //fprintf(USB, "Network Registration Failed\n");
....................       return FALSE;
....................    }
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 testGSM(void){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM, "AT\r");
....................    
....................    if(GetResponse()){
....................       //fprintf(USB,"Active %s\n",FIRMWARE_desc);
....................       fprintf(USB,"GSM module active\n");
....................       return TRUE;
....................    }
....................    else{
....................       fprintf(USB,"GSM module no response\n");
....................       return FALSE;
....................    }
.................... }
.................... 
.................... void igniteGSM(){
....................    //int cnt = 0;
....................    
....................    fprintf(USB,"Ignite GSM module\n");
....................    output_low(IGT);
....................    delay_ms(10);
....................    output_high(IGT);
....................    delay_ms(110);
....................    output_low(IGT);
....................    delay_ms(1000);
....................    
....................    
....................    //{fprintf(USB,"GSM Ignite Try: %i\n",cnt+1);
....................       //delay_ms(100);
....................       //cnt++;
....................    //} while(!testGSM() && (cnt < 5));
.................... }
.................... 
.................... void ShutDownGSM(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"AT^SMSO\r");
....................    if(GetResponse())
....................       fprintf(USB,"GSM Module Shutdown\n");
.................... }
.................... 
.................... void InitGSM(void){
....................    int timeOut=0;
....................    //char *temp=NULL;
....................    
....................    clear_InterruptGSM();
....................    fprintf(USB,"Initialize GSM Module\n");
.................... 
....................    retry:
....................    timeOut=0;
....................       
....................    igniteGSM();
....................    delay_ms(2000);
....................       
....................    if (testGSM()){
....................       fprintf(USB,"Checking network registration, please wait\n");
....................       while(timeOut<20){
....................          if (checkNetworkRegistration()){   
....................             fprintf(USB,"Registered to network: %s\n",getNetworkOperator()); // register ME to network           
....................             break;
....................          }
....................               
....................          else{
....................             delay_ms(1000);
....................             timeOut++;
....................          }
....................       }
....................                
....................       if (timeOut==20){
....................          fprintf(USB,"Network registration failed\n");
....................          fprintf(USB,"Performing GSM module reboot\n");
....................          shutDownGSM();
....................          delay_ms(2000);
....................          goto retry;
....................       }
....................           
....................    }
.................... 
....................    else{
....................       goto retry;
....................    }
.................... 
....................    strcpy(DESIRED_RESPONSE, "OK");  
....................    port_b_pullups(00000010);
....................    //fprintf(USB,"Pull up on PORT B\n");
....................    //fprintf(GSM,"AT+CFUN=1,1\r");
....................    //if (GetResponse())
....................    //fprintf(USB,"ME reset\n");
....................    fprintf(GSM, "AT&F0\r"); // set to factory settings
....................    if(GetResponse())
....................       //fprintf(USB,"Factory settings\n");
....................       
....................       fprintf(GSM, "ATE0\r"); // set echo to off
....................       if(GetResponse())
....................          //fprintf(USB,"Echo off\n");
....................          
....................       fprintf(GSM, "AT^SSYNC=1\r");      // activate LED
....................       if(GetResponse())
....................          //fprintf(USB,"LED active\n");
....................        
....................       fprintf(GSM, "AT+CNMI=1,1,0,0,1\r"); // sms indications set
....................       if(GetResponse())
....................          //fprintf(USB,"SMS indications set\n");
....................       
....................       fprintf(GSM, "AT+CMGF=1\r"); // set to text mode
....................       if(GetResponse())
....................          //fprintf(USB,"Set text mode\n");
....................       
....................       fprintf(GSM, "AT+CSMS=0\r");
....................       if(GetResponse())
....................          //fprintf(USB,"Msg service selected\n");
....................       
....................       fprintf(GSM, "AT+CLIP=1\r"); // display number of calling party
....................       if(GetResponse())
....................          //fprintf(USB,"CLIP enabled\n");
....................       
....................       fprintf(GSM, "AT+CPBS=ON\r"); // select GSM memory as storage phonebook
....................       if(GetResponse())
....................          //fprintf(USB,"PhonebookReady\n");
....................       
....................       fprintf(GSM, "AT+CPMS=MT,MT,MT\r");
....................       if (GetResponse())
....................          //fprintf(USB,"StorageReady\n");
....................         
....................       //fprintf(GSM, "AT+CNMI=2,2,0,0,0\r"); //command to received live message
....................       //if (GetResponse())
....................      
....................    fprintf(USB,"GSM ready\n");
.................... }
.................... 
.................... //----Delete all messages inside Inbox
.................... void clear_inputs(){
....................    int ii=0;
....................    //fprintf(USB, "Kahit ano\n");
....................    for(ii=0;ii<40;ii++){
....................       fprintf(GSM, "AT+CMGD=%i\r", ii);
....................       delay_ms(100);
....................    }   
.................... }
.................... 
.................... int1 SendSMS(char *msg, char *number){
....................    char dq = 0x22; // 0x22 is double quote (") character
....................    //int1 status = FALSE;
....................    //int1 statx=FALSE;
....................    int counter = 0;
....................    //int loopCount=0;
....................     
....................    strcpy(DESIRED_RESPONSE, "> ");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................    fprintf(GSM, "AT+CMGS=%c%s%c,129\r", dq,number,dq);
....................     
....................    //fprintf(USB, "AT+CMGS=%c%s%c,129\r\n", dq,Phone_Number,dq);
....................     
....................    do{
....................       if (InterruptGSM_Flag){ //checks if there is new data in the GSM serial line
....................          //fprintf(USB, "RXD1: %s\n",InterruptGSM_Rxd);
....................     
....................          if (GetResponse()){ //check if "> " is received in the GSM serial line
....................             counter = 0;
....................             clear_InterruptGSM();
....................             //delay_ms(100);
....................             strcpy(DESIRED_RESPONSE, "OK");
....................             fprintf(GSM, "%s\r", msg);
....................             //fprintf(USB, "%s\n", SMS_TOBE_SENT);
....................             fputc(0x1A, GSM); // 0x0A is ctrl-z to terminate message and start sending
....................                
....................             do{
....................                //fprintf(USB, "Counter: %i\n",counter);
....................                if (InterruptGSM_Flag){
....................                //fprintf(USB, "RXD2: %s\n",InterruptGSM_Rxd);
....................                   if (GetResponse()){
....................                      fprintf(USB, "Message sent to: %s\n",number);
....................                      powerGSMready = 1;
....................                      return 1;
....................                         
....................                      //break;
....................                   }
....................                   
....................                   else{
....................                      fprintf(USB, "GSM error 2: Message NOT sent.\n"); //Returns ERROR -> No / low GSM signal causes SMS sending failure
....................                      InterruptGSM_Flag=0;
....................                      powerGSMready = 0;
....................                      return 0;
....................                   }
....................                }
....................                   
....................                else{  
....................                   //fprintf(USB, "Waiting for GSM response %i.\n",counter);
....................                }  
....................                
....................                delay_ms(100);
....................             } while(counter++ < 200);
....................                
....................             fprintf(USB, "GSM Timeout 2: Message NOT sent.\n");
....................             return 0;
....................                
....................          }
....................          else{      
....................             //InterruptGSM_Flag=0; //resetting the flag to 0
....................             fprintf(USB, "GSM error 1:  Message NOT sent.\n");
....................             return 0;
....................          }
....................          }
.................... //!      else
.................... //!         {
.................... //!         fprintf(USB, "Waiting for GSM response %i.\n",counter);
.................... //!         }
....................        
....................         
....................        delay_ms(100);
....................    } while(counter++ < 50); //total waiting time of 5 seconds
....................    
....................    fprintf(USB, "GSM Timeout 1: Message NOT sent.\n");
....................    return 0;
.................... }// end SendSMS()
.................... 
.................... /*
.................... int1 SendSMS(char *Phone_Number){
....................    char dq = 0x22; // 0x22 is double quote (") character  
....................    //int1 status = FALSE;
....................    //int1 statx=FALSE;
....................    int counter = 0;
....................    //int loopCount=0;
.................... 
....................    strcpy(DESIRED_RESPONSE, "> ");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM, "AT+CMGS=%c%s%c,129\r", dq,Phone_Number,dq);
....................    //fprintf(USB, "AT+CMGS=%c%s%c,129\r\n", dq,Phone_Number,dq);
....................     
....................    do{
....................       if (InterruptGSM_Flag){ //checks if there is new data in the GSM serial line
....................          //fprintf(USB, "RXD1: %s\n",InterruptGSM_Rxd);  
....................          if (GetResponse()){ //check if "> " is received in the GSM serial line
....................             counter = 0;
....................             clear_InterruptGSM();
....................             delay_ms(100);
....................             strcpy(DESIRED_RESPONSE, "OK");
....................             fprintf(GSM, "%s\r", SMS_TOBE_SENT);
....................             //fprintf(USB, "%s\n", SMS_TOBE_SENT);
....................             fputc(0x1A, GSM); // 0x0A is ctrl-z to terminate message and start sending
....................                
....................             do{
....................                //fprintf(USB, "Counter: %i\n",counter);
....................                if (InterruptGSM_Flag){
....................                   //fprintf(USB, "RXD2: %s\n",InterruptGSM_Rxd);
....................                   if (GetResponse()){      
....................                      fprintf(USB, "Message sent to: %s\n",SERVERNUMBER);
....................                      return 1;
....................                      //break;
....................                   }
....................                   
....................                   else{
....................                      fprintf(USB, "GSM error 2: Message NOT sent.\n"); //Returns ERROR -> No / low GSM signal causes SMS sending failure
....................                      InterruptGSM_Flag=0;
....................                      return 0;
....................                   }
....................                }
....................                   
....................                //else{    
....................                   //fprintf(USB, "Waiting for GSM response %i.\n",counter);
....................                //}  
....................                delay_ms(1000);  
....................                
....................             } while(counter++ < 20);
....................                
....................             fprintf(USB, "GSM Timeout 2: Message NOT sent.\n");
....................             return 0;
....................                
....................          }
....................             
....................          else{
....................             //InterruptGSM_Flag=0; //resetting the flag to 0
....................             fprintf(USB, "GSM error 1:  Message NOT sent.\n");
....................             return 0;
....................          }
....................       }
.................... 
....................       //else{
....................          //fprintf(USB, "Waiting for GSM response %i.\n",counter);
....................       //}
....................        
....................         
....................       delay_ms(500);
....................    } while(counter++ < 10); //total waiting time of 2 seconds
....................    
....................    fprintf(USB, "GSM Timeout 1: Message NOT sent.\n");
....................    return 0;
.................... }// end SendSMS()
.................... */
.................... 
.................... char *getGSM_Strength(){
....................    char *statx=NULL;
....................    char *statcat=NULL;
....................    
....................    strcpy(DESIRED_RESPONSE, "+CSQ: ");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................    fprintf(GSM,"AT+CSQ\r");
....................    statx = GetResponse();
....................    strcpy(TOKEN,",");
....................    statcat = strtok(statx,TOKEN);
....................    //strcpy(funcReturnVar,statcat);
....................    
....................    //fprintf(USB,"GSM signal: %s\n",statcat);
....................    
....................    return statcat;
.................... }
.................... 
.................... 
.................... void AttemptToSend(char *msg, char *num){ // attempt to send three times
....................    int try = 1;
....................    fprintf(USB,"SMS: %s\n", msg);
....................    
....................    while (try<=5){
....................       //restart_wdt();
....................       getGSM_Strength();
....................       fprintf(USB, "Try to send %i -> ",try);
....................       
....................       if (SendSMS(msg, num)){   
....................          break;
....................       }
....................       
....................       else{
....................          try++;
....................       }
....................    }
....................    delay_ms(100);
.................... }
.................... 
.................... //!void AttemptToSend() // attempt to send three times
.................... //!{
.................... //!
.................... //!   int try = 1;
.................... //!   
.................... //!   fprintf(USB,"SMS: %s\n", SMS_TOBE_SENT);
.................... //!   
.................... //!   while (try<=5)
.................... //!   {//restart_wdt();
.................... //!   
.................... //!   getGSM_Strength();
.................... //!   fprintf(USB, "Try to send %i -> ",try);
.................... //!   
.................... //!   if (SendSMS(SERVERNUMBER))
.................... //!      {
.................... //!       break;
.................... //!      }
.................... //!   else
.................... //!      {
.................... //!       
.................... //!       try++;
.................... //!      }
.................... //!   }
.................... //!   
.................... //!
.................... //!}
.................... 
.................... void SetGSMTime(char *clockSetting){ // this function sets the GSM time
....................    char *ptrx=NULL;
....................    char clockx[30] = {};
....................    
....................    strcpy(clockx,clockSetting);
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    //delay_ms(100);
....................    
....................    //clear_InterruptGSM();
....................    //fprintf(GSM, "AT+CCLK=?\r");
....................    //delay_ms(100);
....................    //fprintf(USB, "RXD1: %s\n", InterruptGSM_Rxd);
....................    
....................    clear_InterruptGSM();
....................    //fprintf(USB, "AT+CCLK=\"%s\"\r\n",clockx);
....................    fprintf(GSM, "AT+CCLK=\"%s\"\r",clockx);
....................    delay_ms(100);
....................    
....................    if (GetResponse())
....................       fprintf(USB,"GSM clock set\n");
....................       
....................    else
....................       fprintf(USB,"GSM clock NOT set\n");
....................       
....................    strcpy(DESIRED_RESPONSE, "+CCLK: ");
....................    clear_InterruptGSM();
.................... 
....................    fprintf(GSM,"AT+CCLK?\r");
....................    delay_ms(50);
....................    ptrx = strtok(GetResponse(),TOKEN);
....................    
....................    //fprintf(USB,"GSM date and time: %s\n",ptrx); 
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/LTE.c>
.................... void initLTE(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"init\r");
....................    delay_ms(1000);
....................    if(GetResponse())
....................       fprintf(USB,"LTE Initialized\n");
.................... }
.................... 
.................... char *signalLTE(){
....................    char *signal=NULL;
....................    //strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................     delay_ms(200);
....................    fprintf(GSM,"signal\r");
....................    delay_ms(200);
....................    signal = GetResponse();
....................    //fprintf(USB, signal);
....................    return signal;
.................... }
.................... 
.................... void sendToLTE(char *msg){
....................    strcpy(DESIRED_RESPONSE, "OK");
*
017E8:  MOVLW  03
017EA:  MOVWF  FEA
017EC:  MOVLW  6F
017EE:  MOVWF  FE9
017F0:  MOVLW  00
017F2:  CALL   0104
017F6:  TBLRD*-
017F8:  TBLRD*+
017FA:  MOVF   FF5,W
017FC:  MOVWF  FEE
017FE:  IORLW  00
01800:  BNZ   17F8
....................    clear_InterruptGSM();
01802:  RCALL  153E
....................    delay_ms(200);
01804:  MOVLW  C8
01806:  MOVLB  7
01808:  MOVWF  x6D
0180A:  MOVLB  0
0180C:  CALL   0F16
....................    fprintf(GSM, msg);
01810:  MOVFF  769,FEA
01814:  MOVFF  768,FE9
01818:  BRA    15AE
....................    if(GetResponse())
0181A:  BRA    160E
0181C:  MOVF   01,W
0181E:  IORWF  02,W
01820:  BZ    184E
....................       fprintf(USB,"\nSMS Sent: %s\n", msg);
01822:  MOVLW  14
01824:  MOVWF  FF6
01826:  MOVLW  06
01828:  MOVWF  FF7
0182A:  MOVLW  00
0182C:  MOVWF  FF8
0182E:  MOVLW  0B
01830:  MOVLB  7
01832:  MOVWF  x90
01834:  MOVLB  0
01836:  RCALL  157A
01838:  MOVFF  769,FEA
0183C:  MOVFF  768,FE9
01840:  RCALL  10B6
01842:  MOVLW  0A
01844:  BTFSS  FA4.4
01846:  BRA    1844
01848:  MOVLB  F
0184A:  MOVWF  x1C
0184C:  MOVLB  0
0184E:  RETURN 0
.................... }  
....................  
....................  void relayOFF(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"OFF\r");
....................    delay_ms(200);
.................... }
.................... 
....................  void relayON(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"ON\r");
....................    delay_ms(200);
.................... }
.................... 
.................... 
....................  void igtLTE(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"igt\r");
....................    delay_ms(2000);
....................    if(GetResponse())
....................       fprintf(USB,"LTE Ignited\n");   
.................... }
.................... 
.................... #include <arQ1010/interruptTimer1.c>
.................... #Byte TMR1H = 0xFCF   // TIMER1 HIGH BYTE LOOK DATASHEET
.................... #Byte T1CON = 0xFCD  //TIMER1 CONFIG REGISTER LOOK DATASHEET 
.................... 
.................... 
.................... 
.................... //#define IS_LEAP(year) (year%4 == 0)
.................... unsigned int INTERRUPTCHECKER=0;
.................... 
.................... int1 IS_LEAP(year)
*
006B6:  MOVLB  7
006B8:  CLRF   xF3
006BA:  CLRF   xF2
.................... {
....................    int16 year_ = 0;
....................    
....................    year_ = year + 2000;
006BC:  MOVLW  D0
006BE:  ADDWF  xF1,W
006C0:  MOVWF  xF2
006C2:  MOVLW  07
006C4:  MOVWF  xF3
006C6:  BTFSC  FD8.0
006C8:  INCF   xF3,F
....................    if (((year_ % 4 == 0) && (year % 100 != 0)) || (year % 400 ==0))
006CA:  MOVF   xF2,W
006CC:  ANDLW  03
006CE:  MOVWF  xF4
006D0:  CLRF   xF5
006D2:  MOVF   xF4,F
006D4:  BNZ   06EC
006D6:  MOVF   xF5,F
006D8:  BNZ   06EC
006DA:  MOVFF  7F1,7F4
006DE:  MOVLW  64
006E0:  MOVWF  xF5
006E2:  MOVLB  0
006E4:  RCALL  0642
006E6:  MOVF   00,F
006E8:  BNZ   0712
006EA:  MOVLB  7
006EC:  CLRF   xF5
006EE:  MOVFF  7F1,7F4
006F2:  MOVLW  01
006F4:  MOVWF  xF7
006F6:  MOVLW  90
006F8:  MOVWF  xF6
006FA:  MOVLB  0
006FC:  BRA    066E
006FE:  MOVFF  00,7F4
00702:  MOVLB  7
00704:  MOVFF  03,7F5
00708:  MOVF   xF4,F
0070A:  BNZ   071C
0070C:  MOVF   xF5,F
0070E:  BNZ   071C
00710:  MOVLB  0
....................       return 1;
00712:  MOVLW  01
00714:  MOVWF  01
00716:  BRA    0722
00718:  BRA    0722
0071A:  MOVLB  7
....................    else
....................       return 0;
0071C:  MOVLW  00
0071E:  MOVWF  01
00720:  MOVLB  0
00722:  GOTO   0768 (RETURN)
.................... }
.................... 
.................... 
.................... #int_TIMER1 
.................... void TIMER1_isr()    
.................... { 
....................    bit_clear(T1CON,1);
00726:  BCF    FCD.1
....................    bit_set(TMR1H,7);
00728:  BSF    FCF.7
....................    bit_set(T1CON,1);
0072A:  BSF    FCD.1
....................    
....................    INTERRUPTCHECKER=0; 
0072C:  MOVLB  4
0072E:  CLRF   x91
....................    if (++SEC>59){
00730:  MOVLB  3
00732:  INCF   x80,F
00734:  MOVF   x80,W
00736:  SUBLW  3B
00738:  BC    07D2
....................       SEC=0;
0073A:  CLRF   x80
....................       TESTFLAG=TRUE;
0073C:  BSF    40.6
....................       if(++MIN>59){
0073E:  INCF   x81,F
00740:  MOVF   x81,W
00742:  SUBLW  3B
00744:  BC    07D2
....................          MIN=0;
00746:  CLRF   x81
....................          if(++HOUR>23){
00748:  INCF   x82,F
0074A:  MOVF   x82,W
0074C:  SUBLW  17
0074E:  BC    07D2
....................             HOUR=0;
00750:  CLRF   x82
....................             ++DAY;
00752:  INCF   x83,F
....................             if ((DAY == 29 && MONTH== 2 && !IS_LEAP(YEAR))
....................                || (DAY == 30 && MONTH==2)
....................                || (DAY == 31 && (MONTH==4 || MONTH==6 || MONTH==9 || MONTH==11))
....................                || (DAY == 32)
00754:  MOVF   x83,W
00756:  SUBLW  1D
00758:  BNZ   076E
0075A:  MOVF   x84,W
0075C:  SUBLW  02
0075E:  BNZ   076E
00760:  MOVFF  385,7F1
00764:  MOVLB  0
00766:  BRA    06B6
00768:  MOVF   01,F
0076A:  BZ    07BC
0076C:  MOVLB  3
0076E:  MOVF   x83,W
00770:  SUBLW  1E
00772:  BNZ   0780
00774:  MOVF   x84,W
00776:  SUBLW  02
00778:  BTFSS  FD8.2
0077A:  BRA    0780
0077C:  MOVLB  0
0077E:  BRA    07BC
00780:  MOVF   x83,W
00782:  SUBLW  1F
00784:  BNZ   07B6
00786:  MOVF   x84,W
00788:  SUBLW  04
0078A:  BTFSS  FD8.2
0078C:  BRA    0792
0078E:  MOVLB  0
00790:  BRA    07BC
00792:  MOVF   x84,W
00794:  SUBLW  06
00796:  BTFSS  FD8.2
00798:  BRA    079E
0079A:  MOVLB  0
0079C:  BRA    07BC
0079E:  MOVF   x84,W
007A0:  SUBLW  09
007A2:  BTFSS  FD8.2
007A4:  BRA    07AA
007A6:  MOVLB  0
007A8:  BRA    07BC
007AA:  MOVF   x84,W
007AC:  SUBLW  0B
007AE:  BTFSS  FD8.2
007B0:  BRA    07B6
007B2:  MOVLB  0
007B4:  BRA    07BC
007B6:  MOVF   x83,W
007B8:  SUBLW  20
007BA:  BNZ   07C4
....................                ){MONTH++;DAY=1;}
007BC:  MOVLB  3
007BE:  INCF   x84,F
007C0:  MOVLW  01
007C2:  MOVWF  x83
....................             if(MONTH == 13) {YEAR++; MONTH=1;}
007C4:  MOVF   x84,W
007C6:  SUBLW  0D
007C8:  BNZ   07D0
007CA:  INCF   x85,F
007CC:  MOVLW  01
007CE:  MOVWF  x84
....................             RESETCPU=1;
007D0:  BSF    40.5
....................          }
.................... //!         if (HOUR == 8)
.................... //!            RESETFLAG=TRUE;
....................       }
....................    }
....................    
....................    if ((HOUR == 23) && (MIN == 58)  && (SEC == 0))
007D2:  MOVF   x82,W
007D4:  SUBLW  17
007D6:  BNZ   07E4
007D8:  MOVF   x81,W
007DA:  SUBLW  3A
007DC:  BNZ   07E4
007DE:  MOVF   x80,F
007E0:  BNZ   07E4
....................        { 
.................... 
....................         SYNCFLAG=TRUE;
007E2:  BSF    40.7
....................        }  
....................    
....................    if ((HOUROLD != HOUR) && (MIN == 58))
007E4:  MOVF   x82,W
007E6:  MOVLB  4
007E8:  SUBWF  x8D,W
007EA:  BZ    0802
007EC:  MOVLB  3
007EE:  MOVF   x81,W
007F0:  SUBLW  3A
007F2:  BTFSC  FD8.2
007F4:  BRA    07FA
007F6:  MOVLB  4
007F8:  BRA    0802
....................    {  
....................       RESETFLAG=TRUE;
007FA:  MOVLB  4
007FC:  BSF    x8E.0
....................       HOUROLD=HOUR;
007FE:  MOVFF  382,48D
....................    }
....................    
....................    if ((MIN%SENDING_TIME) == 0)
00802:  MOVFF  381,7F4
00806:  MOVFF  48C,7F5
0080A:  MOVLB  0
0080C:  RCALL  0642
0080E:  MOVF   00,F
00810:  BNZ   081C
....................    {
....................       if (CHECKMINUTE == FALSE)
00812:  BTFSC  40.4
00814:  BRA    081A
....................       {
....................          CHECKMINUTE = TRUE;
00816:  BSF    40.4
....................          SAMPLINGFLAG = TRUE;
00818:  BSF    40.3
....................       }
....................    }
0081A:  BRA    081E
....................    else
....................       CHECKMINUTE = FALSE;
0081C:  BCF    40.4
....................      
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/rtc.c>
.................... #define RTC_I2C_ADDR_2129     81
.................... #define RTC_I2C_ADDR_8523     104
.................... #define RTC_CONTROL1_REG      0x00
.................... #define RTC_CONTROL2_REG      0x01
.................... #define RTC_CONTROL3_REG      0x02
.................... 
.................... #define RTC_SEC_REG           0x03
.................... #define RTC_MIN_REG           0x04
.................... #define RTC_HOUR_REG          0x05
.................... #define RTC_DATE_REG          0x06
.................... #define RTC_WEEKDAY_REG       0x07
.................... #define RTC_MONTH_REG         0x08
0081E:  BCF    F9E.0
00820:  GOTO   0098
.................... #define RTC_YEAR_REG          0x09
.................... 
.................... 
.................... int8 get_ack_status(int8 address)
.................... {
....................    int8 status; 
....................    
....................    i2c_start(); 
....................    status = i2c_write(address);  // Status = 0 if got an ACK 
....................    i2c_stop(); 
....................    
....................    if(status == 0) 
....................       return(TRUE); 
....................    else 
....................       return(FALSE); 
.................... }
.................... 
.................... int32 rtcGetEpochDate(int32 year, int month, int day)
.................... {
....................     if (year >= 1900)
....................       {
....................         year -= 1900;
....................     }
....................     
....................     /* month must be cast to uint8_t or this fails on some platforms */
....................     int8 m = (int8)(month & 0xFF);
....................     return (1461 * (year + 6700 + (m - 14) / 12)) / 4 + (367 *
....................         (m - 2 - 12 * ((m - 14) / 12))) / 12 -
....................         (3 * ((year + 6800 + (m - 14) / 12) / 100)) / 4 +
....................         day - 2472663;
.................... }
.................... 
.................... int rtcAssignWeekday(int32 years, int months, int days)
.................... {
....................     int32 NrOfDay=0;
....................     int8 weekday=0;
....................     NrOfDay = rtcGetEpochDate(years, months, days);
....................     weekday = (NrOfDay + 3) % 7;
....................     //fprintf(PC,"NrOfDay=%lu\n",NrOfDay);
....................     //fprintf(PC,"weekday=%u\n",weekday);
....................     return weekday;
.................... }
.................... 
.................... int8 rtcBCDToDec(int8 val)
.................... {
....................     return (val >> 4) * 10 + (val & 0x0F);
*
0501E:  MOVLB  7
05020:  SWAPF  x49,W
05022:  MOVWF  00
05024:  MOVLW  0F
05026:  ANDWF  00,F
05028:  MOVF   00,W
0502A:  MULLW  0A
0502C:  MOVFF  FF3,74A
05030:  MOVF   x49,W
05032:  ANDLW  0F
05034:  ADDWF  x4A,W
05036:  MOVWF  01
05038:  MOVLB  0
0503A:  RETURN 0
.................... }   
.................... 
.................... int8 rtcDecToBCD(int8 val)
*
04CBA:  CLRF   1B
04CBC:  BTFSC  FF2.7
04CBE:  BSF    1B.7
04CC0:  BCF    FF2.7
.................... {
....................     return ((val / 10) << 4) | (val % 10);
04CC2:  MOVFF  730,7F4
04CC6:  MOVLW  0A
04CC8:  MOVLB  7
04CCA:  MOVWF  xF5
04CCC:  MOVLB  0
04CCE:  CALL   0642
04CD2:  BTFSC  1B.7
04CD4:  BSF    FF2.7
04CD6:  SWAPF  01,W
04CD8:  MOVLB  7
04CDA:  MOVWF  x31
04CDC:  MOVLW  F0
04CDE:  ANDWF  x31,F
04CE0:  CLRF   1B
04CE2:  BTFSC  FF2.7
04CE4:  BSF    1B.7
04CE6:  BCF    FF2.7
04CE8:  MOVFF  730,7F4
04CEC:  MOVLW  0A
04CEE:  MOVWF  xF5
04CF0:  MOVLB  0
04CF2:  CALL   0642
04CF6:  BTFSC  1B.7
04CF8:  BSF    FF2.7
04CFA:  MOVF   00,W
04CFC:  MOVLB  7
04CFE:  IORWF  x31,W
04D00:  MOVWF  01
04D02:  MOVLB  0
04D04:  RETURN 0
.................... }
.................... /*
.................... void GetDateTime()
.................... {
....................    
....................    int ii=0;
....................    int xx=0;
....................    char forTime[5]={};
....................    char strDateTime[20] ={};
....................    
....................    strcpy(funcReturnVar,"");
....................    for (xx=0;xx<=5;xx++) 
....................    {
....................       switch(xx) {
....................          case 0:
....................             itoa(years,10,forTime);
....................             break;
....................          case 1:
....................             itoa(months,10,forTime);
....................             break;
....................          case 2:
....................             itoa(days,10,forTime);
....................             break;
....................          case 3:
....................             itoa(hours,10,forTime);
....................             break;
....................          case 4:
....................             itoa(minutes,10,forTime);
....................             break;
....................          case 5:
....................             itoa(seconds,10,forTime);
....................             break;
....................       }
....................       if (strlen(forTime)==4) {
....................          strDateTime[ii++] = forTime[2];
....................          strDateTime[ii++] = forTime[3];
....................          strDateTime[ii++] = ':';
....................          }
....................       else if (strlen(forTime)<2) {
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = forTime[0];
....................          strDateTime[ii++] = ':';
....................          }
....................       else if (strlen(forTime)==2)  {
....................          strDateTime[ii++] = forTime[0];
....................          strDateTime[ii++] = forTime[1];
....................          strDateTime[ii++] = ':';
....................          }
....................       else {
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = ':';
....................          }
....................    }
....................    ii--;
....................    strDateTime[ii] = '\0';
....................   fprintf(PC,"strDateTime=%s\n",strDateTime);
....................    //strcpy(funcReturnVar,strDateTime);
.................... }
.................... */
.................... 
.................... // if storeToVariables = 1 then store rtc configs to date and time variables
.................... // used to read configs from rtc chip 
.................... char *readRtc() //int1 storeToVariables
*
050DA:  MOVLB  7
050DC:  CLRF   x24
050DE:  CLRF   x25
050E0:  CLRF   x26
050E2:  CLRF   x27
050E4:  CLRF   x28
050E6:  CLRF   x29
*
05110:  CLRF   x3E
05112:  CLRF   x47
.................... {
....................    int seconds=0;
....................    int minutes=0;
....................    int hours=0;
....................    int days=0;
....................    int months=0;
....................    int years=0;
....................     
....................    char strDateTime[20]={};
*
050E8:  CLRF   x2A
050EA:  CLRF   x2B
050EC:  CLRF   x2C
050EE:  CLRF   x2D
050F0:  CLRF   x2E
050F2:  CLRF   x2F
050F4:  CLRF   x30
050F6:  CLRF   x31
050F8:  CLRF   x32
050FA:  CLRF   x33
050FC:  CLRF   x34
050FE:  CLRF   x35
05100:  CLRF   x36
05102:  CLRF   x37
05104:  CLRF   x38
05106:  CLRF   x39
05108:  CLRF   x3A
0510A:  CLRF   x3B
0510C:  CLRF   x3C
0510E:  CLRF   x3D
....................    int status=0;
....................    int data[8];
....................    int i=0;
....................    
....................    //char *ptr=NULL;
....................    
....................    i2c_start();
*
05114:  BSF    F66.0
05116:  BTFSC  F66.0
05118:  BRA    5116
....................    i2c_write(0xA2);  
0511A:  MOVLW  A2
0511C:  MOVWF  x48
0511E:  MOVLB  0
05120:  RCALL  4D06
....................    i2c_write(RTC_SEC_REG);
05122:  MOVLW  03
05124:  MOVLB  7
05126:  MOVWF  x48
05128:  MOVLB  0
0512A:  RCALL  4D06
....................    i2c_stop(); 
0512C:  BSF    F66.2
0512E:  BTFSC  F66.2
05130:  BRA    512E
....................    
....................    i2c_start();
05132:  BSF    F66.0
05134:  BTFSC  F66.0
05136:  BRA    5134
....................    status = i2c_write(0xA2|0x01);
05138:  MOVLW  A3
0513A:  MOVLB  7
0513C:  MOVWF  x48
0513E:  MOVLB  0
05140:  RCALL  4D06
05142:  MOVFF  01,73E
....................    //fprintf(PC,"for reading=%x\n",status);
....................    
....................    for (i=0;i<7;i++)
05146:  MOVLB  7
05148:  CLRF   x47
0514A:  MOVF   x47,W
0514C:  SUBLW  06
0514E:  BNC   5170
....................       data[i] = i2c_read();
05150:  CLRF   03
05152:  MOVF   x47,W
05154:  ADDLW  3F
05156:  MOVWF  FE9
05158:  MOVLW  07
0515A:  ADDWFC 03,W
0515C:  MOVWF  FEA
0515E:  MOVLW  01
05160:  MOVWF  00
05162:  MOVLB  0
05164:  BRA    5000
05166:  MOVFF  01,FEF
0516A:  MOVLB  7
0516C:  INCF   x47,F
0516E:  BRA    514A
....................    i2c_stop(); 
05170:  BSF    F66.2
05172:  BTFSC  F66.2
05174:  BRA    5172
....................    
....................    seconds  = rtcBCDToDec(data[0] & 0x7F);
05176:  MOVF   x3F,W
05178:  ANDLW  7F
0517A:  MOVWF  x48
0517C:  MOVWF  x49
0517E:  MOVLB  0
05180:  RCALL  501E
05182:  MOVFF  01,724
....................    minutes  = rtcBCDToDec(data[1]);
05186:  MOVFF  740,749
0518A:  RCALL  501E
0518C:  MOVFF  01,725
....................    hours  = rtcBCDToDec(data[2]);
05190:  MOVFF  741,749
05194:  RCALL  501E
05196:  MOVFF  01,726
....................    days  = rtcBCDToDec(data[3]);
0519A:  MOVFF  742,749
0519E:  RCALL  501E
051A0:  MOVFF  01,727
....................    months  = rtcBCDToDec(data[5]);
051A4:  MOVFF  744,749
051A8:  RCALL  501E
051AA:  MOVFF  01,728
....................    years  = rtcBCDToDec(data[6]);
051AE:  MOVFF  745,749
051B2:  RCALL  501E
051B4:  MOVFF  01,729
....................    //timezone = rtcBCDToDec(data[7]);
....................    
.................... /*   
....................    fprintf(PC,"sec=%u\n",seconds);
....................    fprintf(PC,"minutes=%u\n",minutes);
....................    fprintf(PC,"hours=%u\n",hours);
....................    fprintf(PC,"days=%u\n",days);
....................    fprintf(PC,"months=%u\n",months);
....................    fprintf(PC,"years=%u\n",years);
.................... */  
.................... 
....................    
.................... //!   if (storeToVariables==TRUE) // should be outside this function...
.................... //!   {
.................... //!      SEC = seconds;
.................... //!      MIN = minutes;
.................... //!      HOUR = hours;
.................... //!      DAY = days;
.................... //!      MONTH = months;
.................... //!      YEAR = years;
.................... //!      fprintf(USB,"MCU clock set\n");
.................... //!   }
....................       
....................       sprintf(strDateTime,"%u/%u/%u,%u:%u:%u",years,months,days,hours,minutes,seconds);
051B8:  MOVLW  07
051BA:  MOVLB  4
051BC:  MOVWF  x90
051BE:  MOVLW  2A
051C0:  MOVWF  x8F
051C2:  MOVFF  729,748
051C6:  MOVLW  1B
051C8:  MOVLB  7
051CA:  MOVWF  x49
051CC:  MOVLB  0
051CE:  RCALL  503C
051D0:  MOVLW  2F
051D2:  MOVLB  7
051D4:  MOVWF  xBC
051D6:  MOVLB  0
051D8:  CALL   0F8C
051DC:  MOVFF  728,748
051E0:  MOVLW  1B
051E2:  MOVLB  7
051E4:  MOVWF  x49
051E6:  MOVLB  0
051E8:  RCALL  503C
051EA:  MOVLW  2F
051EC:  MOVLB  7
051EE:  MOVWF  xBC
051F0:  MOVLB  0
051F2:  CALL   0F8C
051F6:  MOVFF  727,748
051FA:  MOVLW  1B
051FC:  MOVLB  7
051FE:  MOVWF  x49
05200:  MOVLB  0
05202:  RCALL  503C
05204:  MOVLW  2C
05206:  MOVLB  7
05208:  MOVWF  xBC
0520A:  MOVLB  0
0520C:  CALL   0F8C
05210:  MOVFF  726,748
05214:  MOVLW  1B
05216:  MOVLB  7
05218:  MOVWF  x49
0521A:  MOVLB  0
0521C:  RCALL  503C
0521E:  MOVLW  3A
05220:  MOVLB  7
05222:  MOVWF  xBC
05224:  MOVLB  0
05226:  CALL   0F8C
0522A:  MOVFF  725,748
0522E:  MOVLW  1B
05230:  MOVLB  7
05232:  MOVWF  x49
05234:  MOVLB  0
05236:  RCALL  503C
05238:  MOVLW  3A
0523A:  MOVLB  7
0523C:  MOVWF  xBC
0523E:  MOVLB  0
05240:  CALL   0F8C
05244:  MOVFF  724,748
05248:  MOVLW  1B
0524A:  MOVLB  7
0524C:  MOVWF  x49
0524E:  MOVLB  0
05250:  RCALL  503C
....................       fprintf(USB,"RTC date and time: %s\n",strDateTime);
05252:  MOVLW  24
05254:  MOVWF  FF6
05256:  MOVLW  08
05258:  MOVWF  FF7
0525A:  MOVLW  00
0525C:  MOVWF  FF8
0525E:  MOVLW  13
05260:  MOVLB  7
05262:  MOVWF  x90
05264:  MOVLB  0
05266:  CALL   157A
0526A:  MOVLW  07
0526C:  MOVWF  FEA
0526E:  MOVLW  2A
05270:  MOVWF  FE9
05272:  CALL   10B6
05276:  MOVLW  0A
05278:  BTFSS  FA4.4
0527A:  BRA    5278
0527C:  MOVLB  F
0527E:  MOVWF  x1C
....................        
....................    return strDateTime;
05280:  MOVLW  2A
05282:  MOVWF  01
05284:  MOVLW  07
05286:  MOVWF  02
05288:  MOVLB  0
0528A:  GOTO   54BE (RETURN)
....................    
.................... }
.................... 
.................... 
.................... void configI2C(int param1, int param2)
.................... {
....................    i2c_start(); 
*
04D22:  BSF    F66.0
04D24:  BTFSC  F66.0
04D26:  BRA    4D24
....................    i2c_write(0xA2);  // Status = 0 if got an ACK 
04D28:  MOVLW  A2
04D2A:  MOVLB  7
04D2C:  MOVWF  x48
04D2E:  MOVLB  0
04D30:  RCALL  4D06
....................    i2c_write(param1);
04D32:  MOVFF  72F,748
04D36:  RCALL  4D06
....................    i2c_write(param2);
04D38:  MOVFF  730,748
04D3C:  RCALL  4D06
....................    i2c_stop();
04D3E:  BSF    F66.2
04D40:  BTFSC  F66.2
04D42:  BRA    4D40
04D44:  RETURN 0
.................... }
.................... 
.................... void setRtc(char *input)
04D46:  MOVLB  7
04D48:  CLRF   x10
04D4A:  CLRF   x11
04D4C:  CLRF   x12
04D4E:  CLRF   x13
04D50:  CLRF   x14
04D52:  CLRF   x15
.................... {
....................     int seconds=0;
....................     int minutes=0;
....................     int hours=0;
....................     int days=0;
....................     int months=0;
....................     int years=0;
....................     
....................     char temp[20]={};
04D54:  CLRF   x16
04D56:  CLRF   x17
04D58:  CLRF   x18
04D5A:  CLRF   x19
04D5C:  CLRF   x1A
04D5E:  CLRF   x1B
04D60:  CLRF   x1C
04D62:  CLRF   x1D
04D64:  CLRF   x1E
04D66:  CLRF   x1F
04D68:  CLRF   x20
04D6A:  CLRF   x21
04D6C:  CLRF   x22
04D6E:  CLRF   x23
04D70:  CLRF   x24
04D72:  CLRF   x25
04D74:  CLRF   x26
04D76:  CLRF   x27
04D78:  CLRF   x28
04D7A:  CLRF   x29
....................     char tempx[3]={};
04D7C:  CLRF   x2A
04D7E:  CLRF   x2B
04D80:  CLRF   x2C
....................     char *ptr;
....................     
....................    strcpy(TOKEN,"/,:\"");       //yy/mm/dd,hh:mm:ss
04D82:  CLRF   FEA
04D84:  MOVLW  22
04D86:  MOVWF  FE9
04D88:  MOVLW  00
04D8A:  MOVLB  0
04D8C:  CALL   011C
04D90:  TBLRD*-
04D92:  TBLRD*+
04D94:  MOVF   FF5,W
04D96:  MOVWF  FEE
04D98:  IORLW  00
04D9A:  BNZ   4D92
....................    strcpy(temp,input);
04D9C:  MOVLW  07
04D9E:  MOVWF  FEA
04DA0:  MOVLW  16
04DA2:  MOVWF  FE9
04DA4:  MOVFF  70F,FE2
04DA8:  MOVFF  70E,FE1
04DAC:  MOVF   FE7,F
04DAE:  MOVFF  FE6,FEE
04DB2:  BNZ   4DAC
....................    delay_ms(150);
04DB4:  MOVLW  96
04DB6:  MOVLB  7
04DB8:  MOVWF  x6D
04DBA:  MOVLB  0
04DBC:  CALL   0F16
....................    ptr = strtok(temp,TOKEN);
04DC0:  MOVLW  07
04DC2:  MOVLB  7
04DC4:  MOVWF  xA8
04DC6:  MOVLW  16
04DC8:  MOVWF  xA7
04DCA:  CLRF   xAA
04DCC:  MOVLW  22
04DCE:  MOVWF  xA9
04DD0:  MOVLB  0
04DD2:  CALL   2F58
04DD6:  MOVFF  02,72E
04DDA:  MOVFF  01,72D
....................    strcpy(tempx,ptr);
04DDE:  MOVLW  07
04DE0:  MOVWF  FEA
04DE2:  MOVLW  2A
04DE4:  MOVWF  FE9
04DE6:  MOVFF  72E,FE2
04DEA:  MOVFF  72D,FE1
04DEE:  MOVF   FE7,F
04DF0:  MOVFF  FE6,FEE
04DF4:  BNZ   4DEE
.................... //!   YEAR = atoi(tempx);
....................    years  = rtcDecToBCD(atoi(tempx));
04DF6:  MOVLW  07
04DF8:  MOVLB  7
04DFA:  MOVWF  x40
04DFC:  MOVLW  2A
04DFE:  MOVWF  x3F
04E00:  MOVLB  0
04E02:  RCALL  4B28
04E04:  MOVFF  01,72F
04E08:  MOVFF  01,730
04E0C:  RCALL  4CBA
04E0E:  MOVFF  01,715
....................    //YEAR = YEAR + 2000;
....................    
....................    ptr = strtok(0,TOKEN);
04E12:  MOVLB  7
04E14:  CLRF   xA8
04E16:  CLRF   xA7
04E18:  CLRF   xAA
04E1A:  MOVLW  22
04E1C:  MOVWF  xA9
04E1E:  MOVLB  0
04E20:  CALL   2F58
04E24:  MOVFF  02,72E
04E28:  MOVFF  01,72D
....................    strcpy(tempx,ptr);
04E2C:  MOVLW  07
04E2E:  MOVWF  FEA
04E30:  MOVLW  2A
04E32:  MOVWF  FE9
04E34:  MOVFF  72E,FE2
04E38:  MOVFF  72D,FE1
04E3C:  MOVF   FE7,F
04E3E:  MOVFF  FE6,FEE
04E42:  BNZ   4E3C
.................... //!   MONTH = atoi(tempx);
....................    months  = rtcDecToBCD(atoi(tempx));
04E44:  MOVLW  07
04E46:  MOVLB  7
04E48:  MOVWF  x40
04E4A:  MOVLW  2A
04E4C:  MOVWF  x3F
04E4E:  MOVLB  0
04E50:  RCALL  4B28
04E52:  MOVFF  01,72F
04E56:  MOVFF  01,730
04E5A:  RCALL  4CBA
04E5C:  MOVFF  01,714
....................    
....................    ptr = strtok(0,TOKEN);
04E60:  MOVLB  7
04E62:  CLRF   xA8
04E64:  CLRF   xA7
04E66:  CLRF   xAA
04E68:  MOVLW  22
04E6A:  MOVWF  xA9
04E6C:  MOVLB  0
04E6E:  CALL   2F58
04E72:  MOVFF  02,72E
04E76:  MOVFF  01,72D
....................    strcpy(tempx,ptr);
04E7A:  MOVLW  07
04E7C:  MOVWF  FEA
04E7E:  MOVLW  2A
04E80:  MOVWF  FE9
04E82:  MOVFF  72E,FE2
04E86:  MOVFF  72D,FE1
04E8A:  MOVF   FE7,F
04E8C:  MOVFF  FE6,FEE
04E90:  BNZ   4E8A
.................... //!   DAY = atoi(tempx);
....................    days  = rtcDecToBCD(atoi(tempx));
04E92:  MOVLW  07
04E94:  MOVLB  7
04E96:  MOVWF  x40
04E98:  MOVLW  2A
04E9A:  MOVWF  x3F
04E9C:  MOVLB  0
04E9E:  RCALL  4B28
04EA0:  MOVFF  01,72F
04EA4:  MOVFF  01,730
04EA8:  RCALL  4CBA
04EAA:  MOVFF  01,713
....................    
....................    ptr = strtok(0,TOKEN);
04EAE:  MOVLB  7
04EB0:  CLRF   xA8
04EB2:  CLRF   xA7
04EB4:  CLRF   xAA
04EB6:  MOVLW  22
04EB8:  MOVWF  xA9
04EBA:  MOVLB  0
04EBC:  CALL   2F58
04EC0:  MOVFF  02,72E
04EC4:  MOVFF  01,72D
....................    strcpy(tempx,ptr);
04EC8:  MOVLW  07
04ECA:  MOVWF  FEA
04ECC:  MOVLW  2A
04ECE:  MOVWF  FE9
04ED0:  MOVFF  72E,FE2
04ED4:  MOVFF  72D,FE1
04ED8:  MOVF   FE7,F
04EDA:  MOVFF  FE6,FEE
04EDE:  BNZ   4ED8
.................... //!   HOUR = atoi(tempx);
....................    hours  = rtcDecToBCD(atoi(tempx));
04EE0:  MOVLW  07
04EE2:  MOVLB  7
04EE4:  MOVWF  x40
04EE6:  MOVLW  2A
04EE8:  MOVWF  x3F
04EEA:  MOVLB  0
04EEC:  RCALL  4B28
04EEE:  MOVFF  01,72F
04EF2:  MOVFF  01,730
04EF6:  RCALL  4CBA
04EF8:  MOVFF  01,712
....................    
....................    ptr = strtok(0,TOKEN);
04EFC:  MOVLB  7
04EFE:  CLRF   xA8
04F00:  CLRF   xA7
04F02:  CLRF   xAA
04F04:  MOVLW  22
04F06:  MOVWF  xA9
04F08:  MOVLB  0
04F0A:  CALL   2F58
04F0E:  MOVFF  02,72E
04F12:  MOVFF  01,72D
....................    strcpy(tempx,ptr);
04F16:  MOVLW  07
04F18:  MOVWF  FEA
04F1A:  MOVLW  2A
04F1C:  MOVWF  FE9
04F1E:  MOVFF  72E,FE2
04F22:  MOVFF  72D,FE1
04F26:  MOVF   FE7,F
04F28:  MOVFF  FE6,FEE
04F2C:  BNZ   4F26
.................... //!   MIN = atoi(tempx);
....................    minutes  = rtcDecToBCD(atoi(tempx));
04F2E:  MOVLW  07
04F30:  MOVLB  7
04F32:  MOVWF  x40
04F34:  MOVLW  2A
04F36:  MOVWF  x3F
04F38:  MOVLB  0
04F3A:  RCALL  4B28
04F3C:  MOVFF  01,72F
04F40:  MOVFF  01,730
04F44:  RCALL  4CBA
04F46:  MOVFF  01,711
....................    
....................    ptr = strtok(0,TOKEN);
04F4A:  MOVLB  7
04F4C:  CLRF   xA8
04F4E:  CLRF   xA7
04F50:  CLRF   xAA
04F52:  MOVLW  22
04F54:  MOVWF  xA9
04F56:  MOVLB  0
04F58:  CALL   2F58
04F5C:  MOVFF  02,72E
04F60:  MOVFF  01,72D
....................    strcpy(tempx,ptr);
04F64:  MOVLW  07
04F66:  MOVWF  FEA
04F68:  MOVLW  2A
04F6A:  MOVWF  FE9
04F6C:  MOVFF  72E,FE2
04F70:  MOVFF  72D,FE1
04F74:  MOVF   FE7,F
04F76:  MOVFF  FE6,FEE
04F7A:  BNZ   4F74
.................... //!   SEC = atoi(tempx);
....................    seconds  = rtcDecToBCD(atoi(tempx));   
04F7C:  MOVLW  07
04F7E:  MOVLB  7
04F80:  MOVWF  x40
04F82:  MOVLW  2A
04F84:  MOVWF  x3F
04F86:  MOVLB  0
04F88:  RCALL  4B28
04F8A:  MOVFF  01,72F
04F8E:  MOVFF  01,730
04F92:  RCALL  4CBA
04F94:  MOVFF  01,710
....................    
....................     configI2C(RTC_SEC_REG, seconds);
04F98:  MOVLW  03
04F9A:  MOVLB  7
04F9C:  MOVWF  x2F
04F9E:  MOVFF  710,730
04FA2:  MOVLB  0
04FA4:  RCALL  4D22
....................     configI2C(RTC_MIN_REG, minutes);
04FA6:  MOVLW  04
04FA8:  MOVLB  7
04FAA:  MOVWF  x2F
04FAC:  MOVFF  711,730
04FB0:  MOVLB  0
04FB2:  RCALL  4D22
....................     configI2C(RTC_HOUR_REG, hours);
04FB4:  MOVLW  05
04FB6:  MOVLB  7
04FB8:  MOVWF  x2F
04FBA:  MOVFF  712,730
04FBE:  MOVLB  0
04FC0:  RCALL  4D22
....................     configI2C(RTC_DATE_REG, days);
04FC2:  MOVLW  06
04FC4:  MOVLB  7
04FC6:  MOVWF  x2F
04FC8:  MOVFF  713,730
04FCC:  MOVLB  0
04FCE:  RCALL  4D22
....................     configI2C(RTC_MONTH_REG, months);
04FD0:  MOVLW  08
04FD2:  MOVLB  7
04FD4:  MOVWF  x2F
04FD6:  MOVFF  714,730
04FDA:  MOVLB  0
04FDC:  RCALL  4D22
....................     configI2C(RTC_YEAR_REG, years);
04FDE:  MOVLW  09
04FE0:  MOVLB  7
04FE2:  MOVWF  x2F
04FE4:  MOVFF  715,730
04FE8:  MOVLB  0
04FEA:  RCALL  4D22
....................    // readRtc(0);
....................    
....................     fprintf(USB, "RTC updated\n");
04FEC:  MOVLW  3C
04FEE:  MOVWF  FF6
04FF0:  MOVLW  08
04FF2:  MOVWF  FF7
04FF4:  MOVLW  00
04FF6:  MOVWF  FF8
04FF8:  CALL   0F40
04FFC:  GOTO   566A (RETURN)
.................... }
.................... 
.................... 
.................... #include <arQ1010/dateTimeDetails.c>
.................... void counterNewYear()
.................... {
....................    char *ptr=NULL;
....................    char temp[20]={};
....................    
....................    if (MIN == 0 && HOUR == 0 && DAY == 31 && MONTH == 12)
....................    {
....................       YEAR_PREV = YEAR - 2000;
....................       fprintf(USB, "YEAR_PREV=%i\n",YEAR_PREV);
....................    }
....................    
....................    if (MIN == 0 && HOUR == 0 && DAY == 1 && MONTH == 1)
....................    {
....................       strcpy(DESIRED_RESPONSE, "+CCLK: ");
....................       delay_ms(100);
....................       YEAR_PREV++;
....................       itoa(YEAR_PREV,10,InterruptUSB_Rxd);
....................       strcpy(temp,"/01/01,00:00:03");
....................       strcat(InterruptUSB_Rxd,temp);
....................       //strcat(InterruptUSB_Rxd,"/01/01,00:00:03");
....................       fprintf(USB, "from COUNTERNEWYEAR =%s\n",InterruptUSB_Rxd);
....................       clear_InterruptUSB();
....................       fprintf(GSM, "AT+CCLK=\"%s\"\r",InterruptUSB_Rxd);
....................       strcpy(InterruptUSB_Rxd,"");
....................       if (GetResponse())
....................          fprintf(USB,"clock set\n");
....................       delay_ms(200);
....................       clear_InterruptUSB();
....................       do {
....................          fprintf(GSM,"AT+CCLK?\r");
....................          delay_ms(200);
....................          ptr = GetResponse();
....................       }while(!ptr);
....................    }
.................... }
.................... 
.................... char *convertDateParam(int param)
.................... {
....................  char *funcSmallStr;
....................    
....................    //fprintf (USB,"param %i\n", param);
....................    
....................    if (param < 10)
*
010E0:  MOVLB  7
010E2:  MOVF   x65,W
010E4:  SUBLW  09
010E6:  BNC   110A
....................       sprintf(funcSmallStr,"0%i",param);
010E8:  MOVFF  767,490
010EC:  MOVFF  766,48F
010F0:  MOVLW  30
010F2:  MOVWF  xBC
010F4:  MOVLB  0
010F6:  RCALL  0F8C
010F8:  MOVFF  765,7AF
010FC:  MOVLW  18
010FE:  MOVLB  7
01100:  MOVWF  xB0
01102:  MOVLB  0
01104:  RCALL  0FDE
01106:  BRA    111E
01108:  MOVLB  7
....................    else
....................       sprintf(funcSmallStr,"%i",param);
0110A:  MOVFF  767,490
0110E:  MOVFF  766,48F
01112:  MOVFF  765,7AF
01116:  MOVLW  18
01118:  MOVWF  xB0
0111A:  MOVLB  0
0111C:  RCALL  0FDE
....................    
....................    //fprintf (USB,"funSmallSTr %s\n", funcSmallStr);
....................    
....................    //delay_ms(50);
....................    return funcSmallStr;
0111E:  MOVLB  7
01120:  MOVFF  766,01
01124:  MOVFF  767,02
01128:  MOVLB  0
0112A:  RETURN 0
....................  }
.................... 
.................... char *getMcuDateTime() 
*
01214:  MOVLB  7
01216:  CLRF   x62
01218:  CLRF   x64
0121A:  CLRF   x63
.................... // create a string composed of date and time in the format YY/MM/DD,HH:MM:SS
.................... // store it in funcReturnVar variable 
.................... {
.................... //!   char strDateTime[20] ={};
.................... //!   char *strDateTime;
....................    char charx = NULL;
....................    char *ptr = NULL;
....................       
....................    charx='/'; 
0121C:  MOVLW  2F
0121E:  MOVWF  x62
....................    
....................    //fprintf (USB,"YEAR: %i\n",YEAR);  
.................... //!   ptr = convertDateParam(YEAR);
.................... //!   strcpy(strDateTime,ptr);
....................    strcpy(strDateTime,convertDateParam(YEAR));
01220:  MOVFF  385,765
01224:  MOVLB  0
01226:  RCALL  10E0
01228:  MOVFF  02,766
0122C:  MOVFF  01,765
01230:  MOVLW  03
01232:  MOVWF  FEA
01234:  MOVLW  87
01236:  MOVWF  FE9
01238:  MOVFF  02,FE2
0123C:  MOVFF  01,FE1
01240:  MOVF   FE7,F
01242:  MOVFF  FE6,FEE
01246:  BNZ   1240
.................... //!   strncat(strDateTime,&charx,1);
.................... 
.................... //!   ptr = convertDateParam(MONTH);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(MONTH));
01248:  MOVFF  384,765
0124C:  RCALL  10E0
0124E:  MOVFF  02,766
01252:  MOVFF  01,765
01256:  MOVLW  03
01258:  MOVLB  7
0125A:  MOVWF  xA8
0125C:  MOVLW  87
0125E:  MOVWF  xA7
01260:  MOVFF  02,7AA
01264:  MOVFF  01,7A9
01268:  MOVLB  0
0126A:  RCALL  112C
.................... //!   strncat(strDateTime,&charx,1);
....................    
.................... //!   charx=',';
....................    
.................... //!   ptr = convertDateParam(DAY);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(DAY));
0126C:  MOVFF  383,765
01270:  RCALL  10E0
01272:  MOVFF  02,766
01276:  MOVFF  01,765
0127A:  MOVLW  03
0127C:  MOVLB  7
0127E:  MOVWF  xA8
01280:  MOVLW  87
01282:  MOVWF  xA7
01284:  MOVFF  02,7AA
01288:  MOVFF  01,7A9
0128C:  MOVLB  0
0128E:  RCALL  112C
....................    strncat(strDateTime,&charx,1);   
01290:  MOVLW  03
01292:  MOVLB  7
01294:  MOVWF  x66
01296:  MOVLW  87
01298:  MOVWF  x65
0129A:  MOVLW  07
0129C:  MOVWF  x68
0129E:  MOVLW  62
012A0:  MOVWF  x67
012A2:  CLRF   x6A
012A4:  MOVLW  01
012A6:  MOVWF  x69
012A8:  MOVLB  0
012AA:  BRA    1196
....................    
.................... //!   charx=':';
....................    
.................... //!   ptr = convertDateParam(HOUR);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(HOUR));
012AC:  MOVFF  382,765
012B0:  RCALL  10E0
012B2:  MOVFF  02,766
012B6:  MOVFF  01,765
012BA:  MOVLW  03
012BC:  MOVLB  7
012BE:  MOVWF  xA8
012C0:  MOVLW  87
012C2:  MOVWF  xA7
012C4:  MOVFF  02,7AA
012C8:  MOVFF  01,7A9
012CC:  MOVLB  0
012CE:  RCALL  112C
.................... //!   strncat(strDateTime,&charx,1);
....................    
.................... //!   ptr = convertDateParam(MIN);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(MIN));
012D0:  MOVFF  381,765
012D4:  RCALL  10E0
012D6:  MOVFF  02,766
012DA:  MOVFF  01,765
012DE:  MOVLW  03
012E0:  MOVLB  7
012E2:  MOVWF  xA8
012E4:  MOVLW  87
012E6:  MOVWF  xA7
012E8:  MOVFF  02,7AA
012EC:  MOVFF  01,7A9
012F0:  MOVLB  0
012F2:  RCALL  112C
.................... //!   strncat(strDateTime,&charx,1);
.................... 
.................... //!   ptr = convertDateParam(SEC);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(SEC));
012F4:  MOVFF  380,765
012F8:  RCALL  10E0
012FA:  MOVFF  02,766
012FE:  MOVFF  01,765
01302:  MOVLW  03
01304:  MOVLB  7
01306:  MOVWF  xA8
01308:  MOVLW  87
0130A:  MOVWF  xA7
0130C:  MOVFF  02,7AA
01310:  MOVFF  01,7A9
01314:  MOVLB  0
01316:  RCALL  112C
.................... 
.................... //!   delay_ms(10);
....................   // fprintf(USB,"MCU date and time: %s\n",strDateTime);
....................     //strcpy(globalDT, strDateTime);
....................     
....................    return strDateTime;
01318:  MOVLW  87
0131A:  MOVWF  01
0131C:  MOVLW  03
0131E:  MOVWF  02
01320:  RETURN 0
....................    
.................... 
.................... }
.................... void updateMcuDateTime(char *ptx) //converts strings to integer and change date and time values
*
0528E:  MOVLB  7
05290:  CLRF   x27
05292:  CLRF   x26
.................... {
....................    char *dataz=NULL;
....................    char temp1[20]={};
05294:  CLRF   x28
05296:  CLRF   x29
05298:  CLRF   x2A
0529A:  CLRF   x2B
0529C:  CLRF   x2C
0529E:  CLRF   x2D
052A0:  CLRF   x2E
052A2:  CLRF   x2F
052A4:  CLRF   x30
052A6:  CLRF   x31
052A8:  CLRF   x32
052AA:  CLRF   x33
052AC:  CLRF   x34
052AE:  CLRF   x35
052B0:  CLRF   x36
052B2:  CLRF   x37
052B4:  CLRF   x38
052B6:  CLRF   x39
052B8:  CLRF   x3A
052BA:  CLRF   x3B
....................    char tempx[3]={};
052BC:  CLRF   x3C
052BE:  CLRF   x3D
052C0:  CLRF   x3E
....................    
....................    //fprintf(USB,"ptx: %s\n",ptx);
....................    
....................    strcpy(TOKEN,"/,:\"");       //yy/mm/dd,hh:mm:ss
052C2:  CLRF   FEA
052C4:  MOVLW  22
052C6:  MOVWF  FE9
052C8:  MOVLW  00
052CA:  MOVLB  0
052CC:  CALL   011C
052D0:  TBLRD*-
052D2:  TBLRD*+
052D4:  MOVF   FF5,W
052D6:  MOVWF  FEE
052D8:  IORLW  00
052DA:  BNZ   52D2
....................    strcpy(temp1,ptx);
052DC:  MOVLW  07
052DE:  MOVWF  FEA
052E0:  MOVLW  28
052E2:  MOVWF  FE9
052E4:  MOVFF  725,FE2
052E8:  MOVFF  724,FE1
052EC:  MOVF   FE7,F
052EE:  MOVFF  FE6,FEE
052F2:  BNZ   52EC
....................    
....................    delay_ms(150);
052F4:  MOVLW  96
052F6:  MOVLB  7
052F8:  MOVWF  x6D
052FA:  MOVLB  0
052FC:  CALL   0F16
....................    dataz = strtok(temp1,TOKEN);
05300:  MOVLW  07
05302:  MOVLB  7
05304:  MOVWF  xA8
05306:  MOVLW  28
05308:  MOVWF  xA7
0530A:  CLRF   xAA
0530C:  MOVLW  22
0530E:  MOVWF  xA9
05310:  MOVLB  0
05312:  CALL   2F58
05316:  MOVFF  02,727
0531A:  MOVFF  01,726
....................    strcpy(tempx,dataz);
0531E:  MOVLW  07
05320:  MOVWF  FEA
05322:  MOVLW  3C
05324:  MOVWF  FE9
05326:  MOVFF  727,FE2
0532A:  MOVFF  726,FE1
0532E:  MOVF   FE7,F
05330:  MOVFF  FE6,FEE
05334:  BNZ   532E
....................    YEAR = atoi(tempx);
05336:  MOVLW  07
05338:  MOVLB  7
0533A:  MOVWF  x40
0533C:  MOVLW  3C
0533E:  MOVWF  x3F
05340:  MOVLB  0
05342:  CALL   4B28
05346:  MOVFF  01,385
....................    //YEAR = YEAR + 2000;
....................    
....................    dataz = strtok(0,TOKEN);
0534A:  MOVLB  7
0534C:  CLRF   xA8
0534E:  CLRF   xA7
05350:  CLRF   xAA
05352:  MOVLW  22
05354:  MOVWF  xA9
05356:  MOVLB  0
05358:  CALL   2F58
0535C:  MOVFF  02,727
05360:  MOVFF  01,726
....................    strcpy(tempx,dataz);
05364:  MOVLW  07
05366:  MOVWF  FEA
05368:  MOVLW  3C
0536A:  MOVWF  FE9
0536C:  MOVFF  727,FE2
05370:  MOVFF  726,FE1
05374:  MOVF   FE7,F
05376:  MOVFF  FE6,FEE
0537A:  BNZ   5374
....................    MONTH = atoi(tempx);
0537C:  MOVLW  07
0537E:  MOVLB  7
05380:  MOVWF  x40
05382:  MOVLW  3C
05384:  MOVWF  x3F
05386:  MOVLB  0
05388:  CALL   4B28
0538C:  MOVFF  01,384
....................    
....................    dataz = strtok(0,TOKEN);
05390:  MOVLB  7
05392:  CLRF   xA8
05394:  CLRF   xA7
05396:  CLRF   xAA
05398:  MOVLW  22
0539A:  MOVWF  xA9
0539C:  MOVLB  0
0539E:  CALL   2F58
053A2:  MOVFF  02,727
053A6:  MOVFF  01,726
....................    strcpy(tempx,dataz);
053AA:  MOVLW  07
053AC:  MOVWF  FEA
053AE:  MOVLW  3C
053B0:  MOVWF  FE9
053B2:  MOVFF  727,FE2
053B6:  MOVFF  726,FE1
053BA:  MOVF   FE7,F
053BC:  MOVFF  FE6,FEE
053C0:  BNZ   53BA
....................    DAY = atoi(tempx);
053C2:  MOVLW  07
053C4:  MOVLB  7
053C6:  MOVWF  x40
053C8:  MOVLW  3C
053CA:  MOVWF  x3F
053CC:  MOVLB  0
053CE:  CALL   4B28
053D2:  MOVFF  01,383
....................    
....................    dataz = strtok(0,TOKEN);
053D6:  MOVLB  7
053D8:  CLRF   xA8
053DA:  CLRF   xA7
053DC:  CLRF   xAA
053DE:  MOVLW  22
053E0:  MOVWF  xA9
053E2:  MOVLB  0
053E4:  CALL   2F58
053E8:  MOVFF  02,727
053EC:  MOVFF  01,726
....................    strcpy(tempx,dataz);
053F0:  MOVLW  07
053F2:  MOVWF  FEA
053F4:  MOVLW  3C
053F6:  MOVWF  FE9
053F8:  MOVFF  727,FE2
053FC:  MOVFF  726,FE1
05400:  MOVF   FE7,F
05402:  MOVFF  FE6,FEE
05406:  BNZ   5400
....................    HOUR = atoi(tempx);
05408:  MOVLW  07
0540A:  MOVLB  7
0540C:  MOVWF  x40
0540E:  MOVLW  3C
05410:  MOVWF  x3F
05412:  MOVLB  0
05414:  CALL   4B28
05418:  MOVFF  01,382
....................    
....................    dataz = strtok(0,TOKEN);
0541C:  MOVLB  7
0541E:  CLRF   xA8
05420:  CLRF   xA7
05422:  CLRF   xAA
05424:  MOVLW  22
05426:  MOVWF  xA9
05428:  MOVLB  0
0542A:  CALL   2F58
0542E:  MOVFF  02,727
05432:  MOVFF  01,726
....................    strcpy(tempx,dataz);
05436:  MOVLW  07
05438:  MOVWF  FEA
0543A:  MOVLW  3C
0543C:  MOVWF  FE9
0543E:  MOVFF  727,FE2
05442:  MOVFF  726,FE1
05446:  MOVF   FE7,F
05448:  MOVFF  FE6,FEE
0544C:  BNZ   5446
....................    MIN = atoi(tempx);
0544E:  MOVLW  07
05450:  MOVLB  7
05452:  MOVWF  x40
05454:  MOVLW  3C
05456:  MOVWF  x3F
05458:  MOVLB  0
0545A:  CALL   4B28
0545E:  MOVFF  01,381
....................    
....................    dataz = strtok(0,TOKEN);
05462:  MOVLB  7
05464:  CLRF   xA8
05466:  CLRF   xA7
05468:  CLRF   xAA
0546A:  MOVLW  22
0546C:  MOVWF  xA9
0546E:  MOVLB  0
05470:  CALL   2F58
05474:  MOVFF  02,727
05478:  MOVFF  01,726
....................    strcpy(tempx,dataz);
0547C:  MOVLW  07
0547E:  MOVWF  FEA
05480:  MOVLW  3C
05482:  MOVWF  FE9
05484:  MOVFF  727,FE2
05488:  MOVFF  726,FE1
0548C:  MOVF   FE7,F
0548E:  MOVFF  FE6,FEE
05492:  BNZ   548C
....................    SEC = atoi(tempx);
05494:  MOVLW  07
05496:  MOVLB  7
05498:  MOVWF  x40
0549A:  MOVLW  3C
0549C:  MOVWF  x3F
0549E:  MOVLB  0
054A0:  CALL   4B28
054A4:  MOVFF  01,380
.................... 
.................... 
.................... //!   fprintf(USB,"MCU date and time: %u/%u/%u,%u:%u:%u\n",YEAR,MONTH,DAY,HOUR,MIN,SEC);
....................    
.................... 
....................    fprintf(USB,"MCU clock set\n");
054A8:  MOVLW  96
054AA:  MOVWF  FF6
054AC:  MOVLW  08
054AE:  MOVWF  FF7
054B0:  MOVLW  00
054B2:  MOVWF  FF8
054B4:  CALL   0F40
054B8:  GOTO   54EC (RETURN)
....................    
.................... }
.................... 
.................... void rtc_acquire_sync()
.................... { char *ptr;
....................   char temp[20];
....................   
....................   ptr = readRtc();
054BC:  BRA    50DA
054BE:  MOVFF  02,70F
054C2:  MOVFF  01,70E
.................... //!  fprintf(USB,"RTC date and time: %s\n",ptr);
.................... 
....................   strcpy(temp,ptr);
054C6:  MOVLW  07
054C8:  MOVWF  FEA
054CA:  MOVLW  10
054CC:  MOVWF  FE9
054CE:  MOVFF  70F,FE2
054D2:  MOVFF  70E,FE1
054D6:  MOVF   FE7,F
054D8:  MOVFF  FE6,FEE
054DC:  BNZ   54D6
....................   updateMcuDateTime(temp);
054DE:  MOVLW  07
054E0:  MOVLB  7
054E2:  MOVWF  x25
054E4:  MOVLW  10
054E6:  MOVWF  x24
054E8:  MOVLB  0
054EA:  BRA    528E
....................   
....................   ptr=getMcuDateTime();
054EC:  CALL   1214
054F0:  MOVFF  02,70F
054F4:  MOVFF  01,70E
....................   fprintf(USB,"MCU date and time: %s\n",ptr);
054F8:  MOVLW  A6
054FA:  MOVWF  FF6
054FC:  MOVLW  08
054FE:  MOVWF  FF7
05500:  MOVLW  00
05502:  MOVWF  FF8
05504:  MOVLW  13
05506:  MOVLB  7
05508:  MOVWF  x90
0550A:  MOVLB  0
0550C:  CALL   157A
05510:  MOVFF  70F,FEA
05514:  MOVFF  70E,FE9
05518:  CALL   10B6
0551C:  MOVLW  0A
0551E:  BTFSS  FA4.4
05520:  BRA    551E
05522:  MOVLB  F
05524:  MOVWF  x1C
05526:  MOVLB  0
05528:  RETURN 0
.................... 
.................... //!    if(stopBTD200Sampling)
.................... //!      {ptr=getMcuDateTime();
.................... //!       strcpy(temp,ptr);
.................... //!       updateMcuDateTime(temp);
.................... //!      
.................... //!      }        
....................           
.................... }
.................... 
.................... 
.................... //!
.................... //!void rtc_acquire_sync_noGSM()
.................... //!{
.................... //!   readRtc(1);
.................... //!   GetDateTime();
.................... //!   //SetGSMTime(funcReturnVar);   
.................... //!}
.................... 
.................... //!
.................... //!void downloadDateTime()
.................... //!{
.................... //!   getDataFromUSB();
.................... //!   SetGSMTime(FROMSERIALPC);
.................... //!   fprintf(USB,"%s",funcReturnVar);
.................... //!   InsertTimeToVariables(funcReturnVar);
.................... //!}
.................... //!
.................... 
.................... 
.................... 
.................... #include <arQ1010/debugmode.c>
.................... //#use rs232(baud=9600, xmit=PIN_G4, rcv=PIN_G3, stream=IDP)// IDP
.................... 
.................... void debugMenu()
.................... {
....................    //fprintf(USB,"\n    FIRMWARE VERSION: %s\n",FIRMWARE);
....................    
....................    fprintf(USB,"      DEBUG MODE MENU\n");
....................    fprintf(USB,"      A.     Get data from the sensor\n");
....................    fprintf(USB,"      B.     Get arQ's current configurations\n");
....................    fprintf(USB,"      C.     Display DEBUG menu\n");
....................    fprintf(USB,"      D.     Change sending time\n");
....................    fprintf(USB,"      E.     Check satellite sending\n");
....................    fprintf(USB,"      F.     Set server number\n");
....................    fprintf(USB,"      G.     List registered numbers\n");
....................    fprintf(USB,"      H.     Generate CRC code\n");
....................    fprintf(USB,"      I.     Set date and time\n");
....................    fprintf(USB,"      J.     Set power board configuration\n");
.................... //!   fprintf(USB,"      K.     VAISALA settings\n");
....................    fprintf(USB,"      L.     Download data from flash memory\n");
....................    fprintf(USB,"      M.     Change password\n");
....................    fprintf(USB,"      N.     Enable satellite\n");
....................    fprintf(USB,"      O.     Set the sensor type\n");
.................... //!   fprintf(USB,"P.    Rain gauge test\n");
....................    fprintf(USB,"      Q.    Test Iridium satellite commands\n");
....................    //fprintf(USB,"      R.     Set soil sensor (5TE) ID\n");
....................    fprintf(USB,"      S.     Turn off watchdog\n");
.................... //!   fprintf(USB,"      T.     Check boost pin\n");
.................... //!   #ifdef DYNAMICRAIN
.................... //!   fprintf(USB,"U.    Set dynamic rain\n");
.................... //!   #endif
.................... //!   fprintf(USB,"V.    Change RMYOUNG ID\n");
....................    fprintf(USB,"      W.     Exit DEBUG mode\n");
....................    fprintf(USB,"      X.     Delete registered number\n");
....................    //fprintf(USB,"Z.    Change SENSLOPE command\n");
....................    fprintf(USB,"      a.     Register number\n");
....................    //fprintf(USB,"      b.     Set GSM provider\n");
....................    //fprintf(USB,"      c.     Manual GSM commads\n");
....................    //fprintf(USB,"d.    IDP test\n");
....................    delay_ms(10);
.................... }
.................... 
.................... 
.................... int1 debugDetails()
0552A:  MOVLB  6
0552C:  CLRF   x9F
0552E:  CLRF   x9E
05530:  BCF    xA0.0
.................... {
....................    int16 yy=0;
....................    
....................    int1 exit_=0;
....................    char debugDataInquire[50]={};
05532:  CLRF   xA1
05534:  CLRF   xA2
05536:  CLRF   xA3
05538:  CLRF   xA4
0553A:  CLRF   xA5
0553C:  CLRF   xA6
0553E:  CLRF   xA7
05540:  CLRF   xA8
05542:  CLRF   xA9
05544:  CLRF   xAA
05546:  CLRF   xAB
05548:  CLRF   xAC
0554A:  CLRF   xAD
0554C:  CLRF   xAE
0554E:  CLRF   xAF
05550:  CLRF   xB0
05552:  CLRF   xB1
05554:  CLRF   xB2
05556:  CLRF   xB3
05558:  CLRF   xB4
0555A:  CLRF   xB5
0555C:  CLRF   xB6
0555E:  CLRF   xB7
05560:  CLRF   xB8
05562:  CLRF   xB9
05564:  CLRF   xBA
05566:  CLRF   xBB
05568:  CLRF   xBC
0556A:  CLRF   xBD
0556C:  CLRF   xBE
0556E:  CLRF   xBF
05570:  CLRF   xC0
05572:  CLRF   xC1
05574:  CLRF   xC2
05576:  CLRF   xC3
05578:  CLRF   xC4
0557A:  CLRF   xC5
0557C:  CLRF   xC6
0557E:  CLRF   xC7
05580:  CLRF   xC8
05582:  CLRF   xC9
05584:  CLRF   xCA
05586:  CLRF   xCB
05588:  CLRF   xCC
0558A:  CLRF   xCD
0558C:  CLRF   xCE
0558E:  CLRF   xCF
05590:  CLRF   xD0
05592:  CLRF   xD1
05594:  CLRF   xD2
....................    char passwordx[15]={};
05596:  CLRF   xD3
05598:  CLRF   xD4
0559A:  CLRF   xD5
0559C:  CLRF   xD6
0559E:  CLRF   xD7
055A0:  CLRF   xD8
055A2:  CLRF   xD9
055A4:  CLRF   xDA
055A6:  CLRF   xDB
055A8:  CLRF   xDC
055AA:  CLRF   xDD
055AC:  CLRF   xDE
055AE:  CLRF   xDF
055B0:  CLRF   xE0
055B2:  CLRF   xE1
....................    
....................    char strx[20]={};
055B4:  CLRF   xE2
055B6:  CLRF   xE3
055B8:  CLRF   xE4
055BA:  CLRF   xE5
055BC:  CLRF   xE6
055BE:  CLRF   xE7
055C0:  CLRF   xE8
055C2:  CLRF   xE9
055C4:  CLRF   xEA
055C6:  CLRF   xEB
055C8:  CLRF   xEC
055CA:  CLRF   xED
055CC:  CLRF   xEE
055CE:  CLRF   xEF
055D0:  CLRF   xF0
055D2:  CLRF   xF1
055D4:  CLRF   xF2
055D6:  CLRF   xF3
055D8:  CLRF   xF4
055DA:  CLRF   xF5
....................    char spacex[2]=" ";
055DC:  MOVLW  20
055DE:  MOVWF  xF6
055E0:  CLRF   xF7
....................    char temp[20]={}; 
055E2:  CLRF   xF8
055E4:  CLRF   xF9
055E6:  CLRF   xFA
055E8:  CLRF   xFB
055EA:  CLRF   xFC
055EC:  CLRF   xFD
055EE:  CLRF   xFE
055F0:  CLRF   xFF
055F2:  MOVLB  7
055F4:  CLRF   x00
055F6:  CLRF   x01
055F8:  CLRF   x02
055FA:  CLRF   x03
055FC:  CLRF   x04
055FE:  CLRF   x05
05600:  CLRF   x06
05602:  CLRF   x07
05604:  CLRF   x08
05606:  CLRF   x09
05608:  CLRF   x0A
0560A:  CLRF   x0B
....................    
....................    char *ptrx;
....................  
....................    //strcpy(funcReturnVar,"");
.................... //   readDataEEprom(EEPROM_PASSWORD);
.................... //   strcpy(passwordx,funcReturnVar);
....................    
....................    fprintf(USB,"\nEnter Choice:\n");
0560C:  MOVLW  8A
0560E:  MOVWF  FF6
05610:  MOVLW  0B
05612:  MOVWF  FF7
05614:  MOVLW  00
05616:  MOVWF  FF8
05618:  MOVLB  0
0561A:  CALL   0F40
....................      
....................    getDataFromUSB();
0561E:  CALL   4AC2
....................    
....................    switch(InterruptUSB_Rxd[0])
05622:  MOVF   2C,W
05624:  XORLW  49
05626:  BZ    562A
05628:  BRA    566E
....................    {
....................       case 'I': //SET DATE AND TIME
....................       {  
....................          getMCUDateTime();
0562A:  CALL   1214
....................          //fprintf(USB,"Current date and time: %s\n",funcReturnVar);
....................          fprintf(USB,"Press C to change\n");
0562E:  MOVLW  9A
05630:  MOVWF  FF6
05632:  MOVLW  0B
05634:  MOVWF  FF7
05636:  MOVLW  00
05638:  MOVWF  FF8
0563A:  CALL   0F40
....................          
....................          getDataFromUSB();
0563E:  CALL   4AC2
....................                   
....................          if (InterruptUSB_Rxd[0] == 'C')
05642:  MOVF   2C,W
05644:  SUBLW  43
05646:  BNZ   566C
....................          {
....................             fprintf(USB,"Enter Date and Time (FORMAT \"YY/MM/DD,HH:MM:SS\")");
05648:  MOVLW  AE
0564A:  MOVWF  FF6
0564C:  MOVLW  0B
0564E:  MOVWF  FF7
05650:  MOVLW  00
05652:  MOVWF  FF8
05654:  CALL   0F40
....................             
....................             getDataFromUSB();
05658:  CALL   4AC2
....................             
....................             setRtc(InterruptUSB_Rxd);
0565C:  MOVLB  7
0565E:  CLRF   x0F
05660:  MOVLW  2C
05662:  MOVWF  x0E
05664:  MOVLB  0
05666:  GOTO   4D46
....................             
....................             rtc_acquire_sync();
0566A:  RCALL  54BC
....................             
....................             //delay_ms(50); //needed to stabilize USB input
....................             //sprintf(debugDataInquire,"DATETIME %s %s",passwordx,InterruptUSB_Rxd);
....................            
....................             //fprintf(USB, "%s",debugDataInquire);
....................             // gsmInquire(debugDataInquire,1);
....................            
.................... //!            InsertTimeToVariables(debugDataInquire);
.................... //!            rtcCreateTime();
.................... //!            //dateTimeStatus();
.................... //!            sprintf(SMS_TOBE_SENT,"DT-%s\n",funcReturnVar);
.................... 
....................          }
....................          break;
0566C:  BRA    5684
....................       }
.................... //!      case 'J': //PBOARD CONFIG
.................... //!      {
.................... //!         //readDataEEprom(EEPROM_SERVER_IP);
.................... //!         //strcpy(strx,funcReturnVar); // get server ip
.................... //!         fprintf(PC,"PBOARDCONFIG = %s\n",PBOARDCONFIG);
.................... //!         fprintf(PC,"Press C to change\n");
.................... //!         getDataFromPC();
.................... //!         if (FROMSERIALPC[0] == 'C')
.................... //!         {
.................... //!            fprintf(PC,"ENTER NEW VALUE\n");
.................... //!            getDataFromPC();
.................... //!            delay_ms(10);
.................... //!            sprintf(debugDataInquire,"PBOARDCONFIG %s %s",passwordx,FROMSERIALPC);
.................... //!            gsmInquire(debugDataInquire,1);
.................... //!         }   
.................... //!         break;
.................... //!      }
.................... //!
....................       default:
....................          fprintf(USB,"Please choose another letter from the DEBUG menu\n");
0566E:  MOVLW  E0
05670:  MOVWF  FF6
05672:  MOVLW  0B
05674:  MOVWF  FF7
05676:  MOVLW  00
05678:  MOVWF  FF8
0567A:  CALL   0F40
....................          break;
0567E:  BRA    5684
....................       
....................    clear_InterruptUSB();
05680:  CALL   0F6E
....................    }
....................    return exit_;
05684:  MOVLW  00
05686:  MOVLB  6
05688:  BTFSC  xA0.0
0568A:  MOVLW  01
0568C:  MOVWF  01
0568E:  MOVLB  0
05690:  GOTO   5B7E (RETURN)
.................... }
.................... //!
.................... //!void testDTR()
.................... //!{
.................... //!   int x;
.................... //!   int y=0;
.................... //!   if (DEBUGMODE != IN_DEBUG_MENU)
.................... //!   {
.................... //!      if (input(pin_USB_STAT))
.................... //!      {
.................... //!         for (x=0;x<=60;x++)
.................... //!         {
.................... //!            if (input(pin_USB_STAT)) 
.................... //!               y++;
.................... //!            else
.................... //!               return;
.................... //!            delay_ms(25);
.................... //!         }
.................... //!      }
.................... //!      if (y >= 50)
.................... //!         DEBUGMODE = USB_DETECTED;
.................... //!      else
.................... //!         DEBUGMODE = NO_USB;
.................... //!   }
.................... //!}
.................... 
.................... 
.................... #include <arQ1010/crc_generate.c>
.................... 
.................... int16 crc_generator(int8 *data, int16 len){
*
01F20:  MOVLB  7
01F22:  SETF   x97
01F24:  SETF   x96
....................    int16 i;
....................    int16 crc = 0xFFFF;
....................    char crc_string[6];
....................    
....................    while(len--){
01F26:  MOVFF  793,03
01F2A:  MOVF   x92,W
01F2C:  BTFSC  FD8.2
01F2E:  DECF   x93,F
01F30:  DECF   x92,F
01F32:  IORWF  03,W
01F34:  BZ    1FB6
....................       i = make8(crc,1) ^ *data++;
01F36:  MOVFF  791,FEA
01F3A:  MOVF   x90,W
01F3C:  INCF   x90,F
01F3E:  BTFSC  FD8.2
01F40:  INCF   x91,F
01F42:  MOVWF  FE9
01F44:  MOVF   FEF,W
01F46:  XORWF  x97,W
01F48:  MOVWF  x94
01F4A:  CLRF   x95
....................       i ^= i>>4;
01F4C:  RRCF   x95,W
01F4E:  MOVWF  03
01F50:  RRCF   x94,W
01F52:  MOVWF  02
01F54:  RRCF   03,F
01F56:  RRCF   02,F
01F58:  RRCF   03,F
01F5A:  RRCF   02,F
01F5C:  RRCF   03,F
01F5E:  RRCF   02,F
01F60:  MOVLW  0F
01F62:  ANDWF  03,F
01F64:  MOVF   02,W
01F66:  XORWF  x94,F
01F68:  MOVF   03,W
01F6A:  XORWF  x95,F
....................       crc = (crc << 8) ^ (i << 12) ^ (i <<5) ^ i;
01F6C:  MOVFF  796,79F
01F70:  CLRF   x9E
01F72:  SWAPF  x94,W
01F74:  MOVWF  03
01F76:  CLRF   02
01F78:  MOVLW  F0
01F7A:  ANDWF  03,F
01F7C:  MOVF   02,W
01F7E:  XORWF  x9E,F
01F80:  MOVF   03,W
01F82:  XORWF  x9F,F
01F84:  RLCF   x94,W
01F86:  MOVWF  02
01F88:  RLCF   x95,W
01F8A:  MOVWF  03
01F8C:  RLCF   02,F
01F8E:  RLCF   03,F
01F90:  RLCF   02,F
01F92:  RLCF   03,F
01F94:  RLCF   02,F
01F96:  RLCF   03,F
01F98:  RLCF   02,F
01F9A:  RLCF   03,F
01F9C:  MOVLW  E0
01F9E:  ANDWF  02,F
01FA0:  MOVF   02,W
01FA2:  XORWF  x9E,F
01FA4:  MOVF   03,W
01FA6:  XORWF  x9F,F
01FA8:  MOVF   x9E,W
01FAA:  XORWF  x94,W
01FAC:  MOVWF  x96
01FAE:  MOVF   x9F,W
01FB0:  XORWF  x95,W
01FB2:  MOVWF  x97
01FB4:  BRA    1F26
....................    }
....................    //fprintf(PC,"CRC: %LX\n",crc);
....................    //sprintf(convto_string, "<%lu>", crc);
....................    itoa(crc,16,crc_string);
01FB6:  CLRF   xA1
01FB8:  CLRF   xA0
01FBA:  MOVFF  797,79F
01FBE:  MOVFF  796,79E
01FC2:  MOVLW  10
01FC4:  MOVWF  xA2
01FC6:  MOVLW  07
01FC8:  MOVWF  xA4
01FCA:  MOVLW  98
01FCC:  MOVWF  xA3
01FCE:  MOVLB  0
01FD0:  BRA    1D66
....................    //strcpy(funcReturnVar,crc_string);
....................    //fprintf(PC,"string: %lu\n",crc);
.................... 
....................    return crc;
01FD2:  MOVLB  7
01FD4:  MOVFF  796,01
01FD8:  MOVFF  797,02
01FDC:  MOVLB  0
01FDE:  RETURN 0
.................... }
.................... 
.................... //#include <arQ1010/voltageDetails.c>
.................... #include <arQ1010/rs485.c>
.................... #define RS485_DE PIN_E5
.................... #define RS485_RE PIN_E6
.................... 
.................... void disable485(){
....................    output_high(RS485_RE);
....................    output_low(RS485_DE);
.................... }
.................... 
.................... void writeToRS485(){
....................    output_high(RS485_RE);
....................    output_high(RS485_DE);
.................... }
....................    
.................... void readFromRS485(){
....................    output_low(RS485_RE);
....................    output_low(RS485_DE);
.................... }
.................... 
.................... 
.................... 
.................... #include <sensors/AS3935.c>
.................... 
.................... //////////////////////////////// the AS3935 file ///////////////////////////////
.................... 
.................... 
.................... // register access macros - register address, bitmask [ NOT Currently using these ]
.................... //!#define AS3935_AFE_GB      0x00, 0x3E
.................... //!#define AS3935_PWD      0x00, 0x01
.................... //!#define AS3935_NF_LEV      0x01, 0x70
.................... //!#define AS3935_WDTH      0x01, 0x0F
.................... //!#define AS3935_CL_STAT      0x02, 0x40
.................... //!#define AS3935_MIN_NUM_LIGH   0x02, 0x30
.................... //!#define AS3935_SREJ      0x02, 0x0F
.................... //!#define AS3935_LCO_FDIV   0x03, 0xC0
.................... //!#define AS3935_MASK_DIST   0x03, 0x20
.................... //!#define AS3935_INT      0x03, 0x0F
.................... //!#define AS3935_DISTANCE   0x07, 0x3F
.................... //!#define AS3935_DISP_LCO   0x08, 0x80
.................... //!#define AS3935_DISP_SRCO   0x08, 0x40
.................... //!#define AS3935_DISP_TRCO   0x08, 0x20
.................... //!#define AS3935_TUN_CAP      0x08, 0x0F
.................... 
.................... // other constants
.................... #define INDOOR 0x12
.................... #define OUTDOOR 0x0E
....................  
.................... 
.................... //!unsigned int8 tmp1;
.................... //int32 tmp2;
.................... //int16 message_count = 0;
.................... //int16 Total_Lightings_Detected = 0;
.................... //int1 InterruptFlag = 0;
.................... //unsigned int8 buffer;
.................... unsigned int8 interrupt_source;
.................... //char i;
.................... 
.................... //Func protos
.................... int1 Thunder_Init(void);
.................... void Thunder_Write(unsigned int8 address, unsigned int8 data1);
.................... unsigned int8 Thunder_Read(unsigned int8 address);
.................... int32 Thunder_Read_Energy(void);
.................... unsigned int16 Thunder_Read_distance(void);
.................... void ReadInternalData(void);
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Init()
.................... *
.................... * These are the same functions from the PIC32 example from Mikroe which works fine
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function Initializes Thunder chip
.................... * Input: register address, data
.................... * Output: Nothing
.................... *******************************************************************************/
.................... int1 Thunder_Init(void) {
.................... unsigned int8 temp;
.................... int i;
.................... int checker=0;
....................  
....................   output_high(EN1);              // Set CS to idle
.................... 
....................   Thunder_Write(0x3C, 0x96);           // set all registers in default mode
....................   delay_ms(3);
....................   
....................   Thunder_Write(0x3D, 0x96);           // calibrate internal oscillator
....................   delay_ms(3);
....................   
.................... //!  //CHecking of current configuration values.
.................... //!  for (i=0; i<=8;i++)
.................... //!   {temp = Thunder_Read(i);
.................... //!    fprintf(USB, "0x0%i: 0x%X\n", i, temp);
.................... //!    delay_ms(3);
.................... //!   
.................... //!   }
....................   
.................... //!  temp = Thunder_Read(0x00) & 0xC1;
.................... //!  fprintf(USB, "Ox00 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x00, ((OUTDOOR  << 1) | temp)); // set to INDOOR or OUTDOOR
....................   delay_ms(3);
....................   
.................... //!  temp = Thunder_Read(0x01) & 0x80;
.................... //!  fprintf(USB, "Ox01 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x01, 0x22 | temp);    // set NFL and WDTreshold 0x44
....................   delay_ms(3);
....................   
.................... //!  temp = Thunder_Read(0x02) & 0x80;    // clear statistics, min number of ligtning, spike rejection
.................... //!  fprintf(USB, "Ox02 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x02, 0xC2); //set minimum number of lightning per interrupt.  0XC2 for for 1, 0XD2 for 5 
....................   delay_ms(3);
....................   
.................... //!  temp = Thunder_Read(0x03) & 0x1F;   // Frequency division ratio(antenna),mask disturber, interrupt
.................... //!  fprintf(USB, "Ox03 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x03, 0x00 | temp);
....................   delay_ms(3);
....................   
....................   Thunder_Write(0x08, 0x00);           // LCO, SRCO, TRCO on IRQ, capacitors tuning
....................   delay_ms(200);
....................   
.................... /*
....................   //Check of current configuration values.
....................   for (i=0; i<=8;i++)
....................    {temp = Thunder_Read(i);
....................     switch(i)
....................       {
....................       case 0: 
....................          if(temp==0x1C || temp==0x1D) //0x1D is powered down/reset.
....................             checker++;
....................          break;
....................       
....................       case 1: 
....................          if(temp==0x22)
....................             checker++;
....................          break;
....................          
....................       case 2: 
....................          if(temp==0xC2)
....................             checker++;
....................          break;   
....................          
....................       case 3:
....................          if(temp==0x00 || temp==0x01 || temp==0x02 || temp==0x04 || temp==0x08)
....................             checker++;
....................          break;
....................       
....................       case 7: 
....................          if(temp==0x3F||0x11)
....................             checker++;
....................          break;
....................          
....................       default:
....................          if(temp==0x00)
....................             checker++;
....................          break;
....................       }  
....................          
....................     //fprintf(USB, "0x0%i: 0x%X\n", i, temp);
....................     delay_ms(5);
....................    }
....................    
....................    //fprintf(USB, "checker: %i\n", checker);
....................    if (checker==9)
....................       {fprintf(USB, "AS3935 Initiatized\n");
....................        return TRUE;
....................       }
....................    else
....................       {fprintf(USB, "AS3935 Error\n");
....................        return FALSE;
....................       }
.................... */
....................   fprintf(USB, "AS3935 Ready\n");
.................... }
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Write(unsigned short address, unsigned short data1)
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function writes desired byte into specified register address
.................... * Input: register address, byte
.................... * Output: Nothing
.................... *******************************************************************************/
.................... void Thunder_Write(unsigned int8 address, unsigned int8 data1)  {
....................    
....................   bit_clear(address,7);       // set both bits 6&7 to 0 to do a write                       
....................   bit_clear(address,6); 
....................   output_low(EN1);     
....................   //delay_ms(10);
....................   spi_xfer(address);         // spi_write(address);
....................   spi_xfer(data1);          // spi_write(data1);
....................  //delay_ms(10);
....................   output_high(EN1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Read(unsigned short address)
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function reads byte from specified address
.................... * Input: register address
.................... * Output: desired byte
.................... *******************************************************************************/
.................... unsigned int8 Thunder_Read(unsigned int8 address) {
....................   unsigned int8 tmp = 0;
....................  
....................  // fprintf(USB, "add: 0X%X\n", address);
....................   bit_clear(address,7);      // set both bits 7 =0 and bit 6 = 1 to do a read 
....................   bit_set(address,6);
....................   
....................   output_low(EN1);
....................   spi_xfer(address);            //spi_write(address); 
....................   tmp = spi_xfer(0);        // spi read data; 
....................   //fprintf(USB, "tmp: 0X%X\n", tmp);
....................   output_high(EN1);
....................   return tmp;
.................... }
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Read_Energy()
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function reads energy of detected thunder
.................... * Input: Nothing
.................... * Output: Measured result
.................... *******************************************************************************/
.................... int32 Thunder_Read_Energy() {
....................   unsigned int8 low_byte, mid_byte;
....................   int32 Out_thunder_energy;
....................  
....................   Out_thunder_energy = Thunder_Read(0x06) & 0x1F;
....................   mid_byte = Thunder_Read(0x05);
....................   low_byte = Thunder_Read(0x04);
....................  
....................   Out_thunder_energy = (Out_thunder_energy << 8);
....................   Out_thunder_energy = (Out_thunder_energy | mid_byte);
....................   Out_thunder_energy = (Out_thunder_energy << 8);
....................   Out_thunder_energy = (Out_thunder_energy | low_byte);
....................  
....................   return Out_thunder_energy;
.................... }
....................  
....................  
.................... /*******************************************************************************
.................... * Function Thunder_Read_distance()
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function reads distance from detected thunder
.................... * Input: Nothing
.................... * Output: Measured result
.................... *******************************************************************************/
.................... unsigned int16 Thunder_Read_distance() {
....................   int16 Out_thunder_distance;
....................  
....................   Out_thunder_distance = Thunder_Read(0x07) & 0x3F;
....................   //fprintf(USB, "dist1: %lu\n", Out_thunder_distance);
....................   
....................   return Out_thunder_distance;
.................... }
.................... 
.................... #include <sensors/BTD200.c>
.................... 
.................... //#use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT1)
.................... //char strBTD[100]={};
.................... //#use rs232(baud=57600, xmit=PIN_G4, rcv=PIN_G3, stream=RS232_BTD200)
.................... //#use rs232(baud=57600, xmit=TX_USB, rcv=RX_USB, stream=USB)
.................... 
....................  char message[255]={};
.................... 
.................... void btdStatus(w){
....................    //char recon;
....................   
....................    switch (w){
*
02394:  MOVLB  7
02396:  MOVF   x61,W
02398:  XORLW  01
0239A:  MOVLB  0
0239C:  BZ    23B8
0239E:  XORLW  03
023A0:  BTFSC  FD8.2
023A2:  BRA    2542
023A4:  XORLW  01
023A6:  BTFSC  FD8.2
023A8:  BRA    2658
023AA:  XORLW  07
023AC:  BTFSC  FD8.2
023AE:  BRA    276E
023B0:  XORLW  01
023B2:  BTFSC  FD8.2
023B4:  BRA    2884
023B6:  BRA    299C
....................       case 1:
....................          fprintf(USB,"\nLightning Detected!!!\n******************************************************************************************************************************************************");
023B8:  MOVLW  20
023BA:  MOVWF  FF6
023BC:  MOVLW  0C
023BE:  MOVWF  FF7
023C0:  MOVLW  00
023C2:  MOVWF  FF8
023C4:  CALL   0F40
....................          sprintf(message, "FC:%s+%sGS:*+BT:%s+DT:*\r", flashCount, BTDLaLo, biralBT); 
023C8:  MOVLW  04
023CA:  MOVLB  4
023CC:  MOVWF  x90
023CE:  MOVLW  93
023D0:  MOVWF  x8F
023D2:  MOVLW  CE
023D4:  MOVWF  FF6
023D6:  MOVLW  0C
023D8:  MOVWF  FF7
023DA:  MOVLW  00
023DC:  MOVWF  FF8
023DE:  MOVLW  03
023E0:  MOVLB  7
023E2:  MOVWF  xAF
023E4:  MOVLB  0
023E6:  CALL   0FAE
023EA:  MOVFF  490,FEA
023EE:  MOVFF  48F,FE9
023F2:  CLRF   FEF
023F4:  MOVLW  04
023F6:  MOVWF  FEA
023F8:  MOVLW  4F
023FA:  MOVWF  FE9
023FC:  CALL   1322
02400:  MOVLW  2B
02402:  MOVLB  7
02404:  MOVWF  xBC
02406:  MOVLB  0
02408:  CALL   0F8C
0240C:  MOVFF  490,FEA
02410:  MOVFF  48F,FE9
02414:  CLRF   FEF
02416:  MOVLW  03
02418:  MOVWF  FEA
0241A:  MOVLW  AF
0241C:  MOVWF  FE9
0241E:  CALL   1322
02422:  MOVLW  D6
02424:  MOVWF  FF6
02426:  MOVLW  0C
02428:  MOVWF  FF7
0242A:  MOVLW  00
0242C:  MOVWF  FF8
0242E:  MOVLW  08
02430:  MOVLB  7
02432:  MOVWF  xAF
02434:  MOVLB  0
02436:  CALL   0FAE
0243A:  MOVFF  490,FEA
0243E:  MOVFF  48F,FE9
02442:  CLRF   FEF
02444:  MOVLW  03
02446:  MOVWF  FEA
02448:  MOVLW  9B
0244A:  MOVWF  FE9
0244C:  CALL   1322
02450:  MOVLW  E0
02452:  MOVWF  FF6
02454:  MOVLW  0C
02456:  MOVWF  FF7
02458:  MOVLW  00
0245A:  MOVWF  FF8
0245C:  MOVLW  06
0245E:  MOVLB  7
02460:  MOVWF  xAF
02462:  MOVLB  0
02464:  CALL   0FAE
....................          fprintf(USB, "SMS to Sent: %s", message);
02468:  MOVLW  E8
0246A:  MOVWF  FF6
0246C:  MOVLW  0C
0246E:  MOVWF  FF7
02470:  MOVLW  00
02472:  MOVWF  FF8
02474:  MOVLW  0D
02476:  MOVLB  7
02478:  MOVWF  x90
0247A:  MOVLB  0
0247C:  CALL   157A
02480:  MOVLW  04
02482:  MOVWF  FEA
02484:  MOVLW  93
02486:  MOVWF  FE9
02488:  CALL   10B6
....................          sendToLTE(message);
0248C:  MOVLW  04
0248E:  MOVLB  7
02490:  MOVWF  x69
02492:  MOVLW  93
02494:  MOVWF  x68
02496:  MOVLB  0
02498:  CALL   17E8
....................          strcpy(BTDLaLo, "");   
0249C:  MOVLW  03
0249E:  MOVWF  FEA
024A0:  MOVLW  AF
024A2:  MOVWF  FE9
024A4:  MOVLW  00
024A6:  CALL   00EE
024AA:  TBLRD*-
024AC:  TBLRD*+
024AE:  MOVF   FF5,W
024B0:  MOVWF  FEE
024B2:  IORLW  00
024B4:  BNZ   24AC
....................          
....................          getMcuDateTime();
024B6:  CALL   1214
....................          strcpy(biralBT, strDateTime);
024BA:  MOVLW  03
024BC:  MOVWF  FEA
024BE:  MOVLW  9B
024C0:  MOVWF  FE9
024C2:  MOVLW  03
024C4:  MOVWF  FE2
024C6:  MOVLW  87
024C8:  MOVWF  FE1
024CA:  MOVF   FE7,F
024CC:  MOVFF  FE6,FEE
024D0:  BNZ   24CA
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
024D2:  MOVLW  F8
024D4:  MOVWF  FF6
024D6:  MOVLW  0C
024D8:  MOVWF  FF7
024DA:  MOVLW  00
024DC:  MOVWF  FF8
024DE:  MOVLW  0B
024E0:  MOVLB  7
024E2:  MOVWF  x90
024E4:  MOVLB  0
024E6:  CALL   157A
024EA:  MOVLW  03
024EC:  MOVWF  FEA
024EE:  MOVLW  9B
024F0:  MOVWF  FE9
024F2:  CALL   10B6
024F6:  MOVLW  0A
024F8:  BTFSS  FA4.4
024FA:  BRA    24F8
024FC:  MOVLB  F
024FE:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02500:  MOVLW  03
02502:  MOVWF  FEA
02504:  MOVLW  87
02506:  MOVWF  FE9
02508:  MOVLW  00
0250A:  MOVLB  0
0250C:  CALL   00EE
02510:  TBLRD*-
02512:  TBLRD*+
02514:  MOVF   FF5,W
02516:  MOVWF  FEE
02518:  IORLW  00
0251A:  BNZ   2512
....................          strcpy(biralBT, ""); 
0251C:  MOVLW  03
0251E:  MOVWF  FEA
02520:  MOVLW  9B
02522:  MOVWF  FE9
02524:  MOVLW  00
02526:  CALL   00EE
0252A:  TBLRD*-
0252C:  TBLRD*+
0252E:  MOVF   FF5,W
02530:  MOVWF  FEE
02532:  IORLW  00
02534:  BNZ   252C
....................          
....................          fprintf(USB, "\n");
02536:  MOVLW  0A
02538:  BTFSS  FA4.4
0253A:  BRA    2538
0253C:  MOVLB  F
0253E:  MOVWF  x1C
....................          break;
02540:  BRA    299E
....................       
....................       case 2:
....................          //fprintf(USB, "\nTest switch"); 
....................          strcpy(strBTD_con, "BTDrecon\r");
02542:  MOVLW  04
02544:  MOVWF  FEA
02546:  MOVLW  59
02548:  MOVWF  FE9
0254A:  MOVLW  00
0254C:  CALL   0136
02550:  TBLRD*-
02552:  TBLRD*+
02554:  MOVF   FF5,W
02556:  MOVWF  FEE
02558:  IORLW  00
0255A:  BNZ   2552
....................          sprintf(message, "%s", strBTD_con); 
0255C:  MOVLW  04
0255E:  MOVLB  4
02560:  MOVWF  x90
02562:  MOVLW  93
02564:  MOVWF  x8F
02566:  MOVFF  490,FEA
0256A:  MOVFF  48F,FE9
0256E:  CLRF   FEF
02570:  MOVLW  04
02572:  MOVWF  FEA
02574:  MOVLW  59
02576:  MOVWF  FE9
02578:  MOVLB  0
0257A:  CALL   1322
....................          fprintf(USB, "SMS to Sent: %s", message);
0257E:  MOVLW  08
02580:  MOVWF  FF6
02582:  MOVLW  0D
02584:  MOVWF  FF7
02586:  MOVLW  00
02588:  MOVWF  FF8
0258A:  MOVLW  0D
0258C:  MOVLB  7
0258E:  MOVWF  x90
02590:  MOVLB  0
02592:  CALL   157A
02596:  MOVLW  04
02598:  MOVWF  FEA
0259A:  MOVLW  93
0259C:  MOVWF  FE9
0259E:  CALL   10B6
....................          sendToLTE(message);
025A2:  MOVLW  04
025A4:  MOVLB  7
025A6:  MOVWF  x69
025A8:  MOVLW  93
025AA:  MOVWF  x68
025AC:  MOVLB  0
025AE:  CALL   17E8
....................          strcpy(strBTD_con, "");
025B2:  MOVLW  04
025B4:  MOVWF  FEA
025B6:  MOVLW  59
025B8:  MOVWF  FE9
025BA:  MOVLW  00
025BC:  CALL   00EE
025C0:  TBLRD*-
025C2:  TBLRD*+
025C4:  MOVF   FF5,W
025C6:  MOVWF  FEE
025C8:  IORLW  00
025CA:  BNZ   25C2
....................          
....................          getMcuDateTime();
025CC:  CALL   1214
....................          strcpy(biralBT, strDateTime);
025D0:  MOVLW  03
025D2:  MOVWF  FEA
025D4:  MOVLW  9B
025D6:  MOVWF  FE9
025D8:  MOVLW  03
025DA:  MOVWF  FE2
025DC:  MOVLW  87
025DE:  MOVWF  FE1
025E0:  MOVF   FE7,F
025E2:  MOVFF  FE6,FEE
025E6:  BNZ   25E0
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
025E8:  MOVLW  18
025EA:  MOVWF  FF6
025EC:  MOVLW  0D
025EE:  MOVWF  FF7
025F0:  MOVLW  00
025F2:  MOVWF  FF8
025F4:  MOVLW  0B
025F6:  MOVLB  7
025F8:  MOVWF  x90
025FA:  MOVLB  0
025FC:  CALL   157A
02600:  MOVLW  03
02602:  MOVWF  FEA
02604:  MOVLW  9B
02606:  MOVWF  FE9
02608:  CALL   10B6
0260C:  MOVLW  0A
0260E:  BTFSS  FA4.4
02610:  BRA    260E
02612:  MOVLB  F
02614:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02616:  MOVLW  03
02618:  MOVWF  FEA
0261A:  MOVLW  87
0261C:  MOVWF  FE9
0261E:  MOVLW  00
02620:  MOVLB  0
02622:  CALL   00EE
02626:  TBLRD*-
02628:  TBLRD*+
0262A:  MOVF   FF5,W
0262C:  MOVWF  FEE
0262E:  IORLW  00
02630:  BNZ   2628
....................          strcpy(biralBT, ""); 
02632:  MOVLW  03
02634:  MOVWF  FEA
02636:  MOVLW  9B
02638:  MOVWF  FE9
0263A:  MOVLW  00
0263C:  CALL   00EE
02640:  TBLRD*-
02642:  TBLRD*+
02644:  MOVF   FF5,W
02646:  MOVWF  FEE
02648:  IORLW  00
0264A:  BNZ   2642
....................          
....................          fprintf(USB, "\n");
0264C:  MOVLW  0A
0264E:  BTFSS  FA4.4
02650:  BRA    264E
02652:  MOVLB  F
02654:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;  
02656:  BRA    299E
....................          
....................       case 3:
....................          strcpy(strBTD_con, "BTDcon\r");
02658:  MOVLW  04
0265A:  MOVWF  FEA
0265C:  MOVLW  59
0265E:  MOVWF  FE9
02660:  MOVLW  00
02662:  CALL   0154
02666:  TBLRD*-
02668:  TBLRD*+
0266A:  MOVF   FF5,W
0266C:  MOVWF  FEE
0266E:  IORLW  00
02670:  BNZ   2668
....................          sprintf(message, "%s", strBTD_con); 
02672:  MOVLW  04
02674:  MOVLB  4
02676:  MOVWF  x90
02678:  MOVLW  93
0267A:  MOVWF  x8F
0267C:  MOVFF  490,FEA
02680:  MOVFF  48F,FE9
02684:  CLRF   FEF
02686:  MOVLW  04
02688:  MOVWF  FEA
0268A:  MOVLW  59
0268C:  MOVWF  FE9
0268E:  MOVLB  0
02690:  CALL   1322
....................          fprintf(USB, "SMS to Sent: %s", message);
02694:  MOVLW  28
02696:  MOVWF  FF6
02698:  MOVLW  0D
0269A:  MOVWF  FF7
0269C:  MOVLW  00
0269E:  MOVWF  FF8
026A0:  MOVLW  0D
026A2:  MOVLB  7
026A4:  MOVWF  x90
026A6:  MOVLB  0
026A8:  CALL   157A
026AC:  MOVLW  04
026AE:  MOVWF  FEA
026B0:  MOVLW  93
026B2:  MOVWF  FE9
026B4:  CALL   10B6
....................          sendToLTE(message);
026B8:  MOVLW  04
026BA:  MOVLB  7
026BC:  MOVWF  x69
026BE:  MOVLW  93
026C0:  MOVWF  x68
026C2:  MOVLB  0
026C4:  CALL   17E8
....................          strcpy(strBTD_con, "");
026C8:  MOVLW  04
026CA:  MOVWF  FEA
026CC:  MOVLW  59
026CE:  MOVWF  FE9
026D0:  MOVLW  00
026D2:  CALL   00EE
026D6:  TBLRD*-
026D8:  TBLRD*+
026DA:  MOVF   FF5,W
026DC:  MOVWF  FEE
026DE:  IORLW  00
026E0:  BNZ   26D8
....................          
....................          getMcuDateTime();
026E2:  CALL   1214
....................          strcpy(biralBT, strDateTime);
026E6:  MOVLW  03
026E8:  MOVWF  FEA
026EA:  MOVLW  9B
026EC:  MOVWF  FE9
026EE:  MOVLW  03
026F0:  MOVWF  FE2
026F2:  MOVLW  87
026F4:  MOVWF  FE1
026F6:  MOVF   FE7,F
026F8:  MOVFF  FE6,FEE
026FC:  BNZ   26F6
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
026FE:  MOVLW  38
02700:  MOVWF  FF6
02702:  MOVLW  0D
02704:  MOVWF  FF7
02706:  MOVLW  00
02708:  MOVWF  FF8
0270A:  MOVLW  0B
0270C:  MOVLB  7
0270E:  MOVWF  x90
02710:  MOVLB  0
02712:  CALL   157A
02716:  MOVLW  03
02718:  MOVWF  FEA
0271A:  MOVLW  9B
0271C:  MOVWF  FE9
0271E:  CALL   10B6
02722:  MOVLW  0A
02724:  BTFSS  FA4.4
02726:  BRA    2724
02728:  MOVLB  F
0272A:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
0272C:  MOVLW  03
0272E:  MOVWF  FEA
02730:  MOVLW  87
02732:  MOVWF  FE9
02734:  MOVLW  00
02736:  MOVLB  0
02738:  CALL   00EE
0273C:  TBLRD*-
0273E:  TBLRD*+
02740:  MOVF   FF5,W
02742:  MOVWF  FEE
02744:  IORLW  00
02746:  BNZ   273E
....................          strcpy(biralBT, ""); 
02748:  MOVLW  03
0274A:  MOVWF  FEA
0274C:  MOVLW  9B
0274E:  MOVWF  FE9
02750:  MOVLW  00
02752:  CALL   00EE
02756:  TBLRD*-
02758:  TBLRD*+
0275A:  MOVF   FF5,W
0275C:  MOVWF  FEE
0275E:  IORLW  00
02760:  BNZ   2758
....................          
....................          fprintf(USB, "\n");
02762:  MOVLW  0A
02764:  BTFSS  FA4.4
02766:  BRA    2764
02768:  MOVLB  F
0276A:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;
0276C:  BRA    299E
....................          
....................      case 4:
....................          strcpy(strBTD_con, "BTDstable\r");
0276E:  MOVLW  04
02770:  MOVWF  FEA
02772:  MOVLW  59
02774:  MOVWF  FE9
02776:  MOVLW  00
02778:  CALL   0170
0277C:  TBLRD*-
0277E:  TBLRD*+
02780:  MOVF   FF5,W
02782:  MOVWF  FEE
02784:  IORLW  00
02786:  BNZ   277E
....................          sprintf(message, "%s", strBTD_con); 
02788:  MOVLW  04
0278A:  MOVLB  4
0278C:  MOVWF  x90
0278E:  MOVLW  93
02790:  MOVWF  x8F
02792:  MOVFF  490,FEA
02796:  MOVFF  48F,FE9
0279A:  CLRF   FEF
0279C:  MOVLW  04
0279E:  MOVWF  FEA
027A0:  MOVLW  59
027A2:  MOVWF  FE9
027A4:  MOVLB  0
027A6:  CALL   1322
....................          fprintf(USB, "SMS to Sent: %s", message);
027AA:  MOVLW  48
027AC:  MOVWF  FF6
027AE:  MOVLW  0D
027B0:  MOVWF  FF7
027B2:  MOVLW  00
027B4:  MOVWF  FF8
027B6:  MOVLW  0D
027B8:  MOVLB  7
027BA:  MOVWF  x90
027BC:  MOVLB  0
027BE:  CALL   157A
027C2:  MOVLW  04
027C4:  MOVWF  FEA
027C6:  MOVLW  93
027C8:  MOVWF  FE9
027CA:  CALL   10B6
....................          sendToLTE(message);
027CE:  MOVLW  04
027D0:  MOVLB  7
027D2:  MOVWF  x69
027D4:  MOVLW  93
027D6:  MOVWF  x68
027D8:  MOVLB  0
027DA:  CALL   17E8
....................          strcpy(strBTD_con, "");
027DE:  MOVLW  04
027E0:  MOVWF  FEA
027E2:  MOVLW  59
027E4:  MOVWF  FE9
027E6:  MOVLW  00
027E8:  CALL   00EE
027EC:  TBLRD*-
027EE:  TBLRD*+
027F0:  MOVF   FF5,W
027F2:  MOVWF  FEE
027F4:  IORLW  00
027F6:  BNZ   27EE
....................                   
....................          getMcuDateTime();
027F8:  CALL   1214
....................          strcpy(biralBT, strDateTime);
027FC:  MOVLW  03
027FE:  MOVWF  FEA
02800:  MOVLW  9B
02802:  MOVWF  FE9
02804:  MOVLW  03
02806:  MOVWF  FE2
02808:  MOVLW  87
0280A:  MOVWF  FE1
0280C:  MOVF   FE7,F
0280E:  MOVFF  FE6,FEE
02812:  BNZ   280C
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
02814:  MOVLW  58
02816:  MOVWF  FF6
02818:  MOVLW  0D
0281A:  MOVWF  FF7
0281C:  MOVLW  00
0281E:  MOVWF  FF8
02820:  MOVLW  0B
02822:  MOVLB  7
02824:  MOVWF  x90
02826:  MOVLB  0
02828:  CALL   157A
0282C:  MOVLW  03
0282E:  MOVWF  FEA
02830:  MOVLW  9B
02832:  MOVWF  FE9
02834:  CALL   10B6
02838:  MOVLW  0A
0283A:  BTFSS  FA4.4
0283C:  BRA    283A
0283E:  MOVLB  F
02840:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02842:  MOVLW  03
02844:  MOVWF  FEA
02846:  MOVLW  87
02848:  MOVWF  FE9
0284A:  MOVLW  00
0284C:  MOVLB  0
0284E:  CALL   00EE
02852:  TBLRD*-
02854:  TBLRD*+
02856:  MOVF   FF5,W
02858:  MOVWF  FEE
0285A:  IORLW  00
0285C:  BNZ   2854
....................          strcpy(biralBT, ""); 
0285E:  MOVLW  03
02860:  MOVWF  FEA
02862:  MOVLW  9B
02864:  MOVWF  FE9
02866:  MOVLW  00
02868:  CALL   00EE
0286C:  TBLRD*-
0286E:  TBLRD*+
02870:  MOVF   FF5,W
02872:  MOVWF  FEE
02874:  IORLW  00
02876:  BNZ   286E
....................          
....................          fprintf(USB, "\n");
02878:  MOVLW  0A
0287A:  BTFSS  FA4.4
0287C:  BRA    287A
0287E:  MOVLB  F
02880:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;
02882:  BRA    299E
....................          
....................       case 5:
....................          strcpy(strBTD_con, "BTDcon\r");
02884:  MOVLW  04
02886:  MOVWF  FEA
02888:  MOVLW  59
0288A:  MOVWF  FE9
0288C:  MOVLW  00
0288E:  CALL   0154
02892:  TBLRD*-
02894:  TBLRD*+
02896:  MOVF   FF5,W
02898:  MOVWF  FEE
0289A:  IORLW  00
0289C:  BNZ   2894
....................          sprintf(message, "%s", strBTD_con); 
0289E:  MOVLW  04
028A0:  MOVLB  4
028A2:  MOVWF  x90
028A4:  MOVLW  93
028A6:  MOVWF  x8F
028A8:  MOVFF  490,FEA
028AC:  MOVFF  48F,FE9
028B0:  CLRF   FEF
028B2:  MOVLW  04
028B4:  MOVWF  FEA
028B6:  MOVLW  59
028B8:  MOVWF  FE9
028BA:  MOVLB  0
028BC:  CALL   1322
....................          fprintf(USB, "SMS to Sent: %s", message);
028C0:  MOVLW  68
028C2:  MOVWF  FF6
028C4:  MOVLW  0D
028C6:  MOVWF  FF7
028C8:  MOVLW  00
028CA:  MOVWF  FF8
028CC:  MOVLW  0D
028CE:  MOVLB  7
028D0:  MOVWF  x90
028D2:  MOVLB  0
028D4:  CALL   157A
028D8:  MOVLW  04
028DA:  MOVWF  FEA
028DC:  MOVLW  93
028DE:  MOVWF  FE9
028E0:  CALL   10B6
....................          sendToLTE(message);
028E4:  MOVLW  04
028E6:  MOVLB  7
028E8:  MOVWF  x69
028EA:  MOVLW  93
028EC:  MOVWF  x68
028EE:  MOVLB  0
028F0:  CALL   17E8
....................          strcpy(strBTD_con, "");
028F4:  MOVLW  04
028F6:  MOVWF  FEA
028F8:  MOVLW  59
028FA:  MOVWF  FE9
028FC:  MOVLW  00
028FE:  CALL   00EE
02902:  TBLRD*-
02904:  TBLRD*+
02906:  MOVF   FF5,W
02908:  MOVWF  FEE
0290A:  IORLW  00
0290C:  BNZ   2904
....................            
....................          
....................          getMcuDateTime();
0290E:  CALL   1214
....................          strcpy(biralBT, strDateTime);
02912:  MOVLW  03
02914:  MOVWF  FEA
02916:  MOVLW  9B
02918:  MOVWF  FE9
0291A:  MOVLW  03
0291C:  MOVWF  FE2
0291E:  MOVLW  87
02920:  MOVWF  FE1
02922:  MOVF   FE7,F
02924:  MOVFF  FE6,FEE
02928:  BNZ   2922
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
0292A:  MOVLW  78
0292C:  MOVWF  FF6
0292E:  MOVLW  0D
02930:  MOVWF  FF7
02932:  MOVLW  00
02934:  MOVWF  FF8
02936:  MOVLW  0B
02938:  MOVLB  7
0293A:  MOVWF  x90
0293C:  MOVLB  0
0293E:  CALL   157A
02942:  MOVLW  03
02944:  MOVWF  FEA
02946:  MOVLW  9B
02948:  MOVWF  FE9
0294A:  CALL   10B6
0294E:  MOVLW  0A
02950:  BTFSS  FA4.4
02952:  BRA    2950
02954:  MOVLB  F
02956:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02958:  MOVLW  03
0295A:  MOVWF  FEA
0295C:  MOVLW  87
0295E:  MOVWF  FE9
02960:  MOVLW  00
02962:  MOVLB  0
02964:  CALL   00EE
02968:  TBLRD*-
0296A:  TBLRD*+
0296C:  MOVF   FF5,W
0296E:  MOVWF  FEE
02970:  IORLW  00
02972:  BNZ   296A
....................          strcpy(biralBT, ""); 
02974:  MOVLW  03
02976:  MOVWF  FEA
02978:  MOVLW  9B
0297A:  MOVWF  FE9
0297C:  MOVLW  00
0297E:  CALL   00EE
02982:  TBLRD*-
02984:  TBLRD*+
02986:  MOVF   FF5,W
02988:  MOVWF  FEE
0298A:  IORLW  00
0298C:  BNZ   2984
....................          
....................          fprintf(USB, "\n");
0298E:  MOVLW  0A
02990:  BTFSS  FA4.4
02992:  BRA    2990
02994:  MOVLB  F
02996:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;   
02998:  BRA    299E
0299A:  MOVLB  0
....................          
....................       default:
....................          break;    
0299C:  MOVLB  F
....................    }
....................    fprintf(USB, "\n"); 
0299E:  MOVLW  0A
029A0:  BTFSS  FA4.4
029A2:  BRA    29A0
029A4:  MOVWF  x1C
029A6:  MOVLB  0
029A8:  RETURN 0
.................... } 
.................... 
.................... 
.................... int readData(a, b, c, d, e, f){
....................    int sendResponse;
....................    //fprintf(USB, "\nTest readeData"); 
....................    
....................    if (a==0x0a && b==0x00 && c==0x20 && d==0x00 && e==0x21){
*
01850:  MOVLB  7
01852:  MOVF   x61,W
01854:  SUBLW  0A
01856:  BNZ   1872
01858:  MOVF   x62,F
0185A:  BNZ   1872
0185C:  MOVF   x63,W
0185E:  SUBLW  20
01860:  BNZ   1872
01862:  MOVF   x64,F
01864:  BNZ   1872
01866:  MOVF   x65,W
01868:  SUBLW  21
0186A:  BNZ   1872
....................       
....................       //fprintf(USB, "\n\nBTD Request to Connect: ");
....................       //getMcuDateTime();
....................       //fprintf(USB, "\nBTD Requesting to Connect");
....................       sendResponse = 1;
0186C:  MOVLW  01
0186E:  MOVWF  x67
....................       break;
....................    }
01870:  BRA    1A1C
....................    
....................    else if (a==0x10 && b==0x00 && c==0x20 && d==0x00 && e==0x01){ 
01872:  MOVF   x61,W
01874:  SUBLW  10
01876:  BNZ   18B8
01878:  MOVF   x62,F
0187A:  BNZ   18B8
0187C:  MOVF   x63,W
0187E:  SUBLW  20
01880:  BNZ   18B8
01882:  MOVF   x64,F
01884:  BNZ   18B8
01886:  DECFSZ x65,W
01888:  BRA    18B8
....................       fprintf(USB, "\n");
0188A:  MOVLW  0A
0188C:  BTFSS  FA4.4
0188E:  BRA    188C
01890:  MOVLB  F
01892:  MOVWF  x1C
....................       strcpy(btdCode, "RMS*");
01894:  MOVLW  04
01896:  MOVWF  FEA
01898:  MOVLW  77
0189A:  MOVWF  FE9
0189C:  MOVLW  00
0189E:  MOVLB  0
018A0:  CALL   0190
018A4:  TBLRD*-
018A6:  TBLRD*+
018A8:  MOVF   FF5,W
018AA:  MOVWF  FEE
018AC:  IORLW  00
018AE:  BNZ   18A6
....................       //fprintf(USB, "\n\nBTD Request Module Status: ");
....................       sendResponse = 2;
018B0:  MOVLW  02
018B2:  MOVLB  7
018B4:  MOVWF  x67
....................       break;
....................    }
018B6:  BRA    1A1C
....................    
....................    else if (a==0x37 && b==0x00 && c==0x20 && d==0x00 && e==0x02){
018B8:  MOVF   x61,W
018BA:  SUBLW  37
018BC:  BNZ   18D8
018BE:  MOVF   x62,F
018C0:  BNZ   18D8
018C2:  MOVF   x63,W
018C4:  SUBLW  20
018C6:  BNZ   18D8
018C8:  MOVF   x64,F
018CA:  BNZ   18D8
018CC:  MOVF   x65,W
018CE:  SUBLW  02
018D0:  BNZ   18D8
....................       
....................       //fprintf(USB, "\n\nBTD System Status Message - Maintenance Mode: ");
....................       sendResponse = 3;
018D2:  MOVLW  03
018D4:  MOVWF  x67
....................       break;
....................    }
018D6:  BRA    1A1C
....................    
....................    else if (a==0x27 && b==0x00 && c==0x20 && d==0x00 && e==0x03){
018D8:  MOVF   x61,W
018DA:  SUBLW  27
018DC:  BNZ   1916
018DE:  MOVF   x62,F
018E0:  BNZ   1916
018E2:  MOVF   x63,W
018E4:  SUBLW  20
018E6:  BNZ   1916
018E8:  MOVF   x64,F
018EA:  BNZ   1916
018EC:  MOVF   x65,W
018EE:  SUBLW  03
018F0:  BNZ   1916
....................       //fprintf(USB, "\n\nBTD No Flash Data Message: ");
....................       strcpy(btdCode, "NFD*");
018F2:  MOVLW  04
018F4:  MOVWF  FEA
018F6:  MOVLW  77
018F8:  MOVWF  FE9
018FA:  MOVLW  00
018FC:  MOVLB  0
018FE:  CALL   01AA
01902:  TBLRD*-
01904:  TBLRD*+
01906:  MOVF   FF5,W
01908:  MOVWF  FEE
0190A:  IORLW  00
0190C:  BNZ   1904
....................       sendResponse = 3;
0190E:  MOVLW  03
01910:  MOVLB  7
01912:  MOVWF  x67
....................       break;
....................    }
01914:  BRA    1A1C
....................    
....................    else if (a==0x10 && b==0x00 && c==0x20 && d==0x00 && e==0x0f){
01916:  MOVF   x61,W
01918:  SUBLW  10
0191A:  BNZ   195E
0191C:  MOVF   x62,F
0191E:  BNZ   195E
01920:  MOVF   x63,W
01922:  SUBLW  20
01924:  BNZ   195E
01926:  MOVF   x64,F
01928:  BNZ   195E
0192A:  MOVF   x65,W
0192C:  SUBLW  0F
0192E:  BNZ   195E
....................       //fprintf(USB, "\n\nBTD Change in Relay Status: ");
....................       fprintf(USB, "\n");
01930:  MOVLW  0A
01932:  BTFSS  FA4.4
01934:  BRA    1932
01936:  MOVLB  F
01938:  MOVWF  x1C
....................       strcpy(btdCode, "CRS*");
0193A:  MOVLW  04
0193C:  MOVWF  FEA
0193E:  MOVLW  77
01940:  MOVWF  FE9
01942:  MOVLW  00
01944:  MOVLB  0
01946:  CALL   01C4
0194A:  TBLRD*-
0194C:  TBLRD*+
0194E:  MOVF   FF5,W
01950:  MOVWF  FEE
01952:  IORLW  00
01954:  BNZ   194C
....................       sendResponse = 3;
01956:  MOVLW  03
01958:  MOVLB  7
0195A:  MOVWF  x67
....................       break;
....................    }
0195C:  BRA    1A1C
.................... 
....................    else if (a==0x57 && b==0x00 && c==0x20 && d==0x00 && e==0x04){
0195E:  MOVF   x61,W
01960:  SUBLW  57
01962:  BNZ   197E
01964:  MOVF   x62,F
01966:  BNZ   197E
01968:  MOVF   x63,W
0196A:  SUBLW  20
0196C:  BNZ   197E
0196E:  MOVF   x64,F
01970:  BNZ   197E
01972:  MOVF   x65,W
01974:  SUBLW  04
01976:  BNZ   197E
....................       //fprintf(USB, "\n\nBTD Flash Data Message: ");
....................       sendResponse = 3;
01978:  MOVLW  03
0197A:  MOVWF  x67
....................       break;
....................    }
0197C:  BRA    1A1C
....................    
....................    else if (a==0x12 && b==0x00 && c==0x20 && d==0x00 && e==0x05){
0197E:  MOVF   x61,W
01980:  SUBLW  12
01982:  BNZ   19C6
01984:  MOVF   x62,F
01986:  BNZ   19C6
01988:  MOVF   x63,W
0198A:  SUBLW  20
0198C:  BNZ   19C6
0198E:  MOVF   x64,F
01990:  BNZ   19C6
01992:  MOVF   x65,W
01994:  SUBLW  05
01996:  BNZ   19C6
....................       //fprintf(USB, "\n\nBTD Change in Warning Status: ");
....................       fprintf(USB, "\n");
01998:  MOVLW  0A
0199A:  BTFSS  FA4.4
0199C:  BRA    199A
0199E:  MOVLB  F
019A0:  MOVWF  x1C
....................       strcpy(btdCode, "CWS*");
019A2:  MOVLW  04
019A4:  MOVWF  FEA
019A6:  MOVLW  77
019A8:  MOVWF  FE9
019AA:  MOVLW  00
019AC:  MOVLB  0
019AE:  CALL   01DE
019B2:  TBLRD*-
019B4:  TBLRD*+
019B6:  MOVF   FF5,W
019B8:  MOVWF  FEE
019BA:  IORLW  00
019BC:  BNZ   19B4
....................       sendResponse = 3;
019BE:  MOVLW  03
019C0:  MOVLB  7
019C2:  MOVWF  x67
....................       break;
....................    }
019C4:  BRA    1A1C
....................    
....................    else if (a==0x3f && b==0x00 && c==0x20 && d==0x00 && e==0x06){
019C6:  MOVF   x61,W
019C8:  SUBLW  3F
019CA:  BNZ   19E2
019CC:  MOVF   x62,F
019CE:  BNZ   19E2
019D0:  MOVF   x63,W
019D2:  SUBLW  20
019D4:  BNZ   19E2
019D6:  MOVF   x64,F
019D8:  BNZ   19E2
019DA:  MOVF   x65,W
019DC:  SUBLW  06
019DE:  BNZ   19E2
....................       //fprintf(USB, "\nBTD Configuration Message: ");
....................       break;
....................    }
019E0:  BRA    1A1C
....................    
....................    else if (a==0x16 && b==0x00 && c==0x20 && d==0x00 && e==0x07){
019E2:  MOVF   x61,W
019E4:  SUBLW  16
019E6:  BNZ   19FE
019E8:  MOVF   x62,F
019EA:  BNZ   19FE
019EC:  MOVF   x63,W
019EE:  SUBLW  20
019F0:  BNZ   19FE
019F2:  MOVF   x64,F
019F4:  BNZ   19FE
019F6:  MOVF   x65,W
019F8:  SUBLW  07
019FA:  BNZ   19FE
....................       //fprintf(USB, "\nBTD Acknowledge Data: ");
....................       break;
....................    }
019FC:  BRA    1A1C
.................... 
....................    else if (a==0x16 && b==0x00 && c==0x20 && d==0x00 && e==0x09){
019FE:  MOVF   x61,W
01A00:  SUBLW  16
01A02:  BNZ   1A1A
01A04:  MOVF   x62,F
01A06:  BNZ   1A1A
01A08:  MOVF   x63,W
01A0A:  SUBLW  20
01A0C:  BNZ   1A1A
01A0E:  MOVF   x64,F
01A10:  BNZ   1A1A
01A12:  MOVF   x65,W
01A14:  SUBLW  09
01A16:  BNZ   1A1A
....................       //fprintf(USB, "\nBTD Date and Time: ");
....................       break;
....................    }
01A18:  BRA    1A1C
.................... 
....................    else{
....................       //fprintf(USB,"\nBTD Invalid Message: ");
....................    sendResponse = 0;
01A1A:  CLRF   x67
....................       break;
....................    }
....................    clear_InterruptGSM();
01A1C:  MOVLB  0
01A1E:  RCALL  153E
....................    strcpy(strBTD_info, btdCode);
01A20:  MOVLW  04
01A22:  MOVWF  FEA
01A24:  MOVLW  63
01A26:  MOVWF  FE9
01A28:  MOVLW  04
01A2A:  MOVWF  FE2
01A2C:  MOVLW  77
01A2E:  MOVWF  FE1
01A30:  MOVF   FE7,F
01A32:  MOVFF  FE6,FEE
01A36:  BNZ   1A30
....................    sprintf(message, "%s%i\r", strBTD_info, f); 
01A38:  MOVLW  04
01A3A:  MOVLB  4
01A3C:  MOVWF  x90
01A3E:  MOVLW  93
01A40:  MOVWF  x8F
01A42:  MOVFF  490,FEA
01A46:  MOVFF  48F,FE9
01A4A:  CLRF   FEF
01A4C:  MOVLW  04
01A4E:  MOVWF  FEA
01A50:  MOVLW  63
01A52:  MOVWF  FE9
01A54:  MOVLB  0
01A56:  RCALL  1322
01A58:  MOVFF  766,7AF
01A5C:  MOVLW  18
01A5E:  MOVLB  7
01A60:  MOVWF  xB0
01A62:  MOVLB  0
01A64:  CALL   0FDE
01A68:  MOVLW  0D
01A6A:  MOVLB  7
01A6C:  MOVWF  xBC
01A6E:  MOVLB  0
01A70:  CALL   0F8C
....................    fprintf(USB, "SMS to Sent: %s", message);
01A74:  MOVLW  88
01A76:  MOVWF  FF6
01A78:  MOVLW  0D
01A7A:  MOVWF  FF7
01A7C:  MOVLW  00
01A7E:  MOVWF  FF8
01A80:  MOVLW  0D
01A82:  MOVLB  7
01A84:  MOVWF  x90
01A86:  MOVLB  0
01A88:  RCALL  157A
01A8A:  MOVLW  04
01A8C:  MOVWF  FEA
01A8E:  MOVLW  93
01A90:  MOVWF  FE9
01A92:  CALL   10B6
....................    strcpy(strBTD_info, "");
01A96:  MOVLW  04
01A98:  MOVWF  FEA
01A9A:  MOVLW  63
01A9C:  MOVWF  FE9
01A9E:  MOVLW  00
01AA0:  CALL   00EE
01AA4:  TBLRD*-
01AA6:  TBLRD*+
01AA8:  MOVF   FF5,W
01AAA:  MOVWF  FEE
01AAC:  IORLW  00
01AAE:  BNZ   1AA6
....................    strcpy(btdCode, "");
01AB0:  MOVLW  04
01AB2:  MOVWF  FEA
01AB4:  MOVLW  77
01AB6:  MOVWF  FE9
01AB8:  MOVLW  00
01ABA:  CALL   00EE
01ABE:  TBLRD*-
01AC0:  TBLRD*+
01AC2:  MOVF   FF5,W
01AC4:  MOVWF  FEE
01AC6:  IORLW  00
01AC8:  BNZ   1AC0
....................    sendToLTE(message);
01ACA:  MOVLW  04
01ACC:  MOVLB  7
01ACE:  MOVWF  x69
01AD0:  MOVLW  93
01AD2:  MOVWF  x68
01AD4:  MOVLB  0
01AD6:  RCALL  17E8
....................    
....................    
....................    
....................    delay_ms(200);
01AD8:  MOVLW  C8
01ADA:  MOVLB  7
01ADC:  MOVWF  x6D
01ADE:  MOVLB  0
01AE0:  CALL   0F16
....................    return sendResponse;
01AE4:  MOVLB  7
01AE6:  MOVFF  767,01
01AEA:  MOVLB  0
01AEC:  GOTO   452E (RETURN)
.................... }
.................... 
.................... void dMonth(m){
....................    //char month;
....................    switch(m){    
....................       case 1: //fprintf(USB, "January");
....................          break;
....................       case 2: //fprintf(USB, "February");
....................          break;
....................       case 3: //fprintf(USB, "March");
....................          break;
....................       case 4: //fprintf(USB, "April");
....................          break;
....................       case 5: //fprintf(USB, "May");
....................          break;
....................       case 6: //fprintf(USB, "June");
....................          break;
....................       case 7: //fprintf(USB, "July");
....................          break;
....................       case 8: //fprintf(USB, "August");
....................          break;
....................       case 9: //fprintf(USB, "September");
....................          break;
....................       case 10: //fprintf(USB, "October");
....................          break;
....................       case 11: //fprintf(USB, "November");
....................          break;
....................       case 12: //fprintf(USB, "December");
....................          break;
....................       default : 
....................          break;
....................    }
.................... }
.................... 
.................... void writeData(w, t){
*
01FE0:  MOVLB  7
01FE2:  CLRF   x64
01FE4:  CLRF   x63
01FE6:  CLRF   x67
....................    int16 crc=0;
....................    uint8_t  bytes[2];
....................    int i = 0;
....................    char msmD [18] = {0xff, 0xff, 0x12, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0x6b};
01FE8:  SETF   x68
01FEA:  SETF   x69
01FEC:  MOVLW  12
01FEE:  MOVWF  x6A
01FF0:  CLRF   x6B
01FF2:  MOVLW  02
01FF4:  MOVWF  x6C
01FF6:  MOVWF  x6D
01FF8:  CLRF   x6E
01FFA:  CLRF   x6F
01FFC:  CLRF   x70
01FFE:  MOVLW  01
02000:  MOVWF  x71
02002:  MOVWF  x72
02004:  CLRF   x73
02006:  CLRF   x74
02008:  CLRF   x75
0200A:  CLRF   x76
0200C:  CLRF   x77
0200E:  MOVLW  AD
02010:  MOVWF  x78
02012:  MOVLW  6B
02014:  MOVWF  x79
....................    char ack [22] = {0xff, 0xff, 0x16, 0x00, 0x02, 0x01, 0x00, 0x06, 0x00, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x5a};
02016:  SETF   x7A
02018:  SETF   x7B
0201A:  MOVLW  16
0201C:  MOVWF  x7C
0201E:  CLRF   x7D
02020:  MOVLW  02
02022:  MOVWF  x7E
02024:  MOVLW  01
02026:  MOVWF  x7F
02028:  CLRF   x80
0202A:  MOVLW  06
0202C:  MOVWF  x81
0202E:  CLRF   x82
02030:  MOVLW  04
02032:  MOVWF  x83
02034:  MOVLW  06
02036:  MOVWF  x84
02038:  MOVLW  01
0203A:  MOVWF  x85
0203C:  CLRF   x86
0203E:  CLRF   x87
02040:  CLRF   x88
02042:  CLRF   x89
02044:  CLRF   x8A
02046:  CLRF   x8B
02048:  CLRF   x8C
0204A:  CLRF   x8D
0204C:  MOVLW  3E
0204E:  MOVWF  x8E
02050:  MOVLW  5A
02052:  MOVWF  x8F
....................          
....................    
....................    switch(w){
02054:  MOVF   x61,W
02056:  XORLW  01
02058:  MOVLB  0
0205A:  BZ    2068
0205C:  XORLW  03
0205E:  BZ    2104
02060:  XORLW  01
02062:  BTFSC  FD8.2
02064:  BRA    222A
02066:  BRA    238C
....................    case 1:
....................       //fprintf(USB, "\narQ Accept Connect Request = %X %X %X %X %X %X %X %X %X %X", 0xff, 0xff, 0x0a, 0x00, 0x02, 0x33, 0x00, 0x00, 0x9f, 0xf7);
....................       fprintf(USB, "\nARQ Accepts Request\n"); 
02068:  MOVLW  98
0206A:  MOVWF  FF6
0206C:  MOVLW  0D
0206E:  MOVWF  FF7
02070:  MOVLW  00
02072:  MOVWF  FF8
02074:  CALL   0F40
....................       fprintf(RS232_BTD200, "%c%c%c%c%c%c%c%c%c%c", 0xff, 0xff, 0x0a, 0x00, 0x02, 0x33, 0x00, 0x00, 0x9f, 0xf7);
02078:  MOVLB  7
0207A:  SETF   x90
0207C:  MOVLB  0
0207E:  RCALL  1AF0
02080:  MOVLB  7
02082:  SETF   x90
02084:  MOVLB  0
02086:  RCALL  1AF0
02088:  MOVLW  0A
0208A:  MOVLB  7
0208C:  MOVWF  x90
0208E:  MOVLB  0
02090:  RCALL  1AF0
02092:  MOVLB  7
02094:  CLRF   x90
02096:  MOVLB  0
02098:  RCALL  1AF0
0209A:  MOVLW  02
0209C:  MOVLB  7
0209E:  MOVWF  x90
020A0:  MOVLB  0
020A2:  RCALL  1AF0
020A4:  MOVLW  33
020A6:  MOVLB  7
020A8:  MOVWF  x90
020AA:  MOVLB  0
020AC:  RCALL  1AF0
020AE:  MOVLB  7
020B0:  CLRF   x90
020B2:  MOVLB  0
020B4:  RCALL  1AF0
020B6:  MOVLB  7
020B8:  CLRF   x90
020BA:  MOVLB  0
020BC:  RCALL  1AF0
020BE:  MOVLW  9F
020C0:  MOVLB  7
020C2:  MOVWF  x90
020C4:  MOVLB  0
020C6:  RCALL  1AF0
020C8:  MOVLW  F7
020CA:  MOVLB  7
020CC:  MOVWF  x90
020CE:  MOVLB  0
020D0:  RCALL  1AF0
....................       //BTDhealth[0] = 100;
....................       fprintf(USB, "Message Number = %i\n", t);
020D2:  MOVLW  AE
020D4:  MOVWF  FF6
020D6:  MOVLW  0D
020D8:  MOVWF  FF7
020DA:  MOVLW  00
020DC:  MOVWF  FF8
020DE:  MOVLW  11
020E0:  MOVLB  7
020E2:  MOVWF  x90
020E4:  MOVLB  0
020E6:  CALL   157A
020EA:  MOVFF  762,790
020EE:  MOVLW  18
020F0:  MOVLB  7
020F2:  MOVWF  x91
020F4:  MOVLB  0
020F6:  RCALL  1B36
020F8:  MOVLW  0A
020FA:  BTFSS  FA4.4
020FC:  BRA    20FA
020FE:  MOVLB  F
02100:  MOVWF  x1C
....................       break;
02102:  BRA    238E
....................       //%d%d%d%d%d%d%d%d%d%d
....................    case 2:
....................       for (i=0;i<18;i++){
02104:  MOVLB  7
02106:  CLRF   x67
02108:  MOVF   x67,W
0210A:  SUBLW  11
0210C:  BNC   2116
....................          msmD[7] = t;
0210E:  MOVFF  762,76F
02112:  INCF   x67,F
02114:  BRA    2108
....................       }
....................       crc=crc_generator(msmD, 16);
02116:  MOVLW  07
02118:  MOVWF  x91
0211A:  MOVLW  68
0211C:  MOVWF  x90
0211E:  CLRF   x93
02120:  MOVLW  10
02122:  MOVWF  x92
02124:  MOVLB  0
02126:  RCALL  1F20
02128:  MOVFF  02,764
0212C:  MOVFF  01,763
....................       bytes[0] = *((uint8_t*)&(crc)+1);
02130:  MOVLW  07
02132:  MOVWF  03
02134:  MOVLW  64
02136:  MOVWF  FE9
02138:  MOVFF  03,FEA
0213C:  MOVFF  FEF,765
....................       bytes[1] = *((uint8_t*)&(crc)+0);
02140:  MOVLW  07
02142:  MOVWF  03
02144:  MOVLW  63
02146:  MOVWF  FE9
02148:  MOVFF  03,FEA
0214C:  MOVFF  FEF,766
....................       //fprintf(USB, "\nARQ Module Status Message: ");
....................       
....................       for (i=0;i<18;i++){ 
02150:  MOVLB  7
02152:  CLRF   x67
02154:  MOVF   x67,W
02156:  SUBLW  11
02158:  BNC   2166
....................          msmD[16] = bytes[1];
0215A:  MOVFF  766,778
....................          msmD[17] = bytes[0];
0215E:  MOVFF  765,779
02162:  INCF   x67,F
02164:  BRA    2154
....................       }
....................       
....................       //for (i=0;i<18;i++){
....................          //fprintf(USB, "%X ", msmD[i]);
....................       //}
....................       fprintf(RS232_BTD200, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c", 0xff, 0xff, 0x12, 0x00, 0x02, 0x02, 0x00,  msmD[7], 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, msmD[16], msmD[17]);
02166:  SETF   x90
02168:  MOVLB  0
0216A:  RCALL  1AF0
0216C:  MOVLB  7
0216E:  SETF   x90
02170:  MOVLB  0
02172:  RCALL  1AF0
02174:  MOVLW  12
02176:  MOVLB  7
02178:  MOVWF  x90
0217A:  MOVLB  0
0217C:  RCALL  1AF0
0217E:  MOVLB  7
02180:  CLRF   x90
02182:  MOVLB  0
02184:  RCALL  1AF0
02186:  MOVLW  02
02188:  MOVLB  7
0218A:  MOVWF  x90
0218C:  MOVLB  0
0218E:  RCALL  1AF0
02190:  MOVLW  02
02192:  MOVLB  7
02194:  MOVWF  x90
02196:  MOVLB  0
02198:  RCALL  1AF0
0219A:  MOVLB  7
0219C:  CLRF   x90
0219E:  MOVLB  0
021A0:  RCALL  1AF0
021A2:  MOVFF  76F,790
021A6:  RCALL  1AF0
021A8:  MOVLB  7
021AA:  CLRF   x90
021AC:  MOVLB  0
021AE:  RCALL  1AF0
021B0:  MOVLW  01
021B2:  MOVLB  7
021B4:  MOVWF  x90
021B6:  MOVLB  0
021B8:  RCALL  1AF0
021BA:  MOVLW  01
021BC:  MOVLB  7
021BE:  MOVWF  x90
021C0:  MOVLB  0
021C2:  RCALL  1AF0
021C4:  MOVLB  7
021C6:  CLRF   x90
021C8:  MOVLB  0
021CA:  RCALL  1AF0
021CC:  MOVLB  7
021CE:  CLRF   x90
021D0:  MOVLB  0
021D2:  RCALL  1AF0
021D4:  MOVLB  7
021D6:  CLRF   x90
021D8:  MOVLB  0
021DA:  RCALL  1AF0
021DC:  MOVLB  7
021DE:  CLRF   x90
021E0:  MOVLB  0
021E2:  RCALL  1AF0
021E4:  MOVLB  7
021E6:  CLRF   x90
021E8:  MOVLB  0
021EA:  RCALL  1AF0
021EC:  MOVFF  778,790
021F0:  RCALL  1AF0
021F2:  MOVFF  779,790
021F6:  RCALL  1AF0
....................       fprintf(USB, "\nMessage Number = %i\n", t);
021F8:  MOVLW  C4
021FA:  MOVWF  FF6
021FC:  MOVLW  0D
021FE:  MOVWF  FF7
02200:  MOVLW  00
02202:  MOVWF  FF8
02204:  MOVLW  12
02206:  MOVLB  7
02208:  MOVWF  x90
0220A:  MOVLB  0
0220C:  CALL   157A
02210:  MOVFF  762,790
02214:  MOVLW  18
02216:  MOVLB  7
02218:  MOVWF  x91
0221A:  MOVLB  0
0221C:  RCALL  1B36
0221E:  MOVLW  0A
02220:  BTFSS  FA4.4
02222:  BRA    2220
02224:  MOVLB  F
02226:  MOVWF  x1C
....................       break;
02228:  BRA    238E
....................    
....................    case 3:
....................       for (i=0;i<22;i++){
0222A:  MOVLB  7
0222C:  CLRF   x67
0222E:  MOVF   x67,W
02230:  SUBLW  15
02232:  BNC   223C
....................          ack[7] = t;
02234:  MOVFF  762,781
02238:  INCF   x67,F
0223A:  BRA    222E
....................       }  
....................       crc=crc_generator(ack, 20);
0223C:  MOVLW  07
0223E:  MOVWF  x91
02240:  MOVLW  7A
02242:  MOVWF  x90
02244:  CLRF   x93
02246:  MOVLW  14
02248:  MOVWF  x92
0224A:  MOVLB  0
0224C:  RCALL  1F20
0224E:  MOVFF  02,764
02252:  MOVFF  01,763
....................       bytes[0] = *((uint8_t*)&(crc)+1);
02256:  MOVLW  07
02258:  MOVWF  03
0225A:  MOVLW  64
0225C:  MOVWF  FE9
0225E:  MOVFF  03,FEA
02262:  MOVFF  FEF,765
....................       bytes[1] = *((uint8_t*)&(crc)+0);
02266:  MOVLW  07
02268:  MOVWF  03
0226A:  MOVLW  63
0226C:  MOVWF  FE9
0226E:  MOVFF  03,FEA
02272:  MOVFF  FEF,766
....................       //fprintf(USB, "\nARQ Acknowledge Data: "); 
....................       
....................       for (i=0;i<22;i++){
02276:  MOVLB  7
02278:  CLRF   x67
0227A:  MOVF   x67,W
0227C:  SUBLW  15
0227E:  BNC   228C
....................          ack[20] = bytes[1];
02280:  MOVFF  766,78E
....................          ack[21] = bytes[0];
02284:  MOVFF  765,78F
02288:  INCF   x67,F
0228A:  BRA    227A
....................       }
....................      
....................       //for (i=0;i<22;i++){
....................          //fprintf(USB, "%X ", ack[i]);
....................       //}
....................       
....................       fprintf(RS232_BTD200, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c", 0xff, 0xff, 0x16, 0x00, 0x02, 0x01, 0x00, ack[7], 0x00, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ack[20], ack[21]);
0228C:  SETF   x90
0228E:  MOVLB  0
02290:  RCALL  1AF0
02292:  MOVLB  7
02294:  SETF   x90
02296:  MOVLB  0
02298:  RCALL  1AF0
0229A:  MOVLW  16
0229C:  MOVLB  7
0229E:  MOVWF  x90
022A0:  MOVLB  0
022A2:  RCALL  1AF0
022A4:  MOVLB  7
022A6:  CLRF   x90
022A8:  MOVLB  0
022AA:  RCALL  1AF0
022AC:  MOVLW  02
022AE:  MOVLB  7
022B0:  MOVWF  x90
022B2:  MOVLB  0
022B4:  RCALL  1AF0
022B6:  MOVLW  01
022B8:  MOVLB  7
022BA:  MOVWF  x90
022BC:  MOVLB  0
022BE:  RCALL  1AF0
022C0:  MOVLB  7
022C2:  CLRF   x90
022C4:  MOVLB  0
022C6:  RCALL  1AF0
022C8:  MOVFF  781,790
022CC:  RCALL  1AF0
022CE:  MOVLB  7
022D0:  CLRF   x90
022D2:  MOVLB  0
022D4:  RCALL  1AF0
022D6:  MOVLW  04
022D8:  MOVLB  7
022DA:  MOVWF  x90
022DC:  MOVLB  0
022DE:  RCALL  1AF0
022E0:  MOVLW  06
022E2:  MOVLB  7
022E4:  MOVWF  x90
022E6:  MOVLB  0
022E8:  RCALL  1AF0
022EA:  MOVLW  01
022EC:  MOVLB  7
022EE:  MOVWF  x90
022F0:  MOVLB  0
022F2:  CALL   1AF0
022F6:  MOVLB  7
022F8:  CLRF   x90
022FA:  MOVLB  0
022FC:  CALL   1AF0
02300:  MOVLB  7
02302:  CLRF   x90
02304:  MOVLB  0
02306:  CALL   1AF0
0230A:  MOVLB  7
0230C:  CLRF   x90
0230E:  MOVLB  0
02310:  CALL   1AF0
02314:  MOVLB  7
02316:  CLRF   x90
02318:  MOVLB  0
0231A:  CALL   1AF0
0231E:  MOVLB  7
02320:  CLRF   x90
02322:  MOVLB  0
02324:  CALL   1AF0
02328:  MOVLB  7
0232A:  CLRF   x90
0232C:  MOVLB  0
0232E:  CALL   1AF0
02332:  MOVLB  7
02334:  CLRF   x90
02336:  MOVLB  0
02338:  CALL   1AF0
0233C:  MOVLB  7
0233E:  CLRF   x90
02340:  MOVLB  0
02342:  CALL   1AF0
02346:  MOVFF  78E,790
0234A:  CALL   1AF0
0234E:  MOVFF  78F,790
02352:  CALL   1AF0
....................       fprintf(USB, "\nMessage Number = %i\n", t);
02356:  MOVLW  DA
02358:  MOVWF  FF6
0235A:  MOVLW  0D
0235C:  MOVWF  FF7
0235E:  MOVLW  00
02360:  MOVWF  FF8
02362:  MOVLW  12
02364:  MOVLB  7
02366:  MOVWF  x90
02368:  MOVLB  0
0236A:  CALL   157A
0236E:  MOVFF  762,790
02372:  MOVLW  18
02374:  MOVLB  7
02376:  MOVWF  x91
02378:  MOVLB  0
0237A:  CALL   1B36
0237E:  MOVLW  0A
02380:  BTFSS  FA4.4
02382:  BRA    2380
02384:  MOVLB  F
02386:  MOVWF  x1C
....................       break;
02388:  BRA    238E
0238A:  MOVLB  0
....................    
....................    default:
....................       //fprintf(USB,"\nARQ No Valid Response.");
....................       break;  
0238C:  MOVLB  F
....................    }
0238E:  MOVLB  0
02390:  GOTO   453E (RETURN)
.................... }
.................... 
.................... void polarConverter(){
....................    float x, y;
....................    const float piVal = 3.141592; 
....................    char LatLong[30]={};
*
03C90:  MOVLB  7
03C92:  CLRF   x69
03C94:  CLRF   x6A
03C96:  CLRF   x6B
03C98:  CLRF   x6C
03C9A:  CLRF   x6D
03C9C:  CLRF   x6E
03C9E:  CLRF   x6F
03CA0:  CLRF   x70
03CA2:  CLRF   x71
03CA4:  CLRF   x72
03CA6:  CLRF   x73
03CA8:  CLRF   x74
03CAA:  CLRF   x75
03CAC:  CLRF   x76
03CAE:  CLRF   x77
03CB0:  CLRF   x78
03CB2:  CLRF   x79
03CB4:  CLRF   x7A
03CB6:  CLRF   x7B
03CB8:  CLRF   x7C
03CBA:  CLRF   x7D
03CBC:  CLRF   x7E
03CBE:  CLRF   x7F
03CC0:  CLRF   x80
03CC2:  CLRF   x81
03CC4:  CLRF   x82
03CC6:  CLRF   x83
03CC8:  CLRF   x84
03CCA:  CLRF   x85
03CCC:  CLRF   x86
....................    char septr[3], *ptr;
....................    
....................    int16 num;
....................    int  rt[10]={}; 
03CCE:  CLRF   x8E
03CD0:  CLRF   x8F
03CD2:  CLRF   x90
03CD4:  CLRF   x91
03CD6:  CLRF   x92
03CD8:  CLRF   x93
03CDA:  CLRF   x94
03CDC:  CLRF   x95
03CDE:  CLRF   x96
03CE0:  CLRF   x97
....................    int i;
....................    float r;
....................    //int16 dirVal;
....................    long int dirVal;
....................    //unsigned int t;
....................    
....................    // fprintf(USB,"\nTest Data: %s", distDir);  
....................    strcpy(septr,".+");
03CE2:  MOVLW  07
03CE4:  MOVWF  FEA
03CE6:  MOVLW  87
03CE8:  MOVWF  FE9
03CEA:  MOVLW  00
03CEC:  MOVLB  0
03CEE:  CALL   01F8
03CF2:  TBLRD*-
03CF4:  TBLRD*+
03CF6:  MOVF   FF5,W
03CF8:  MOVWF  FEE
03CFA:  IORLW  00
03CFC:  BNZ   3CF4
....................    ptr = strtok(distDir, septr);
03CFE:  MOVLW  04
03D00:  MOVLB  7
03D02:  MOVWF  xA8
03D04:  MOVLW  45
03D06:  MOVWF  xA7
03D08:  MOVLW  07
03D0A:  MOVWF  xAA
03D0C:  MOVLW  87
03D0E:  MOVWF  xA9
03D10:  MOVLB  0
03D12:  CALL   2F58
03D16:  MOVFF  02,78B
03D1A:  MOVFF  01,78A
....................    while(ptr!=0){
03D1E:  MOVLB  7
03D20:  MOVF   x8A,F
03D22:  BNZ   3D28
03D24:  MOVF   x8B,F
03D26:  BZ    3D92
....................       for (i=0;i<4;i++){   
03D28:  CLRF   x98
03D2A:  MOVF   x98,W
03D2C:  SUBLW  03
03D2E:  BNC   3D90
....................          //unsigned long num = (unsigned long)strtol(ptr, NULL, 10);
....................          num = (int16)strtol(ptr, NULL, 10);
03D30:  MOVFF  78B,7A8
03D34:  MOVFF  78A,7A7
03D38:  CLRF   xAA
03D3A:  CLRF   xA9
03D3C:  MOVLW  0A
03D3E:  MOVWF  xAB
03D40:  MOVLB  0
03D42:  GOTO   30AE
03D46:  MOVFF  02,78D
03D4A:  MOVFF  01,78C
....................          //fprintf(USB, "%s ----- ", ptr);
....................          rt[i] = num;  
03D4E:  CLRF   03
03D50:  MOVLB  7
03D52:  MOVF   x98,W
03D54:  ADDLW  8E
03D56:  MOVWF  FE9
03D58:  MOVLW  07
03D5A:  ADDWFC 03,W
03D5C:  MOVWF  FEA
03D5E:  MOVFF  78C,FEF
....................          //fprintf(USB, "\nVal: %lu", num);  
....................          if (i==2){
03D62:  MOVF   x98,W
03D64:  SUBLW  02
03D66:  BNZ   3D70
....................          dirVal = num;}
03D68:  MOVFF  78D,79E
03D6C:  MOVFF  78C,79D
....................          ptr = strtok(0, septr);  
03D70:  CLRF   xA8
03D72:  CLRF   xA7
03D74:  MOVLW  07
03D76:  MOVWF  xAA
03D78:  MOVLW  87
03D7A:  MOVWF  xA9
03D7C:  MOVLB  0
03D7E:  CALL   2F58
03D82:  MOVFF  02,78B
03D86:  MOVFF  01,78A
03D8A:  MOVLB  7
03D8C:  INCF   x98,F
03D8E:  BRA    3D2A
....................       }
03D90:  BRA    3D20
....................    } 
....................    //r = rt[0] + (0.01*rt[1]) + 0.05;
....................    r = rt[0] + (0.01*rt[1]);
03D92:  CLRF   xE2
03D94:  MOVFF  78F,7E1
03D98:  MOVLB  0
03D9A:  CALL   29AA
03D9E:  MOVLW  0A
03DA0:  MOVLB  7
03DA2:  MOVWF  xE4
03DA4:  MOVLW  D7
03DA6:  MOVWF  xE3
03DA8:  MOVLW  23
03DAA:  MOVWF  xE2
03DAC:  MOVLW  78
03DAE:  MOVWF  xE1
03DB0:  MOVFF  03,7E8
03DB4:  MOVFF  02,7E7
03DB8:  MOVFF  01,7E6
03DBC:  MOVFF  00,7E5
03DC0:  MOVLB  0
03DC2:  CALL   29E0
03DC6:  MOVFF  03,7AA
03DCA:  MOVFF  02,7A9
03DCE:  MOVFF  01,7A8
03DD2:  MOVFF  00,7A7
03DD6:  MOVLB  7
03DD8:  CLRF   xE2
03DDA:  MOVFF  78E,7E1
03DDE:  MOVLB  0
03DE0:  CALL   29AA
03DE4:  BCF    FD8.1
03DE6:  MOVFF  03,7E4
03DEA:  MOVFF  02,7E3
03DEE:  MOVFF  01,7E2
03DF2:  MOVFF  00,7E1
03DF6:  MOVFF  7AA,7E8
03DFA:  MOVFF  7A9,7E7
03DFE:  MOVFF  7A8,7E6
03E02:  MOVFF  7A7,7E5
03E06:  CALL   3404
03E0A:  MOVFF  03,79C
03E0E:  MOVFF  02,79B
03E12:  MOVFF  01,79A
03E16:  MOVFF  00,799
....................    //ASTI Latlong
....................    float latA = 14.647; //14.646990
....................    float lonA = 121.072; //121.072072
03E1A:  MOVLW  1D
03E1C:  MOVLB  7
03E1E:  MOVWF  xA2
03E20:  MOVLW  5A
03E22:  MOVWF  xA1
03E24:  MOVLW  6A
03E26:  MOVWF  xA0
03E28:  MOVLW  82
03E2A:  MOVWF  x9F
03E2C:  MOVLW  DD
03E2E:  MOVWF  xA6
03E30:  MOVLW  24
03E32:  MOVWF  xA5
03E34:  MOVLW  72
03E36:  MOVWF  xA4
03E38:  MOVLW  85
03E3A:  MOVWF  xA3
....................    //fprintf(USB,"\nDirection Value: %li", dirVal); 
....................    
....................    x = (r*cos(dirVal*(piVal / 180.0)))/111.111;
03E3C:  MOVFF  79E,7E2
03E40:  MOVFF  79D,7E1
03E44:  MOVLB  0
03E46:  CALL   29AA
03E4A:  MOVFF  03,7E4
03E4E:  MOVFF  02,7E3
03E52:  MOVFF  01,7E2
03E56:  MOVFF  00,7E1
03E5A:  MOVLW  33
03E5C:  MOVLB  7
03E5E:  MOVWF  xE8
03E60:  MOVLW  FA
03E62:  MOVWF  xE7
03E64:  MOVLW  0E
03E66:  MOVWF  xE6
03E68:  MOVLW  79
03E6A:  MOVWF  xE5
03E6C:  MOVLB  0
03E6E:  CALL   29E0
03E72:  MOVFF  03,7AA
03E76:  MOVFF  02,7A9
03E7A:  MOVFF  01,7A8
03E7E:  MOVFF  00,7A7
03E82:  MOVFF  03,7B6
03E86:  MOVFF  02,7B5
03E8A:  MOVFF  01,7B4
03E8E:  MOVFF  00,7B3
03E92:  RCALL  3734
03E94:  MOVFF  79C,7E4
03E98:  MOVFF  79B,7E3
03E9C:  MOVFF  79A,7E2
03EA0:  MOVFF  799,7E1
03EA4:  MOVFF  03,7E8
03EA8:  MOVFF  02,7E7
03EAC:  MOVFF  01,7E6
03EB0:  MOVFF  00,7E5
03EB4:  CALL   29E0
03EB8:  MOVFF  03,7AA
03EBC:  MOVFF  02,7A9
03EC0:  MOVFF  01,7A8
03EC4:  MOVFF  00,7A7
03EC8:  MOVFF  03,7AE
03ECC:  MOVFF  02,7AD
03ED0:  MOVFF  01,7AC
03ED4:  MOVFF  00,7AB
03ED8:  MOVLW  D5
03EDA:  MOVLB  7
03EDC:  MOVWF  xB2
03EDE:  MOVLW  38
03EE0:  MOVWF  xB1
03EE2:  MOVLW  5E
03EE4:  MOVWF  xB0
03EE6:  MOVLW  85
03EE8:  MOVWF  xAF
03EEA:  MOVLB  0
03EEC:  RCALL  3AB8
03EEE:  MOVFF  03,764
03EF2:  MOVFF  02,763
03EF6:  MOVFF  01,762
03EFA:  MOVFF  00,761
....................    y = (r*sin(dirVal*(piVal / 180.0)))/107.721;  
03EFE:  MOVFF  79E,7E2
03F02:  MOVFF  79D,7E1
03F06:  CALL   29AA
03F0A:  MOVFF  03,7E4
03F0E:  MOVFF  02,7E3
03F12:  MOVFF  01,7E2
03F16:  MOVFF  00,7E1
03F1A:  MOVLW  33
03F1C:  MOVLB  7
03F1E:  MOVWF  xE8
03F20:  MOVLW  FA
03F22:  MOVWF  xE7
03F24:  MOVLW  0E
03F26:  MOVWF  xE6
03F28:  MOVLW  79
03F2A:  MOVWF  xE5
03F2C:  MOVLB  0
03F2E:  CALL   29E0
03F32:  MOVFF  03,7AA
03F36:  MOVFF  02,7A9
03F3A:  MOVFF  01,7A8
03F3E:  MOVFF  00,7A7
03F42:  MOVFF  03,7AE
03F46:  MOVFF  02,7AD
03F4A:  MOVFF  01,7AC
03F4E:  MOVFF  00,7AB
03F52:  BRA    3C16
03F54:  MOVFF  79C,7E4
03F58:  MOVFF  79B,7E3
03F5C:  MOVFF  79A,7E2
03F60:  MOVFF  799,7E1
03F64:  MOVFF  03,7E8
03F68:  MOVFF  02,7E7
03F6C:  MOVFF  01,7E6
03F70:  MOVFF  00,7E5
03F74:  CALL   29E0
03F78:  MOVFF  03,7AA
03F7C:  MOVFF  02,7A9
03F80:  MOVFF  01,7A8
03F84:  MOVFF  00,7A7
03F88:  MOVFF  03,7AE
03F8C:  MOVFF  02,7AD
03F90:  MOVFF  01,7AC
03F94:  MOVFF  00,7AB
03F98:  MOVLW  27
03F9A:  MOVLB  7
03F9C:  MOVWF  xB2
03F9E:  MOVLW  71
03FA0:  MOVWF  xB1
03FA2:  MOVLW  57
03FA4:  MOVWF  xB0
03FA6:  MOVLW  85
03FA8:  MOVWF  xAF
03FAA:  MOVLB  0
03FAC:  RCALL  3AB8
03FAE:  MOVFF  03,768
03FB2:  MOVFF  02,767
03FB6:  MOVFF  01,766
03FBA:  MOVFF  00,765
.................... 
....................    if (r > 0){
03FBE:  MOVLB  7
03FC0:  CLRF   xE0
03FC2:  CLRF   xDF
03FC4:  CLRF   xDE
03FC6:  CLRF   xDD
03FC8:  MOVFF  79C,7E4
03FCC:  MOVFF  79B,7E3
03FD0:  MOVFF  79A,7E2
03FD4:  MOVFF  799,7E1
03FD8:  MOVLB  0
03FDA:  CALL   367C
03FDE:  BTFSS  FD8.0
03FE0:  BRA    4126
....................       //sprintf(LatLong, "LT%i:%0.6f+LN%i:%0.6f+", rt[3], x+latA, rt[3], y+lonA);
....................       sprintf(LatLong, "LT%i:%0.3f+LN%i:%0.3f+", rt[3], x+latA, rt[3], y+lonA);
03FE2:  BCF    FD8.1
03FE4:  MOVFF  764,7E4
03FE8:  MOVFF  763,7E3
03FEC:  MOVFF  762,7E2
03FF0:  MOVFF  761,7E1
03FF4:  MOVFF  7A2,7E8
03FF8:  MOVFF  7A1,7E7
03FFC:  MOVFF  7A0,7E6
04000:  MOVFF  79F,7E5
04004:  CALL   3404
04008:  MOVFF  03,7AA
0400C:  MOVFF  02,7A9
04010:  MOVFF  01,7A8
04014:  MOVFF  00,7A7
04018:  BCF    FD8.1
0401A:  MOVFF  768,7E4
0401E:  MOVFF  767,7E3
04022:  MOVFF  766,7E2
04026:  MOVFF  765,7E1
0402A:  MOVFF  7A6,7E8
0402E:  MOVFF  7A5,7E7
04032:  MOVFF  7A4,7E6
04036:  MOVFF  7A3,7E5
0403A:  CALL   3404
0403E:  MOVFF  03,7AE
04042:  MOVFF  02,7AD
04046:  MOVFF  01,7AC
0404A:  MOVFF  00,7AB
0404E:  MOVLW  07
04050:  MOVLB  4
04052:  MOVWF  x90
04054:  MOVLW  69
04056:  MOVWF  x8F
04058:  MOVLW  4C
0405A:  MOVLB  7
0405C:  MOVWF  xBC
0405E:  MOVLB  0
04060:  CALL   0F8C
04064:  MOVLW  54
04066:  MOVLB  7
04068:  MOVWF  xBC
0406A:  MOVLB  0
0406C:  CALL   0F8C
04070:  MOVFF  791,7AF
04074:  MOVLW  18
04076:  MOVLB  7
04078:  MOVWF  xB0
0407A:  MOVLB  0
0407C:  CALL   0FDE
04080:  MOVLW  3A
04082:  MOVLB  7
04084:  MOVWF  xBC
04086:  MOVLB  0
04088:  CALL   0F8C
0408C:  MOVLW  C9
0408E:  MOVWF  FE9
04090:  MOVFF  7AA,7B2
04094:  MOVFF  7A9,7B1
04098:  MOVFF  7A8,7B0
0409C:  MOVFF  7A7,7AF
040A0:  MOVLW  03
040A2:  MOVLB  7
040A4:  MOVWF  xB3
040A6:  MOVLB  0
040A8:  CALL   2BAE
040AC:  MOVLW  FA
040AE:  MOVWF  FF6
040B0:  MOVLW  0D
040B2:  MOVWF  FF7
040B4:  MOVLW  00
040B6:  MOVWF  FF8
040B8:  MOVLW  03
040BA:  MOVLB  7
040BC:  MOVWF  xAF
040BE:  MOVLB  0
040C0:  CALL   0FAE
040C4:  MOVFF  791,7AF
040C8:  MOVLW  18
040CA:  MOVLB  7
040CC:  MOVWF  xB0
040CE:  MOVLB  0
040D0:  CALL   0FDE
040D4:  MOVLW  3A
040D6:  MOVLB  7
040D8:  MOVWF  xBC
040DA:  MOVLB  0
040DC:  CALL   0F8C
040E0:  MOVLW  C9
040E2:  MOVWF  FE9
040E4:  MOVFF  7AE,7B2
040E8:  MOVFF  7AD,7B1
040EC:  MOVFF  7AC,7B0
040F0:  MOVFF  7AB,7AF
040F4:  MOVLW  03
040F6:  MOVLB  7
040F8:  MOVWF  xB3
040FA:  MOVLB  0
040FC:  CALL   2BAE
04100:  MOVLW  2B
04102:  MOVLB  7
04104:  MOVWF  xBC
04106:  MOVLB  0
04108:  CALL   0F8C
....................       //strcat(strLaLo, LatLong);
....................       strcat(BTDLaLo, LatLong);
0410C:  MOVLW  03
0410E:  MOVLB  7
04110:  MOVWF  xA8
04112:  MOVLW  AF
04114:  MOVWF  xA7
04116:  MOVLW  07
04118:  MOVWF  xAA
0411A:  MOVLW  69
0411C:  MOVWF  xA9
0411E:  MOVLB  0
04120:  CALL   112C
....................       //strcpy(LatLong, "");
....................    }
04124:  BRA    41D8
....................    
....................    else{
....................    sprintf(LatLong, "LT%i:%s+LN%i:%s+", rt[3], "00.000", rt[3],  "000.000");
04126:  MOVLW  07
04128:  MOVLB  4
0412A:  MOVWF  x90
0412C:  MOVLW  69
0412E:  MOVWF  x8F
04130:  MOVLW  4C
04132:  MOVLB  7
04134:  MOVWF  xBC
04136:  MOVLB  0
04138:  CALL   0F8C
0413C:  MOVLW  54
0413E:  MOVLB  7
04140:  MOVWF  xBC
04142:  MOVLB  0
04144:  CALL   0F8C
04148:  MOVFF  791,7AF
0414C:  MOVLW  18
0414E:  MOVLB  7
04150:  MOVWF  xB0
04152:  MOVLB  0
04154:  CALL   0FDE
04158:  MOVLW  3A
0415A:  MOVLB  7
0415C:  MOVWF  xBC
0415E:  MOVLB  0
04160:  CALL   0F8C
04164:  MOVLW  1A
04166:  MOVWF  FF6
04168:  MOVLW  0E
0416A:  MOVWF  FF7
0416C:  MOVLW  00
0416E:  MOVWF  FF8
04170:  RCALL  3C66
04172:  MOVLW  0F
04174:  MOVWF  FF6
04176:  MOVLW  0E
04178:  MOVWF  FF7
0417A:  MOVLW  00
0417C:  MOVWF  FF8
0417E:  MOVLW  03
04180:  MOVLB  7
04182:  MOVWF  xAF
04184:  MOVLB  0
04186:  CALL   0FAE
0418A:  MOVFF  791,7AF
0418E:  MOVLW  18
04190:  MOVLB  7
04192:  MOVWF  xB0
04194:  MOVLB  0
04196:  CALL   0FDE
0419A:  MOVLW  3A
0419C:  MOVLB  7
0419E:  MOVWF  xBC
041A0:  MOVLB  0
041A2:  CALL   0F8C
041A6:  MOVLW  22
041A8:  MOVWF  FF6
041AA:  MOVLW  0E
041AC:  MOVWF  FF7
041AE:  MOVLW  00
041B0:  MOVWF  FF8
041B2:  RCALL  3C66
041B4:  MOVLW  2B
041B6:  MOVLB  7
041B8:  MOVWF  xBC
041BA:  MOVLB  0
041BC:  CALL   0F8C
....................    //sprintf(LatLong, "LT%i:%s+LN%i:%s+", rt[3], "00.000000", rt[3],  "000.000000");
....................    //strcat(strLaLo, LatLong);
....................    strcat(BTDLaLo, LatLong);
041C0:  MOVLW  03
041C2:  MOVLB  7
041C4:  MOVWF  xA8
041C6:  MOVLW  AF
041C8:  MOVWF  xA7
041CA:  MOVLW  07
041CC:  MOVWF  xAA
041CE:  MOVLW  69
041D0:  MOVWF  xA9
041D2:  MOVLB  0
041D4:  CALL   112C
....................    //strcat(BTDLaLo, LatLong);
....................    //strcpy(LatLong, "");
....................    }
....................    //fprintf(USB, "\nConverted Polar: %s", LatLong);
....................    //fprintf(USB, "\nAcquired: %s", BTDLaLo);
....................    strcpy(LatLong, "");
041D8:  MOVLW  07
041DA:  MOVWF  FEA
041DC:  MOVLW  69
041DE:  MOVWF  FE9
041E0:  MOVLW  00
041E2:  CALL   00EE
041E6:  TBLRD*-
041E8:  TBLRD*+
041EA:  MOVF   FF5,W
041EC:  MOVWF  FEE
041EE:  IORLW  00
041F0:  BNZ   41E8
041F2:  GOTO   48CE (RETURN)
....................    //return 0;  
.................... }  
.................... 
.................... //Reading BTD-200
.................... void readSerial(){
*
043A2:  CLRF   x04
043A4:  CLRF   x03
043A6:  MOVLW  01
043A8:  MOVWF  x0F
....................   // fprintf(USB, "\nInitializing BTD200 ");
....................    char cx[100] = {}; //0xed, 0x08, 0x2d,
*
042D6:  MOVLB  6
042D8:  CLRF   x9E
042DA:  CLRF   x9F
042DC:  CLRF   xA0
042DE:  CLRF   xA1
042E0:  CLRF   xA2
042E2:  CLRF   xA3
042E4:  CLRF   xA4
042E6:  CLRF   xA5
042E8:  CLRF   xA6
042EA:  CLRF   xA7
042EC:  CLRF   xA8
042EE:  CLRF   xA9
042F0:  CLRF   xAA
042F2:  CLRF   xAB
042F4:  CLRF   xAC
042F6:  CLRF   xAD
042F8:  CLRF   xAE
042FA:  CLRF   xAF
042FC:  CLRF   xB0
042FE:  CLRF   xB1
04300:  CLRF   xB2
04302:  CLRF   xB3
04304:  CLRF   xB4
04306:  CLRF   xB5
04308:  CLRF   xB6
0430A:  CLRF   xB7
0430C:  CLRF   xB8
0430E:  CLRF   xB9
04310:  CLRF   xBA
04312:  CLRF   xBB
04314:  CLRF   xBC
04316:  CLRF   xBD
04318:  CLRF   xBE
0431A:  CLRF   xBF
0431C:  CLRF   xC0
0431E:  CLRF   xC1
04320:  CLRF   xC2
04322:  CLRF   xC3
04324:  CLRF   xC4
04326:  CLRF   xC5
04328:  CLRF   xC6
0432A:  CLRF   xC7
0432C:  CLRF   xC8
0432E:  CLRF   xC9
04330:  CLRF   xCA
04332:  CLRF   xCB
04334:  CLRF   xCC
04336:  CLRF   xCD
04338:  CLRF   xCE
0433A:  CLRF   xCF
0433C:  CLRF   xD0
0433E:  CLRF   xD1
04340:  CLRF   xD2
04342:  CLRF   xD3
04344:  CLRF   xD4
04346:  CLRF   xD5
04348:  CLRF   xD6
0434A:  CLRF   xD7
0434C:  CLRF   xD8
0434E:  CLRF   xD9
04350:  CLRF   xDA
04352:  CLRF   xDB
04354:  CLRF   xDC
04356:  CLRF   xDD
04358:  CLRF   xDE
0435A:  CLRF   xDF
0435C:  CLRF   xE0
0435E:  CLRF   xE1
04360:  CLRF   xE2
04362:  CLRF   xE3
04364:  CLRF   xE4
04366:  CLRF   xE5
04368:  CLRF   xE6
0436A:  CLRF   xE7
0436C:  CLRF   xE8
0436E:  CLRF   xE9
04370:  CLRF   xEA
04372:  CLRF   xEB
04374:  CLRF   xEC
04376:  CLRF   xED
04378:  CLRF   xEE
0437A:  CLRF   xEF
0437C:  CLRF   xF0
0437E:  CLRF   xF1
04380:  CLRF   xF2
04382:  CLRF   xF3
04384:  CLRF   xF4
04386:  CLRF   xF5
04388:  CLRF   xF6
0438A:  CLRF   xF7
0438C:  CLRF   xF8
0438E:  CLRF   xF9
04390:  CLRF   xFA
04392:  CLRF   xFB
04394:  CLRF   xFC
04396:  CLRF   xFD
04398:  CLRF   xFE
0439A:  CLRF   xFF
0439C:  MOVLB  7
0439E:  CLRF   x00
043A0:  CLRF   x01
....................    int i;
....................    //int j;
....................    long timeOut=0;
....................    int byteCount;
....................    int response;
.................... 
....................    //Flash Data variables
....................    //int dIndex;
....................    float distance;
....................    int16 dir;
....................    int m;
....................    int p;
....................   
....................    int inF = 1;
....................    int index;
....................    
....................    //char fc[100] = {};
....................    char dsdr[50] = {};
*
043AA:  CLRF   x11
043AC:  CLRF   x12
043AE:  CLRF   x13
043B0:  CLRF   x14
043B2:  CLRF   x15
043B4:  CLRF   x16
043B6:  CLRF   x17
043B8:  CLRF   x18
043BA:  CLRF   x19
043BC:  CLRF   x1A
043BE:  CLRF   x1B
043C0:  CLRF   x1C
043C2:  CLRF   x1D
043C4:  CLRF   x1E
043C6:  CLRF   x1F
043C8:  CLRF   x20
043CA:  CLRF   x21
043CC:  CLRF   x22
043CE:  CLRF   x23
043D0:  CLRF   x24
043D2:  CLRF   x25
043D4:  CLRF   x26
043D6:  CLRF   x27
043D8:  CLRF   x28
043DA:  CLRF   x29
043DC:  CLRF   x2A
043DE:  CLRF   x2B
043E0:  CLRF   x2C
043E2:  CLRF   x2D
043E4:  CLRF   x2E
043E6:  CLRF   x2F
043E8:  CLRF   x30
043EA:  CLRF   x31
043EC:  CLRF   x32
043EE:  CLRF   x33
043F0:  CLRF   x34
043F2:  CLRF   x35
043F4:  CLRF   x36
043F6:  CLRF   x37
043F8:  CLRF   x38
043FA:  CLRF   x39
043FC:  CLRF   x3A
043FE:  CLRF   x3B
04400:  CLRF   x3C
04402:  CLRF   x3D
04404:  CLRF   x3E
04406:  CLRF   x3F
04408:  CLRF   x40
0440A:  CLRF   x41
0440C:  CLRF   x42
....................    char dt[20]  = {};
0440E:  CLRF   x43
04410:  CLRF   x44
04412:  CLRF   x45
04414:  CLRF   x46
04416:  CLRF   x47
04418:  CLRF   x48
0441A:  CLRF   x49
0441C:  CLRF   x4A
0441E:  CLRF   x4B
04420:  CLRF   x4C
04422:  CLRF   x4D
04424:  CLRF   x4E
04426:  CLRF   x4F
04428:  CLRF   x50
0442A:  CLRF   x51
0442C:  CLRF   x52
0442E:  CLRF   x53
04430:  CLRF   x54
04432:  CLRF   x55
04434:  CLRF   x56
....................    char fcount[2] = {};   
04436:  CLRF   x57
04438:  CLRF   x58
....................    
....................    int16 dist[2];
....................    int16 dirc[2];
....................    
....................    while(kbhit(RS232_BTD200)&&++timeOut<50000){
0443A:  BTFSC  F86.3
0443C:  BRA    445C
0443E:  INCF   x03,F
04440:  BTFSC  FD8.2
04442:  INCF   x04,F
04444:  MOVF   x04,W
04446:  SUBLW  C3
04448:  BNC   445C
0444A:  BNZ   4452
0444C:  MOVF   x03,W
0444E:  SUBLW  4F
04450:  BNC   445C
....................      // fprintf(USB,"\nNo Data!\n");
....................       delay_us(10);
04452:  MOVLW  0D
04454:  MOVWF  00
04456:  DECFSZ 00,F
04458:  BRA    4456
0445A:  BRA    443A
....................    }
....................      
....................    if (!kbhit(RS232_BTD200)){
0445C:  BTFSS  F86.3
0445E:  BRA    45CE
....................       //fprintf(USB, "\nTest kbhit");
....................       //fprintf(USB, RS232_BTD200);
....................       //setup_wdt(WDT_OFF);
....................        
....................       //Catching header to byte count
....................       for (i=0;i<3;i++){
04460:  CLRF   x02
04462:  MOVF   x02,W
04464:  SUBLW  02
04466:  BNC   4496
....................       //fprintf(USB, RS232_BTD200);
....................       cx[i] = fgetc(RS232_BTD200);        
04468:  CLRF   03
0446A:  MOVF   x02,W
0446C:  ADDLW  9E
0446E:  MOVWF  FE9
04470:  MOVLW  06
04472:  ADDWFC 03,W
04474:  MOVWF  FEA
04476:  MOVFF  FEA,764
0447A:  MOVFF  FE9,763
0447E:  MOVLB  0
04480:  CALL   14A8
04484:  MOVFF  764,FEA
04488:  MOVFF  763,FE9
0448C:  MOVFF  01,FEF
04490:  MOVLB  7
04492:  INCF   x02,F
04494:  BRA    4462
....................       }
....................       byteCount = cx[2];
04496:  MOVFF  6A0,705
....................       
....................       //Catching index 3 to byte count or last byte of message
....................       for (i=3;i<byteCount;i++){
0449A:  MOVLW  03
0449C:  MOVWF  x02
0449E:  MOVF   x05,W
044A0:  SUBWF  x02,W
044A2:  BC    44D2
....................          cx[i] = fgetc(RS232_BTD200);  
044A4:  CLRF   03
044A6:  MOVF   x02,W
044A8:  ADDLW  9E
044AA:  MOVWF  FE9
044AC:  MOVLW  06
044AE:  ADDWFC 03,W
044B0:  MOVWF  FEA
044B2:  MOVFF  FEA,764
044B6:  MOVFF  FE9,763
044BA:  MOVLB  0
044BC:  CALL   14A8
044C0:  MOVFF  764,FEA
044C4:  MOVFF  763,FE9
044C8:  MOVFF  01,FEF
044CC:  MOVLB  7
044CE:  INCF   x02,F
044D0:  BRA    449E
....................          //fprintf(USB, RS232_BTD200);
....................       }
....................       
....................       //Printing the complete hex message from BTD-200
....................       for (i=0;i<byteCount;i++){
044D2:  CLRF   x02
044D4:  MOVF   x05,W
044D6:  SUBWF  x02,W
044D8:  BC    4506
....................          fprintf(USB, "%X ", cx[i]);   
044DA:  CLRF   03
044DC:  MOVF   x02,W
044DE:  ADDLW  9E
044E0:  MOVWF  FE9
044E2:  MOVLW  06
044E4:  ADDWFC 03,W
044E6:  MOVWF  FEA
044E8:  MOVFF  FEF,762
044EC:  MOVLW  37
044EE:  MOVWF  x63
044F0:  MOVLB  0
044F2:  CALL   14F2
044F6:  MOVLW  20
044F8:  BTFSS  FA4.4
044FA:  BRA    44F8
044FC:  MOVLB  F
044FE:  MOVWF  x1C
04500:  MOVLB  7
04502:  INCF   x02,F
04504:  BRA    44D4
....................          //fprintf(USB, "\nPrinting");
....................          //fprintf(RS485_GDAT1, "%c", cx[i]);
....................       }
.................... 
....................       if (cx[0] == 0xff){
04506:  MOVLB  6
04508:  INCFSZ x9E,W
0450A:  BRA    45CC
....................          //fprintf(USB, RS232_BTD200);
....................          if (cx[1] == 0xff){ 
0450C:  INCFSZ x9F,W
0450E:  BRA    45CC
....................             //fprintf(USB, RS232_BTD200);
....................             //fprintf(USB, "\nTest 2nd header");
....................             
....................             //Reading and analyzing the BTD-200 command and selecting the correct response
....................             response = readData(cx[2], cx[3], cx[4], cx[5], cx[6], cx[7]);
04510:  MOVFF  6A0,761
04514:  MOVFF  6A1,762
04518:  MOVFF  6A2,763
0451C:  MOVFF  6A3,764
04520:  MOVFF  6A4,765
04524:  MOVFF  6A5,766
04528:  MOVLB  0
0452A:  GOTO   1850
0452E:  MOVFF  01,706
....................             //fprintf(USB, "\nTest writeData"); 
....................             writeData(response, cx[7]);
04532:  MOVFF  706,761
04536:  MOVFF  6A5,762
0453A:  GOTO   1FE0
....................             fprintf(USB, "\n");
0453E:  MOVLW  0A
04540:  BTFSS  FA4.4
04542:  BRA    4540
04544:  MOVLB  F
04546:  MOVWF  x1C
....................             
....................             getMcuDateTime();
04548:  MOVLB  0
0454A:  CALL   1214
....................             strcpy(biralBT, strDateTime);
0454E:  MOVLW  03
04550:  MOVWF  FEA
04552:  MOVLW  9B
04554:  MOVWF  FE9
04556:  MOVLW  03
04558:  MOVWF  FE2
0455A:  MOVLW  87
0455C:  MOVWF  FE1
0455E:  MOVF   FE7,F
04560:  MOVFF  FE6,FEE
04564:  BNZ   455E
....................             fprintf(USB, "Date-Time: %s\n", biralBT);
04566:  MOVLW  2A
04568:  MOVWF  FF6
0456A:  MOVLW  0E
0456C:  MOVWF  FF7
0456E:  MOVLW  00
04570:  MOVWF  FF8
04572:  MOVLW  0B
04574:  MOVLB  7
04576:  MOVWF  x90
04578:  MOVLB  0
0457A:  CALL   157A
0457E:  MOVLW  03
04580:  MOVWF  FEA
04582:  MOVLW  9B
04584:  MOVWF  FE9
04586:  CALL   10B6
0458A:  MOVLW  0A
0458C:  BTFSS  FA4.4
0458E:  BRA    458C
04590:  MOVLB  F
04592:  MOVWF  x1C
....................          
....................             strcpy(strDateTime, ""); 
04594:  MOVLW  03
04596:  MOVWF  FEA
04598:  MOVLW  87
0459A:  MOVWF  FE9
0459C:  MOVLW  00
0459E:  MOVLB  0
045A0:  CALL   00EE
045A4:  TBLRD*-
045A6:  TBLRD*+
045A8:  MOVF   FF5,W
045AA:  MOVWF  FEE
045AC:  IORLW  00
045AE:  BNZ   45A6
....................             strcpy(biralBT, ""); 
045B0:  MOVLW  03
045B2:  MOVWF  FEA
045B4:  MOVLW  9B
045B6:  MOVWF  FE9
045B8:  MOVLW  00
045BA:  CALL   00EE
045BE:  TBLRD*-
045C0:  TBLRD*+
045C2:  MOVF   FF5,W
045C4:  MOVWF  FEE
045C6:  IORLW  00
045C8:  BNZ   45C0
045CA:  MOVLB  6
045CC:  MOVLB  7
....................          }
....................       }     
....................    } 
....................               
....................           
....................    delay_ms(50);
045CE:  MOVLW  32
045D0:  MOVWF  x6D
045D2:  MOVLB  0
045D4:  CALL   0F16
....................    //fprintf(USB,"\nOngoing Read Serial!\n");
....................  
....................   
....................    //fprintf(USB, "\nWhere's data");
....................    if (cx[2]==0x0a && cx[2]==0x10 && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x01){
045D8:  MOVLB  6
045DA:  MOVF   xA0,W
045DC:  SUBLW  0A
045DE:  BNZ   4608
045E0:  MOVF   xA0,W
045E2:  SUBLW  10
045E4:  BNZ   4608
045E6:  MOVF   xA1,F
045E8:  BNZ   4608
045EA:  MOVF   xA2,W
045EC:  SUBLW  20
045EE:  BNZ   4608
045F0:  MOVF   xA3,F
045F2:  BNZ   4608
045F4:  DECFSZ xA4,W
045F6:  BRA    4608
....................       btdStatus(2);    
045F8:  MOVLW  02
045FA:  MOVLB  7
045FC:  MOVWF  x61
045FE:  MOVLB  0
04600:  CALL   2394
....................    }
04604:  BRA    498E
04606:  MOVLB  6
....................    
....................     else if (cx[7]==0 && cx[2]==0x0a && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x21){
04608:  MOVF   xA5,F
0460A:  BNZ   4636
0460C:  MOVF   xA0,W
0460E:  SUBLW  0A
04610:  BNZ   4636
04612:  MOVF   xA1,F
04614:  BNZ   4636
04616:  MOVF   xA2,W
04618:  SUBLW  20
0461A:  BNZ   4636
0461C:  MOVF   xA3,F
0461E:  BNZ   4636
04620:  MOVF   xA4,W
04622:  SUBLW  21
04624:  BNZ   4636
....................       btdStatus(3);
04626:  MOVLW  03
04628:  MOVLB  7
0462A:  MOVWF  x61
0462C:  MOVLB  0
0462E:  CALL   2394
....................     }
04632:  BRA    498E
04634:  MOVLB  6
....................    else if (cx[7]>1 && cx[7]<5) {
04636:  MOVF   xA5,W
04638:  SUBLW  01
0463A:  BC    4652
0463C:  MOVF   xA5,W
0463E:  SUBLW  04
04640:  BNC   4652
....................       btdStatus(3);
04642:  MOVLW  03
04644:  MOVLB  7
04646:  MOVWF  x61
04648:  MOVLB  0
0464A:  CALL   2394
....................    }
0464E:  BRA    498E
04650:  MOVLB  6
....................    
....................    else if (cx[7]==63){
04652:  MOVF   xA5,W
04654:  SUBLW  3F
04656:  BNZ   4668
....................       btdStatus(4);
04658:  MOVLW  04
0465A:  MOVLB  7
0465C:  MOVWF  x61
0465E:  MOVLB  0
04660:  CALL   2394
....................    }
04664:  BRA    498E
04666:  MOVLB  6
....................                 
....................                 
....................    else if (cx[2]==0x57 && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x04 ){
04668:  MOVF   xA0,W
0466A:  SUBLW  57
0466C:  BTFSS  FD8.2
0466E:  BRA    4990
04670:  MOVF   xA1,F
04672:  BTFSS  FD8.2
04674:  BRA    4990
04676:  MOVF   xA2,W
04678:  SUBLW  20
0467A:  BTFSS  FD8.2
0467C:  BRA    4990
0467E:  MOVF   xA3,F
04680:  BTFSS  FD8.2
04682:  BRA    4990
04684:  MOVF   xA4,W
04686:  SUBLW  04
04688:  BTFSS  FD8.2
0468A:  BRA    4990
....................        getMcuDateTime();
0468C:  MOVLB  0
0468E:  CALL   1214
....................        strcpy(biralBT, strDateTime);
04692:  MOVLW  03
04694:  MOVWF  FEA
04696:  MOVLW  9B
04698:  MOVWF  FE9
0469A:  MOVLW  03
0469C:  MOVWF  FE2
0469E:  MOVLW  87
046A0:  MOVWF  FE1
046A2:  MOVF   FE7,F
046A4:  MOVFF  FE6,FEE
046A8:  BNZ   46A2
....................       //fprintf(USB, "\nTest");
....................     
....................       fprintf(USB, "Warning - Flash Count: %X  ", cx[18]);  
046AA:  MOVLW  3A
046AC:  MOVWF  FF6
046AE:  MOVLW  0E
046B0:  MOVWF  FF7
046B2:  MOVLW  00
046B4:  MOVWF  FF8
046B6:  MOVLW  17
046B8:  MOVLB  7
046BA:  MOVWF  x90
046BC:  MOVLB  0
046BE:  CALL   157A
046C2:  MOVFF  6B0,762
046C6:  MOVLW  37
046C8:  MOVLB  7
046CA:  MOVWF  x63
046CC:  MOVLB  0
046CE:  CALL   14F2
046D2:  MOVLW  20
046D4:  BTFSS  FA4.4
046D6:  BRA    46D4
046D8:  MOVLB  F
046DA:  MOVWF  x1C
046DC:  MOVLW  20
046DE:  BTFSS  FA4.4
046E0:  BRA    46DE
046E2:  MOVWF  x1C
....................       //sprintf(fc, "FC:%i+", cx[18]); // integer to string    
....................       for (index=0;index<48;index=index+12){
046E4:  MOVLB  7
046E6:  CLRF   x10
046E8:  MOVF   x10,W
046EA:  SUBLW  2F
046EC:  BTFSS  FD8.0
046EE:  BRA    4902
....................       //fprintf(USB, "\nIndex: %i", inF);
....................          for (i=0;i<2;i++){
046F0:  CLRF   x02
046F2:  MOVF   x02,W
046F4:  SUBLW  01
046F6:  BNC   4728
....................             dist[0] = cx[40+index];
046F8:  MOVLW  28
046FA:  ADDWF  x10,W
046FC:  CLRF   03
046FE:  ADDLW  9E
04700:  MOVWF  FE9
04702:  MOVLW  06
04704:  ADDWFC 03,W
04706:  MOVWF  FEA
04708:  CLRF   x5A
0470A:  MOVFF  FEF,759
....................             dist[1] = cx[41+index];
0470E:  MOVLW  29
04710:  ADDWF  x10,W
04712:  CLRF   03
04714:  ADDLW  9E
04716:  MOVWF  FE9
04718:  MOVLW  06
0471A:  ADDWFC 03,W
0471C:  MOVWF  FEA
0471E:  CLRF   x5C
04720:  MOVFF  FEF,75B
04724:  INCF   x02,F
04726:  BRA    46F2
....................          }
.................... 
....................          distance = (dist[1]<<8 | dist[0])*0.01;     
04728:  MOVFF  75B,763
0472C:  CLRF   x62
0472E:  MOVF   x59,W
04730:  IORWF  x62,F
04732:  MOVF   x5A,W
04734:  IORWF  x63,F
04736:  MOVFF  763,7E2
0473A:  MOVFF  762,7E1
0473E:  MOVLB  0
04740:  CALL   29AA
04744:  MOVFF  03,7E4
04748:  MOVFF  02,7E3
0474C:  MOVFF  01,7E2
04750:  MOVFF  00,7E1
04754:  MOVLW  0A
04756:  MOVLB  7
04758:  MOVWF  xE8
0475A:  MOVLW  D7
0475C:  MOVWF  xE7
0475E:  MOVLW  23
04760:  MOVWF  xE6
04762:  MOVLW  78
04764:  MOVWF  xE5
04766:  MOVLB  0
04768:  CALL   29E0
0476C:  MOVFF  03,70A
04770:  MOVFF  02,709
04774:  MOVFF  01,708
04778:  MOVFF  00,707
.................... 
....................          if (cx[43+index] == 0){
0477C:  MOVLW  2B
0477E:  MOVLB  7
04780:  ADDWF  x10,W
04782:  CLRF   03
04784:  ADDLW  9E
04786:  MOVWF  FE9
04788:  MOVLW  06
0478A:  ADDWFC 03,W
0478C:  MOVWF  FEA
0478E:  MOVF   FEF,F
04790:  BNZ   47BC
....................             dir =   cx[43+index]<<8 | cx[42+index];
04792:  MOVLW  2B
04794:  ADDWF  x10,W
04796:  CLRF   03
04798:  ADDLW  9E
0479A:  MOVWF  FE9
0479C:  MOVLW  06
0479E:  ADDWFC 03,W
047A0:  MOVWF  FEA
047A2:  CLRF   x61
047A4:  MOVLW  2A
047A6:  ADDWF  x10,W
047A8:  CLRF   03
047AA:  ADDLW  9E
047AC:  MOVWF  FE9
047AE:  MOVLW  06
047B0:  ADDWFC 03,W
047B2:  MOVWF  FEA
047B4:  MOVF   FEF,W
047B6:  IORWF  x61,W
047B8:  MOVWF  x0B
047BA:  CLRF   x0C
....................          }
....................                
....................          if (cx[43+index] > 0){
047BC:  MOVLW  2B
047BE:  ADDWF  x10,W
047C0:  CLRF   03
047C2:  ADDLW  9E
047C4:  MOVWF  FE9
047C6:  MOVLW  06
047C8:  ADDWFC 03,W
047CA:  MOVWF  FEA
047CC:  MOVF   FEF,F
047CE:  BZ    4816
....................             for (i=0;i<2;i++){
047D0:  CLRF   x02
047D2:  MOVF   x02,W
047D4:  SUBLW  01
047D6:  BNC   4808
....................                dirc[0] = cx[42+index];
047D8:  MOVLW  2A
047DA:  ADDWF  x10,W
047DC:  CLRF   03
047DE:  ADDLW  9E
047E0:  MOVWF  FE9
047E2:  MOVLW  06
047E4:  ADDWFC 03,W
047E6:  MOVWF  FEA
047E8:  CLRF   x5E
047EA:  MOVFF  FEF,75D
....................                dirc[1] = cx[43+index];
047EE:  MOVLW  2B
047F0:  ADDWF  x10,W
047F2:  CLRF   03
047F4:  ADDLW  9E
047F6:  MOVWF  FE9
047F8:  MOVLW  06
047FA:  ADDWFC 03,W
047FC:  MOVWF  FEA
047FE:  CLRF   x60
04800:  MOVFF  FEF,75F
04804:  INCF   x02,F
04806:  BRA    47D2
....................             }
....................             dir = dirc[1]<<8 | dirc[0];
04808:  CLRF   x61
0480A:  MOVF   x61,W
0480C:  IORWF  x5D,W
0480E:  MOVWF  x0B
04810:  MOVF   x5F,W
04812:  IORWF  x5E,W
04814:  MOVWF  x0C
....................             //fprintf(USB, "\nDirection Hex: %X %X degrees  ", cx[42], cx[43]);
....................          }
....................          
....................          m = cx[36];
04816:  MOVFF  6C2,70D
....................          p = cx[18];
0481A:  MOVFF  6B0,70E
....................                
....................          //delay_ms(50);
....................          //fprintf(USB, "\nDistance: %lf km  Direction: %li degrees  ", distance, dir);
....................          //fprintf(USB, "Date: ");
....................          //dMonth(m);
....................          //fprintf(USB, " %i, 20%i", cx[35+index], cx[37+index]);
....................          //fprintf(USB, "  Time: %02i:%02i:%02i", cx[34+index], cx[33+index], cx[32+index]);                           
....................          
....................          sprintf(dsdr, "%lf+%li+%i", distance, dir, inF);
0481E:  MOVLW  07
04820:  MOVLB  4
04822:  MOVWF  x90
04824:  MOVLW  11
04826:  MOVWF  x8F
04828:  MOVLW  89
0482A:  MOVWF  FE9
0482C:  MOVFF  70A,7B2
04830:  MOVFF  709,7B1
04834:  MOVFF  708,7B0
04838:  MOVFF  707,7AF
0483C:  MOVLW  02
0483E:  MOVLB  7
04840:  MOVWF  xB3
04842:  MOVLB  0
04844:  CALL   2BAE
04848:  MOVLW  2B
0484A:  MOVLB  7
0484C:  MOVWF  xBC
0484E:  MOVLB  0
04850:  CALL   0F8C
04854:  MOVLW  10
04856:  MOVWF  FE9
04858:  MOVFF  70C,762
0485C:  MOVFF  70B,761
04860:  GOTO   2D5C
04864:  MOVLW  2B
04866:  MOVLB  7
04868:  MOVWF  xBC
0486A:  MOVLB  0
0486C:  CALL   0F8C
04870:  MOVFF  70F,7AF
04874:  MOVLW  18
04876:  MOVLB  7
04878:  MOVWF  xB0
0487A:  MOVLB  0
0487C:  CALL   0FDE
....................          sprintf(fcount, "%i", p);
04880:  MOVLW  07
04882:  MOVLB  4
04884:  MOVWF  x90
04886:  MOVLW  57
04888:  MOVWF  x8F
0488A:  MOVFF  70E,7AF
0488E:  MOVLW  18
04890:  MOVLB  7
04892:  MOVWF  xB0
04894:  MOVLB  0
04896:  CALL   0FDE
....................           
....................          //fprintf(USB, "\nDistance: %s  ", dsdr);
....................          //fprintf(USB, "\nTest: %s", dsdr);
....................                
....................          strcpy(distDir, dsdr);
0489A:  MOVLW  04
0489C:  MOVWF  FEA
0489E:  MOVLW  45
048A0:  MOVWF  FE9
048A2:  MOVLW  07
048A4:  MOVWF  FE2
048A6:  MOVLW  11
048A8:  MOVWF  FE1
048AA:  MOVF   FE7,F
048AC:  MOVFF  FE6,FEE
048B0:  BNZ   48AA
....................          strcpy(flashCount, fcount);
048B2:  MOVLW  04
048B4:  MOVWF  FEA
048B6:  MOVLW  4F
048B8:  MOVWF  FE9
048BA:  MOVLW  07
048BC:  MOVWF  FE2
048BE:  MOVLW  57
048C0:  MOVWF  FE1
048C2:  MOVF   FE7,F
048C4:  MOVFF  FE6,FEE
048C8:  BNZ   48C2
....................          
....................          polarConverter();
048CA:  GOTO   3C90
....................          
....................          //delay_ms(100);
....................          
....................          inF = inF + 1; 
048CE:  MOVLW  01
048D0:  MOVLB  7
048D2:  ADDWF  x0F,F
....................               
....................          //strcat(strBTD, dsdr);
....................          //fprintf(USB, "\nBiral Data: %s\n", BTDLaLo);
....................          strcpy(dsdr, NULL);
048D4:  MOVLW  07
048D6:  MOVWF  FEA
048D8:  MOVLW  11
048DA:  MOVWF  FE9
048DC:  CLRF   FE2
048DE:  CLRF   FE1
048E0:  MOVF   FE7,F
048E2:  MOVFF  FE6,FEE
048E6:  BNZ   48E0
....................          strcpy(fcount, NULL);
048E8:  MOVLW  07
048EA:  MOVWF  FEA
048EC:  MOVLW  57
048EE:  MOVWF  FE9
048F0:  CLRF   FE2
048F2:  CLRF   FE1
048F4:  MOVF   FE7,F
048F6:  MOVFF  FE6,FEE
048FA:  BNZ   48F4
048FC:  MOVLW  0C
048FE:  ADDWF  x10,F
04900:  BRA    46E8
....................          
....................          }
....................          
....................          delay_ms(50);
04902:  MOVLW  32
04904:  MOVWF  x6D
04906:  MOVLB  0
04908:  CALL   0F16
....................          //Storing Date and Time   190905/175000  YYMMDD/HHMMSS
....................          sprintf(dt, "%02i%02i%02i/%02i%02i%02i", cx[37], cx[36], cx[35], cx[34], cx[33], cx[32]);
0490C:  MOVLW  07
0490E:  MOVLB  4
04910:  MOVWF  x90
04912:  MOVLW  43
04914:  MOVWF  x8F
04916:  MOVFF  6C3,761
0491A:  MOVLW  01
0491C:  MOVLB  7
0491E:  MOVWF  x62
04920:  MOVLB  0
04922:  RCALL  41F6
04924:  MOVFF  6C2,761
04928:  MOVLW  01
0492A:  MOVLB  7
0492C:  MOVWF  x62
0492E:  MOVLB  0
04930:  RCALL  41F6
04932:  MOVFF  6C1,761
04936:  MOVLW  01
04938:  MOVLB  7
0493A:  MOVWF  x62
0493C:  MOVLB  0
0493E:  RCALL  41F6
04940:  MOVLW  2F
04942:  MOVLB  7
04944:  MOVWF  xBC
04946:  MOVLB  0
04948:  CALL   0F8C
0494C:  MOVFF  6C0,761
04950:  MOVLW  01
04952:  MOVLB  7
04954:  MOVWF  x62
04956:  MOVLB  0
04958:  RCALL  41F6
0495A:  MOVFF  6BF,761
0495E:  MOVLW  01
04960:  MOVLB  7
04962:  MOVWF  x62
04964:  MOVLB  0
04966:  RCALL  41F6
04968:  MOVFF  6BE,761
0496C:  MOVLW  01
0496E:  MOVLB  7
04970:  MOVWF  x62
04972:  MOVLB  0
04974:  RCALL  41F6
....................          //fprintf(USB, "\nBiral Time: %s\n", dt);
....................             
....................          //delay_ms(100);
....................          
....................          //Carbs ---- Change BTD time to arQ Time
....................          //strcpy(biralBT, dt);
....................          
....................          
....................          
....................          //fprintf(USB, "\nBiral Data: %s\n", BTDLaLo);
....................          //BTDhealth[0] = 6;
....................          btdStatus(1);
04976:  MOVLW  01
04978:  MOVLB  7
0497A:  MOVWF  x61
0497C:  MOVLB  0
0497E:  CALL   2394
....................          delay_ms(50);
04982:  MOVLW  32
04984:  MOVLB  7
04986:  MOVWF  x6D
04988:  MOVLB  0
0498A:  CALL   0F16
0498E:  MOVLB  6
....................       
....................       }
....................          
.................... //!      else if (cx[2]==0x27 && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x03){
.................... //!         btdStatus(5);
.................... //!         delay_ms(50);
.................... //!      }
....................          
....................       //fprintf(USB, "\nTest end of Serial Read"); 
....................       //setup_wdt(WDT_ON);
....................       //cx[7] = 0x0a;
....................       //sprintf(strBTD_info, "NFD*%X\r", cx[7]);
....................       //strcpy(strBTD_con, strBTD_info);
....................       //btdStatus(5);
....................       //strcpy(strBTD_info, "");
....................       delay_ms(50);
04990:  MOVLW  32
04992:  MOVLB  7
04994:  MOVWF  x6D
04996:  MOVLB  0
04998:  CALL   0F16
0499C:  GOTO   5B24 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... void mcuStatusOnStartUp(){
....................    char strx[20] = {};
*
01346:  MOVLB  6
01348:  CLRF   x9E
0134A:  CLRF   x9F
0134C:  CLRF   xA0
0134E:  CLRF   xA1
01350:  CLRF   xA2
01352:  CLRF   xA3
01354:  CLRF   xA4
01356:  CLRF   xA5
01358:  CLRF   xA6
0135A:  CLRF   xA7
0135C:  CLRF   xA8
0135E:  CLRF   xA9
01360:  CLRF   xAA
01362:  CLRF   xAB
01364:  CLRF   xAC
01366:  CLRF   xAD
01368:  CLRF   xAE
0136A:  CLRF   xAF
0136C:  CLRF   xB0
0136E:  CLRF   xB1
....................    //char *msgP1=NULL;
....................    char message[40];
....................    int cause;
....................    
....................    cause=restart_cause();
01370:  MOVF   FD0,W
01372:  ANDLW  0F
01374:  BTFSS  FD0.4
01376:  MOVLW  00
01378:  BSF    FD0.0
0137A:  BSF    FD0.1
0137C:  BSF    FD0.4
0137E:  BSF    FD8.3
01380:  BSF    FD8.4
01382:  MOVWF  xDA
....................    switch (cause){
01384:  MOVF   xDA,W
01386:  XORLW  07
01388:  MOVLB  0
0138A:  BZ    139A
0138C:  XORLW  0B
0138E:  BZ    13B6
01390:  XORLW  0C
01392:  BZ    13D2
01394:  XORLW  0F
01396:  BZ    13EE
01398:  BRA    140A
....................       case WDT_TIMEOUT:{ 
....................           strcpy(strx,"WATCHDOG TIMEOUT");
0139A:  MOVLW  06
0139C:  MOVWF  FEA
0139E:  MOVLW  9E
013A0:  MOVWF  FE9
013A2:  MOVLW  00
013A4:  CALL   0210
013A8:  TBLRD*-
013AA:  TBLRD*+
013AC:  MOVF   FF5,W
013AE:  MOVWF  FEE
013B0:  IORLW  00
013B2:  BNZ   13AA
....................           break;
013B4:  BRA    1442
....................       }
....................       
....................      
....................       case NORMAL_POWER_UP:{  //12 after upload of firmware
....................          strcpy(strx,"FRESH POWER UP!");
013B6:  MOVLW  06
013B8:  MOVWF  FEA
013BA:  MOVLW  9E
013BC:  MOVWF  FE9
013BE:  MOVLW  00
013C0:  CALL   0236
013C4:  TBLRD*-
013C6:  TBLRD*+
013C8:  MOVF   FF5,W
013CA:  MOVWF  FEE
013CC:  IORLW  00
013CE:  BNZ   13C6
....................          break;
013D0:  BRA    1442
....................       }
....................       
....................     
....................       case RESET_INSTRUCTION:{   //0
....................          //readDataEEprom(EEPROM_RESET_NUMBER);
....................          strcpy(strx, "SOFTWARE RESET-");
013D2:  MOVLW  06
013D4:  MOVWF  FEA
013D6:  MOVLW  9E
013D8:  MOVWF  FE9
013DA:  MOVLW  00
013DC:  CALL   025A
013E0:  TBLRD*-
013E2:  TBLRD*+
013E4:  MOVF   FF5,W
013E6:  MOVWF  FEE
013E8:  IORLW  00
013EA:  BNZ   13E2
....................          //strcat(strx, funcReturnVar);
....................          break;
013EC:  BRA    1442
....................       }
....................       
....................       case MCLR_FROM_RUN:{    //15
....................          strcpy(strx,"HARDWARE RESET");
013EE:  MOVLW  06
013F0:  MOVWF  FEA
013F2:  MOVLW  9E
013F4:  MOVWF  FE9
013F6:  MOVLW  00
013F8:  CALL   027E
013FC:  TBLRD*-
013FE:  TBLRD*+
01400:  MOVF   FF5,W
01402:  MOVWF  FEE
01404:  IORLW  00
01406:  BNZ   13FE
....................          break;
01408:  BRA    1442
....................       }
....................       
....................       default:{
....................          sprintf(strx, "OTHER RESET CAUSE (%i)", cause );
0140A:  MOVLW  06
0140C:  MOVLB  4
0140E:  MOVWF  x90
01410:  MOVLW  9E
01412:  MOVWF  x8F
01414:  MOVLW  56
01416:  MOVWF  FF6
01418:  MOVLW  0E
0141A:  MOVWF  FF7
0141C:  MOVLW  00
0141E:  MOVWF  FF8
01420:  MOVLW  13
01422:  MOVLB  7
01424:  MOVWF  xAF
01426:  MOVLB  0
01428:  RCALL  0FAE
0142A:  MOVFF  6DA,7AF
0142E:  MOVLW  18
01430:  MOVLB  7
01432:  MOVWF  xB0
01434:  MOVLB  0
01436:  RCALL  0FDE
01438:  MOVLW  29
0143A:  MOVLB  7
0143C:  MOVWF  xBC
0143E:  MOVLB  0
01440:  RCALL  0F8C
....................       }
....................    }
....................    
....................    fprintf(USB,"%s\n",strx);
01442:  MOVLW  06
01444:  MOVWF  FEA
01446:  MOVLW  9E
01448:  MOVWF  FE9
0144A:  RCALL  10B6
0144C:  MOVLW  0A
0144E:  BTFSS  FA4.4
01450:  BRA    144E
01452:  MOVLB  F
01454:  MOVWF  x1C
....................    //strcpy(SMS_TOBE_SENT,strx);
....................    getMcuDateTime();
01456:  MOVLB  0
01458:  RCALL  1214
....................    //sprintf(SMS_TOBE_SENT, "%s - %s", strx, getMcuDateTime()); //getDateTime()
....................    //sprintf(message, "%s - %s", strx, globalDT); //getDateTime()  
....................    sprintf(message, "%s - %s", strx, strDateTime); //getDateTime() 
0145A:  MOVLW  06
0145C:  MOVLB  4
0145E:  MOVWF  x90
01460:  MOVLW  B2
01462:  MOVWF  x8F
01464:  MOVFF  490,FEA
01468:  MOVFF  48F,FE9
0146C:  CLRF   FEF
0146E:  MOVLW  06
01470:  MOVWF  FEA
01472:  MOVLW  9E
01474:  MOVWF  FE9
01476:  MOVLB  0
01478:  RCALL  1322
0147A:  MOVLW  70
0147C:  MOVWF  FF6
0147E:  MOVLW  0E
01480:  MOVWF  FF7
01482:  MOVLW  00
01484:  MOVWF  FF8
01486:  MOVLW  03
01488:  MOVLB  7
0148A:  MOVWF  xAF
0148C:  MOVLB  0
0148E:  RCALL  0FAE
01490:  MOVFF  490,FEA
01494:  MOVFF  48F,FE9
01498:  CLRF   FEF
0149A:  MOVLW  03
0149C:  MOVWF  FEA
0149E:  MOVLW  87
014A0:  MOVWF  FE9
014A2:  RCALL  1322
014A4:  GOTO   5AF6 (RETURN)
....................    //AttemptToSend(message,MYNUMBER2);
.................... }
.................... 
.................... 
.................... 
.................... void main(){
*
056DA:  CLRF   FF8
056DC:  BCF    FD0.7
056DE:  BSF    07.7
056E0:  MOVLW  72
056E2:  MOVWF  FD3
056E4:  CLRF   F9B
056E6:  CLRF   F64
056E8:  BCF    FC6.5
056EA:  MOVLW  00
056EC:  MOVWF  FC7
056EE:  MOVLW  20
056F0:  MOVWF  FC6
056F2:  BCF    F94.5
056F4:  BSF    F94.4
056F6:  BCF    F94.3
056F8:  BSF    F95.6
056FA:  BSF    F95.5
056FC:  MOVLW  27
056FE:  MOVWF  F69
05700:  MOVLW  28
05702:  MOVWF  F67
05704:  BSF    F68.7
05706:  BCF    F68.6
05708:  BCF    F96.4
0570A:  BSF    F8D.4
0570C:  BCF    F98.4
0570E:  BSF    F8F.4
05710:  BCF    F65.3
05712:  MOVLW  0C
05714:  MOVWF  FAF
05716:  MOVLW  A2
05718:  MOVWF  FAC
0571A:  MOVLW  90
0571C:  MOVWF  FAB
0571E:  BCF    40.0
05720:  CLRF   41
05722:  BCF    40.1
05724:  MOVLB  1
05726:  CLRF   x41
05728:  CLRF   x42
0572A:  CLRF   x43
0572C:  BCF    40.2
0572E:  MOVLB  3
05730:  CLRF   x80
05732:  CLRF   x81
05734:  CLRF   x82
05736:  CLRF   x83
05738:  CLRF   x84
0573A:  CLRF   x85
0573C:  CLRF   x86
0573E:  MOVLB  4
05740:  CLRF   x8B
05742:  MOVLW  0F
05744:  MOVWF  x8C
05746:  BCF    40.3
05748:  BCF    40.4
0574A:  CLRF   x8D
0574C:  BCF    40.5
0574E:  BCF    40.6
05750:  BCF    40.7
05752:  BCF    x8E.0
05754:  MOVLB  F
05756:  BSF    x20.3
05758:  MOVLW  44
0575A:  MOVWF  x1E
0575C:  MOVLW  00
0575E:  MOVWF  x1F
05760:  MOVLW  A6
05762:  MOVWF  x21
05764:  MOVLW  90
05766:  MOVWF  x22
05768:  MOVLB  4
0576A:  BCF    x8E.1
0576C:  CLRF   x90
0576E:  CLRF   x8F
05770:  CLRF   x91
05772:  MOVLW  00
05774:  MOVLB  F
05776:  MOVWF  x23
05778:  MOVWF  x24
0577A:  MOVWF  x25
0577C:  BCF    FC1.3
0577E:  BCF    FC1.4
05780:  BCF    FC1.5
05782:  CLRF   x2E
05784:  CLRF   x2F
05786:  CLRF   x54
05788:  MOVLB  4
0578A:  BCF    x8E.2
0578C:  BRA    57B2
0578E:  DATA 02,00
05790:  DATA 1C,00
05792:  DATA 00,1E
05794:  DATA 40,22
05796:  DATA 00,FF
05798:  DATA 40,42
0579A:  DATA 00,FF
0579C:  DATA 41,44
0579E:  DATA 00,FF
057A0:  DATA C0,00
057A2:  DATA 3E,C0
057A4:  DATA 00,FF
057A6:  DATA 43,87
057A8:  DATA 00,05
057AA:  DATA C0,00
057AC:  DATA FF,44
057AE:  DATA 93,00
057B0:  DATA 00,00
057B2:  MOVLW  00
057B4:  MOVWF  FF8
057B6:  MOVLW  57
057B8:  MOVWF  FF7
057BA:  MOVLW  8E
057BC:  MOVWF  FF6
057BE:  TBLRD*+
057C0:  MOVF   FF5,W
057C2:  MOVWF  00
057C4:  XORLW  00
057C6:  BZ    57EE
057C8:  TBLRD*+
057CA:  MOVF   FF5,W
057CC:  MOVWF  01
057CE:  BTFSC  FE8.7
057D0:  BRA    57DC
057D2:  ANDLW  3F
057D4:  MOVWF  FEA
057D6:  TBLRD*+
057D8:  MOVFF  FF5,FE9
057DC:  BTFSC  01.6
057DE:  TBLRD*+
057E0:  BTFSS  01.6
057E2:  TBLRD*+
057E4:  MOVFF  FF5,FEE
057E8:  DCFSNZ 00,F
057EA:  BRA    57BE
057EC:  BRA    57E0
057EE:  CLRF   FF8
....................    char dbg[6]="debug";
057F0:  MOVLW  64
057F2:  MOVLB  5
057F4:  MOVWF  x92
057F6:  MOVLW  65
057F8:  MOVWF  x93
057FA:  MOVLW  62
057FC:  MOVWF  x94
057FE:  MOVLW  75
05800:  MOVWF  x95
05802:  MOVLW  67
05804:  MOVWF  x96
05806:  CLRF   x97
....................    char reset[6]="reset";
05808:  MOVLW  72
0580A:  MOVWF  x98
0580C:  MOVLW  65
0580E:  MOVWF  x99
05810:  MOVLW  73
05812:  MOVWF  x9A
05814:  MOVLW  65
05816:  MOVWF  x9B
05818:  MOVLW  74
0581A:  MOVWF  x9C
0581C:  CLRF   x9D
.................... 
....................    unsigned int8 tmp1;
....................    
....................    //int byteCount;
....................    char message[255]={};
0581E:  CLRF   x9F
05820:  CLRF   xA0
05822:  CLRF   xA1
05824:  CLRF   xA2
05826:  CLRF   xA3
05828:  CLRF   xA4
0582A:  CLRF   xA5
0582C:  CLRF   xA6
0582E:  CLRF   xA7
05830:  CLRF   xA8
05832:  CLRF   xA9
05834:  CLRF   xAA
05836:  CLRF   xAB
05838:  CLRF   xAC
0583A:  CLRF   xAD
0583C:  CLRF   xAE
0583E:  CLRF   xAF
05840:  CLRF   xB0
05842:  CLRF   xB1
05844:  CLRF   xB2
05846:  CLRF   xB3
05848:  CLRF   xB4
0584A:  CLRF   xB5
0584C:  CLRF   xB6
0584E:  CLRF   xB7
05850:  CLRF   xB8
05852:  CLRF   xB9
05854:  CLRF   xBA
05856:  CLRF   xBB
05858:  CLRF   xBC
0585A:  CLRF   xBD
0585C:  CLRF   xBE
0585E:  CLRF   xBF
05860:  CLRF   xC0
05862:  CLRF   xC1
05864:  CLRF   xC2
05866:  CLRF   xC3
05868:  CLRF   xC4
0586A:  CLRF   xC5
0586C:  CLRF   xC6
0586E:  CLRF   xC7
05870:  CLRF   xC8
05872:  CLRF   xC9
05874:  CLRF   xCA
05876:  CLRF   xCB
05878:  CLRF   xCC
0587A:  CLRF   xCD
0587C:  CLRF   xCE
0587E:  CLRF   xCF
05880:  CLRF   xD0
05882:  CLRF   xD1
05884:  CLRF   xD2
05886:  CLRF   xD3
05888:  CLRF   xD4
0588A:  CLRF   xD5
0588C:  CLRF   xD6
0588E:  CLRF   xD7
05890:  CLRF   xD8
05892:  CLRF   xD9
05894:  CLRF   xDA
05896:  CLRF   xDB
05898:  CLRF   xDC
0589A:  CLRF   xDD
0589C:  CLRF   xDE
0589E:  CLRF   xDF
058A0:  CLRF   xE0
058A2:  CLRF   xE1
058A4:  CLRF   xE2
058A6:  CLRF   xE3
058A8:  CLRF   xE4
058AA:  CLRF   xE5
058AC:  CLRF   xE6
058AE:  CLRF   xE7
058B0:  CLRF   xE8
058B2:  CLRF   xE9
058B4:  CLRF   xEA
058B6:  CLRF   xEB
058B8:  CLRF   xEC
058BA:  CLRF   xED
058BC:  CLRF   xEE
058BE:  CLRF   xEF
058C0:  CLRF   xF0
058C2:  CLRF   xF1
058C4:  CLRF   xF2
058C6:  CLRF   xF3
058C8:  CLRF   xF4
058CA:  CLRF   xF5
058CC:  CLRF   xF6
058CE:  CLRF   xF7
058D0:  CLRF   xF8
058D2:  CLRF   xF9
058D4:  CLRF   xFA
058D6:  CLRF   xFB
058D8:  CLRF   xFC
058DA:  CLRF   xFD
058DC:  CLRF   xFE
058DE:  CLRF   xFF
058E0:  MOVLB  6
058E2:  CLRF   x00
058E4:  CLRF   x01
058E6:  CLRF   x02
058E8:  CLRF   x03
058EA:  CLRF   x04
058EC:  CLRF   x05
058EE:  CLRF   x06
058F0:  CLRF   x07
058F2:  CLRF   x08
058F4:  CLRF   x09
058F6:  CLRF   x0A
058F8:  CLRF   x0B
058FA:  CLRF   x0C
058FC:  CLRF   x0D
058FE:  CLRF   x0E
05900:  CLRF   x0F
05902:  CLRF   x10
05904:  CLRF   x11
05906:  CLRF   x12
05908:  CLRF   x13
0590A:  CLRF   x14
0590C:  CLRF   x15
0590E:  CLRF   x16
05910:  CLRF   x17
05912:  CLRF   x18
05914:  CLRF   x19
05916:  CLRF   x1A
05918:  CLRF   x1B
0591A:  CLRF   x1C
0591C:  CLRF   x1D
0591E:  CLRF   x1E
05920:  CLRF   x1F
05922:  CLRF   x20
05924:  CLRF   x21
05926:  CLRF   x22
05928:  CLRF   x23
0592A:  CLRF   x24
0592C:  CLRF   x25
0592E:  CLRF   x26
05930:  CLRF   x27
05932:  CLRF   x28
05934:  CLRF   x29
05936:  CLRF   x2A
05938:  CLRF   x2B
0593A:  CLRF   x2C
0593C:  CLRF   x2D
0593E:  CLRF   x2E
05940:  CLRF   x2F
05942:  CLRF   x30
05944:  CLRF   x31
05946:  CLRF   x32
05948:  CLRF   x33
0594A:  CLRF   x34
0594C:  CLRF   x35
0594E:  CLRF   x36
05950:  CLRF   x37
05952:  CLRF   x38
05954:  CLRF   x39
05956:  CLRF   x3A
05958:  CLRF   x3B
0595A:  CLRF   x3C
0595C:  CLRF   x3D
0595E:  CLRF   x3E
05960:  CLRF   x3F
05962:  CLRF   x40
05964:  CLRF   x41
05966:  CLRF   x42
05968:  CLRF   x43
0596A:  CLRF   x44
0596C:  CLRF   x45
0596E:  CLRF   x46
05970:  CLRF   x47
05972:  CLRF   x48
05974:  CLRF   x49
05976:  CLRF   x4A
05978:  CLRF   x4B
0597A:  CLRF   x4C
0597C:  CLRF   x4D
0597E:  CLRF   x4E
05980:  CLRF   x4F
05982:  CLRF   x50
05984:  CLRF   x51
05986:  CLRF   x52
05988:  CLRF   x53
0598A:  CLRF   x54
0598C:  CLRF   x55
0598E:  CLRF   x56
05990:  CLRF   x57
05992:  CLRF   x58
05994:  CLRF   x59
05996:  CLRF   x5A
05998:  CLRF   x5B
0599A:  CLRF   x5C
0599C:  CLRF   x5D
0599E:  CLRF   x5E
059A0:  CLRF   x5F
059A2:  CLRF   x60
059A4:  CLRF   x61
059A6:  CLRF   x62
059A8:  CLRF   x63
059AA:  CLRF   x64
059AC:  CLRF   x65
059AE:  CLRF   x66
059B0:  CLRF   x67
059B2:  CLRF   x68
059B4:  CLRF   x69
059B6:  CLRF   x6A
059B8:  CLRF   x6B
059BA:  CLRF   x6C
059BC:  CLRF   x6D
059BE:  CLRF   x6E
059C0:  CLRF   x6F
059C2:  CLRF   x70
059C4:  CLRF   x71
059C6:  CLRF   x72
059C8:  CLRF   x73
059CA:  CLRF   x74
059CC:  CLRF   x75
059CE:  CLRF   x76
059D0:  CLRF   x77
059D2:  CLRF   x78
059D4:  CLRF   x79
059D6:  CLRF   x7A
059D8:  CLRF   x7B
059DA:  CLRF   x7C
059DC:  CLRF   x7D
059DE:  CLRF   x7E
059E0:  CLRF   x7F
059E2:  CLRF   x80
059E4:  CLRF   x81
059E6:  CLRF   x82
059E8:  CLRF   x83
059EA:  CLRF   x84
059EC:  CLRF   x85
059EE:  CLRF   x86
059F0:  CLRF   x87
059F2:  CLRF   x88
059F4:  CLRF   x89
059F6:  CLRF   x8A
059F8:  CLRF   x8B
059FA:  CLRF   x8C
059FC:  CLRF   x8D
059FE:  CLRF   x8E
05A00:  CLRF   x8F
05A02:  CLRF   x90
05A04:  CLRF   x91
05A06:  CLRF   x92
05A08:  CLRF   x93
05A0A:  CLRF   x94
05A0C:  CLRF   x95
05A0E:  CLRF   x96
05A10:  CLRF   x97
05A12:  CLRF   x98
05A14:  CLRF   x99
05A16:  CLRF   x9A
05A18:  CLRF   x9B
05A1A:  CLRF   x9C
05A1C:  CLRF   x9D
....................    delay_ms(500);
05A1E:  MOVLW  02
05A20:  MOVWF  x9E
05A22:  MOVLW  FA
05A24:  MOVLB  7
05A26:  MOVWF  x6D
05A28:  MOVLB  0
05A2A:  CALL   0F16
05A2E:  MOVLB  6
05A30:  DECFSZ x9E,F
05A32:  BRA    5A22
....................    
....................    fprintf(USB, "\n*************************************************\n");
05A34:  MOVLW  76
05A36:  MOVWF  FF6
05A38:  MOVLW  0E
05A3A:  MOVWF  FF7
05A3C:  MOVLW  00
05A3E:  MOVWF  FF8
05A40:  MOVLB  0
05A42:  CALL   0F40
....................    fprintf(USB, "ULAT Lightning Monitoring Station (Beta version)\n");
05A46:  MOVLW  AA
05A48:  MOVWF  FF6
05A4A:  MOVLW  0E
05A4C:  MOVWF  FF7
05A4E:  MOVLW  00
05A50:  MOVWF  FF8
05A52:  CALL   0F40
....................   
....................    enable_interrupts(INT_TIMER1); // enable timer1 interrupt, through the use of the 32 khz oscillator, it will be triggered every second   
05A56:  BSF    F9D.0
....................    enable_interrupts(INT_RDA);    // hardware UART interrupt, used by Radio/GSM module
05A58:  BSF    F9D.5
....................    enable_interrupts(INT_RDA2);   // hardware UART interrupt, used by USB through RS232 interface via the USB port
05A5A:  BSF    FA3.5
....................    enable_interrupts(INT_EXT);    // B0 used by rain gauge
05A5C:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1);   // RING OUT - will be triggered once a call or text is received by the gsm module
05A5E:  BSF    FF0.3
....................    //enable_interrupts(INT_EXT2);   // Interrupt 2 is triggered when there is interrupt signal from the AS3935
....................    enable_interrupts(GLOBAL);     // main switch for all the interrupts
05A60:  MOVLW  C0
05A62:  IORWF  FF2,F
....................  
....................    ext_int_edge(2,H_TO_L);         // configure INT2 state change to trigger interrupt 2  
05A64:  BCF    FF1.4
....................    
....................    setup_wdt(WDT_ON);// enable watch dog
05A66:  BSF    FD1.0
....................    //setup_wdt(WDT_128S);  
....................    
....................    setup_timer_1(T1_EXTERNAL|T1_DIV_BY_1|T1_ENABLE_SOSC); //no T1_CLK_OUT
05A68:  MOVLW  8F
05A6A:  MOVWF  FCD
05A6C:  CLRF   FAA
....................    
....................    setup_spi(SPI_MASTER |SPI_L_TO_H | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);  // Working with AS3935, set as default
05A6E:  BCF    FC6.5
05A70:  BCF    F94.5
05A72:  BSF    F94.4
05A74:  BCF    F94.3
05A76:  MOVLW  22
05A78:  MOVWF  FC6
05A7A:  MOVLW  00
05A7C:  MOVWF  FC7
....................     
....................    delay_ms(500);
05A7E:  MOVLW  02
05A80:  MOVLB  6
05A82:  MOVWF  x9E
05A84:  MOVLW  FA
05A86:  MOVLB  7
05A88:  MOVWF  x6D
05A8A:  MOVLB  0
05A8C:  CALL   0F16
05A90:  MOVLB  6
05A92:  DECFSZ x9E,F
05A94:  BRA    5A84
....................    //Thunder_Init();
....................     
....................    
....................    //igniteGSM();
....................    //InitGSM();                      // initialize GSM
....................    
....................    
....................    
....................    // igtLTE();
....................    delay_ms(2000);
05A96:  MOVLW  08
05A98:  MOVWF  x9E
05A9A:  MOVLW  FA
05A9C:  MOVLB  7
05A9E:  MOVWF  x6D
05AA0:  MOVLB  0
05AA2:  CALL   0F16
05AA6:  MOVLB  6
05AA8:  DECFSZ x9E,F
05AAA:  BRA    5A9A
....................   
....................    
....................    
....................    
....................    //fprintf(GSM, "init\r");
....................    //rtc_acquire_sync();             // sync datetime from rtc chip to both GSM and MCU
....................    
.................... 
....................    InterruptInput2_Flag=0;
05AAC:  MOVLB  4
05AAE:  BCF    x8E.1
....................       
....................    clear_InterruptUSB();
05AB0:  MOVLB  0
05AB2:  CALL   0F6E
.................... 
....................   
....................    //Send to server through message format
.................... 
....................    strcpy(SERVERNUMBER,"639564334913");
05AB6:  MOVLW  01
05AB8:  MOVWF  FEA
05ABA:  MOVLW  44
05ABC:  MOVWF  FE9
05ABE:  MOVLW  00
05AC0:  CALL   02A2
05AC4:  TBLRD*-
05AC6:  TBLRD*+
05AC8:  MOVF   FF5,W
05ACA:  MOVWF  FEE
05ACC:  IORLW  00
05ACE:  BNZ   5AC6
....................    //strcpy(MYNUMBER1,"639564334913");
....................    strcpy(MYNUMBER2,"639564334913");
05AD0:  MOVLW  01
05AD2:  MOVWF  FEA
05AD4:  MOVLW  62
05AD6:  MOVWF  FE9
05AD8:  MOVLW  00
05ADA:  CALL   02A2
05ADE:  TBLRD*-
05AE0:  TBLRD*+
05AE2:  MOVF   FF5,W
05AE4:  MOVWF  FEE
05AE6:  IORLW  00
05AE8:  BNZ   5AE0
....................    //strcpy(MyNUMBER,"");
....................    SENDING_TIME = 60; //60
05AEA:  MOVLW  3C
05AEC:  MOVLB  4
05AEE:  MOVWF  x8C
....................    
....................    mcuStatusOnStartUp(); // function determines cause of MCU restart
05AF0:  MOVLB  0
05AF2:  GOTO   1346
....................    
....................    //output_high(pin_BOOST1);  //5 volts
....................    //output_high(pin_BOOST2); //18 volts
....................    
....................    fprintf(USB, "\nInitializing BTD200\n");
05AF6:  MOVLW  DC
05AF8:  MOVWF  FF6
05AFA:  MOVLW  0E
05AFC:  MOVWF  FF7
05AFE:  MOVLW  00
05B00:  MOVWF  FF8
05B02:  CALL   0F40
....................    //igtLTE();
....................    //char gsLTE;
....................   
....................    delay_ms(200);
05B06:  MOVLW  C8
05B08:  MOVLB  7
05B0A:  MOVWF  x6D
05B0C:  MOVLB  0
05B0E:  CALL   0F16
....................    //clear_inputs();
....................    
....................    
....................    delay_ms(200);
05B12:  MOVLW  C8
05B14:  MOVLB  7
05B16:  MOVWF  x6D
05B18:  MOVLB  0
05B1A:  CALL   0F16
....................  
....................    
....................             
....................    while(1){
....................       restart_wdt();
05B1E:  CLRWDT
....................       //read RS232
....................       readSerial();
05B20:  GOTO   42D6
....................       
....................          
.................... 
....................       if (InterruptUSB_Flag==1){              // if there is a character from USB, the interrupt will trigger            
05B24:  BTFSS  40.0
05B26:  BRA    5BCA
....................          ledConfig(LED_GREEN);
05B28:  MOVLW  01
05B2A:  MOVLB  6
05B2C:  MOVWF  x9F
05B2E:  MOVLB  0
05B30:  CALL   49A0
....................          
....................          InterruptUSB_Rxd[InterruptUSB_Counter-1]='\0';       
05B34:  MOVLW  01
05B36:  SUBWF  41,W
05B38:  CLRF   03
05B3A:  ADDLW  2C
05B3C:  MOVWF  FE9
05B3E:  MOVLW  00
05B40:  ADDWFC 03,W
05B42:  MOVWF  FEA
05B44:  CLRF   FEF
....................          if (!stricmp(InterruptUSB_Rxd,dbg)){ // if data from USB = debug, it will go into debug mode.
05B46:  MOVLB  6
05B48:  CLRF   x9F
05B4A:  MOVLW  2C
05B4C:  MOVWF  x9E
05B4E:  MOVLW  05
05B50:  MOVWF  xA1
05B52:  MOVLW  92
05B54:  MOVWF  xA0
05B56:  MOVLB  0
05B58:  CALL   49CE
05B5C:  MOVF   01,F
05B5E:  BNZ   5B80
....................             ledConfig(LED_GREEN);
05B60:  MOVLW  01
05B62:  MOVLB  6
05B64:  MOVWF  x9F
05B66:  MOVLB  0
05B68:  CALL   49A0
....................             fprintf(USB,"DEBUG MODE");
05B6C:  MOVLW  F2
05B6E:  MOVWF  FF6
05B70:  MOVLW  0E
05B72:  MOVWF  FF7
05B74:  MOVLW  00
05B76:  MOVWF  FF8
05B78:  CALL   0F40
....................             debugDetails();
05B7C:  BRA    552A
....................             //whilex=1;
....................             //debugMenu();
....................             //while(whilex==1){
....................             //if (debugDetails()){
....................                //whilex=0;
....................             //}   
....................          }
05B7E:  BRA    5BC4
....................          
....................          else if (!stricmp(InterruptUSB_Rxd,reset )){ // if data from USB = debug, it will go into debug mode.
05B80:  MOVLB  6
05B82:  CLRF   x9F
05B84:  MOVLW  2C
05B86:  MOVWF  x9E
05B88:  MOVLW  05
05B8A:  MOVWF  xA1
05B8C:  MOVLW  98
05B8E:  MOVWF  xA0
05B90:  MOVLB  0
05B92:  CALL   49CE
05B96:  MOVF   01,F
05B98:  BNZ   5BC4
....................             ledConfig(LED_GREEN);
05B9A:  MOVLW  01
05B9C:  MOVLB  6
05B9E:  MOVWF  x9F
05BA0:  MOVLB  0
05BA2:  CALL   49A0
....................             fprintf(USB,"Reset MCU\n");
05BA6:  MOVLW  FE
05BA8:  MOVWF  FF6
05BAA:  MOVLW  0E
05BAC:  MOVWF  FF7
05BAE:  MOVLW  00
05BB0:  MOVWF  FF8
05BB2:  CALL   0F40
....................             delay_ms(50);
05BB6:  MOVLW  32
05BB8:  MOVLB  7
05BBA:  MOVWF  x6D
05BBC:  MOVLB  0
05BBE:  CALL   0F16
....................             reset_cpu();
05BC2:  RESET
....................          }
....................          clear_InterruptUSB();
05BC4:  CALL   0F6E
....................       }
05BC8:  BRA    5C38
....................         
....................       else{ //nothing happens in otherwords no interrupts  
....................       
....................       if (SAMPLINGFLAG == TRUE){        
05BCA:  BTFSS  40.3
05BCC:  BRA    5BDA
....................          ledConfig(LED_GREEN);
05BCE:  MOVLW  01
05BD0:  MOVLB  6
05BD2:  MOVWF  x9F
05BD4:  MOVLB  0
05BD6:  CALL   49A0
....................                
....................          //readRtc(0);
....................          //getMcuDateTime();
....................          //SAMPLINGFLAG = FALSE;
....................       }
....................             
....................       if (SYNCFLAG==TRUE){                      
05BDA:  BTFSS  40.7
05BDC:  BRA    5BFE
....................          ledConfig(LED_GREEN);
05BDE:  MOVLW  01
05BE0:  MOVLB  6
05BE2:  MOVWF  x9F
05BE4:  MOVLB  0
05BE6:  CALL   49A0
....................          fprintf(USB,"Time Sync\n");
05BEA:  MOVLW  0A
05BEC:  MOVWF  FF6
05BEE:  MOVLW  0F
05BF0:  MOVWF  FF7
05BF2:  MOVLW  00
05BF4:  MOVWF  FF8
05BF6:  CALL   0F40
....................    
....................          rtc_acquire_sync();           // sync rtc datetime to both mcu and gsm 
05BFA:  RCALL  54BC
....................          SYNCFLAG = FALSE;             // two minutes before reaching the next hour, this will be activated      
05BFC:  BCF    40.7
....................       }
....................                
....................       if (RESETFLAG==TRUE){                      
05BFE:  MOVLB  4
05C00:  BTFSS  x8E.0
05C02:  BRA    5C14
....................          ledConfig(LED_GREEN);
05C04:  MOVLW  01
05C06:  MOVLB  6
05C08:  MOVWF  x9F
05C0A:  MOVLB  0
05C0C:  CALL   49A0
....................          //Thunder_Init();
....................          RESETFLAG=FALSE;
05C10:  MOVLB  4
05C12:  BCF    x8E.0
....................       }   
....................                
....................             
....................       ledToggle(LED_GREEN);
05C14:  MOVLW  01
05C16:  MOVLB  6
05C18:  MOVWF  x9E
05C1A:  MOVLB  0
05C1C:  BRA    5694
....................       delay_ms(500);                   
05C1E:  MOVLW  02
05C20:  MOVLB  6
05C22:  MOVWF  x9E
05C24:  MOVLW  FA
05C26:  MOVLB  7
05C28:  MOVWF  x6D
05C2A:  MOVLB  0
05C2C:  CALL   0F16
05C30:  MOVLB  6
05C32:  DECFSZ x9E,F
05C34:  BRA    5C24
05C36:  MOVLB  0
....................       }  
05C38:  BRA    5B1E
....................    }
.................... }  
.................... 
05C3A:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: 481D   VREGSLEEP INTRC_HP SOSC_HIGH NOXINST INTRC_IO NOPLLEN FCMEN NOIESO
   Word  2: 3E7E   PUT BROWNOUT BORV18 ZPBORM WDT_SW WDT32768
   Word  3: 8BF9   RTCOSC_T1 EXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
