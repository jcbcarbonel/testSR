CCS PCH C Compiler, Version 5.091, 49613               15-Aug-25 09:24

               Filename:   C:\Users\JohnCarloBCarbonel\testSR\BTD200\main.lst

               ROM used:   9046 bytes (7%)
                           Largest free fragment is 65536
               RAM used:   1440 (37%) at main() level
                           1624 (42%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

00000:  GOTO   1E02
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   0386
00068:  BTFSS  FF0.3
0006A:  GOTO   0074
0006E:  BTFSC  FF0.0
00070:  GOTO   022A
00074:  BTFSS  FF0.4
00076:  GOTO   0080
0007A:  BTFSC  FF0.1
0007C:  GOTO   0248
00080:  BTFSS  F9D.5
00082:  GOTO   008C
00086:  BTFSC  F9E.5
00088:  GOTO   0206
0008C:  BTFSS  FA3.5
0008E:  GOTO   0098
00092:  BTFSC  FA4.5
00094:  GOTO   01D2
00098:  MOVFF  0E,00
0009C:  MOVFF  0F,01
000A0:  MOVFF  10,02
000A4:  MOVFF  11,03
000A8:  MOVFF  0C,FE9
000AC:  MOVFF  07,FEA
000B0:  BSF    07.7
000B2:  MOVFF  08,FE1
000B6:  MOVFF  09,FE2
000BA:  MOVFF  0A,FD9
000BE:  MOVFF  0B,FDA
000C2:  MOVFF  12,FF3
000C6:  MOVFF  13,FF4
000CA:  MOVFF  14,FFA
000CE:  MOVFF  15,FF5
000D2:  MOVFF  16,FF6
000D6:  MOVFF  17,FF7
000DA:  MOVFF  18,FF8
000DE:  MOVFF  19,FFB
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
.................... //Author: Glenn Vincent Lopez
.................... //May 11, 2022
.................... 
.................... #include <18F87K22.h>
.................... //////////// Standard Header file for the PIC18F87K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F87K22
000EE:  CLRF   FF7
000F0:  ADDLW  02
000F2:  MOVWF  FF6
000F4:  MOVLW  01
000F6:  ADDWFC FF7,F
000F8:  MOVLW  00
000FA:  MOVWF  FF8
000FC:  TBLRD*+
000FE:  MOVF   FF5,W
00100:  RETURN 0
00102:  DATA 00,00
00104:  CLRF   FF7
00106:  ADDLW  18
00108:  MOVWF  FF6
0010A:  MOVLW  01
0010C:  ADDWFC FF7,F
0010E:  MOVLW  00
00110:  MOVWF  FF8
00112:  TBLRD*+
00114:  MOVF   FF5,W
00116:  RETURN 0
00118:  DATA 2F,2C
0011A:  DATA 3A,22
0011C:  DATA 00,00
0011E:  CLRF   FF7
00120:  ADDLW  32
00122:  MOVWF  FF6
00124:  MOVLW  01
00126:  ADDWFC FF7,F
00128:  MOVLW  00
0012A:  MOVWF  FF8
0012C:  TBLRD*+
0012E:  MOVF   FF5,W
00130:  RETURN 0
00132:  DATA 57,41
00134:  DATA 54,43
00136:  DATA 48,44
00138:  DATA 4F,47
0013A:  DATA 20,54
0013C:  DATA 49,4D
0013E:  DATA 45,4F
00140:  DATA 55,54
00142:  DATA 00,00
00144:  CLRF   FF7
00146:  ADDLW  58
00148:  MOVWF  FF6
0014A:  MOVLW  01
0014C:  ADDWFC FF7,F
0014E:  MOVLW  00
00150:  MOVWF  FF8
00152:  TBLRD*+
00154:  MOVF   FF5,W
00156:  RETURN 0
00158:  DATA 46,52
0015A:  DATA 45,53
0015C:  DATA 48,20
0015E:  DATA 50,4F
00160:  DATA 57,45
00162:  DATA 52,20
00164:  DATA 55,50
00166:  DATA 21,00
00168:  CLRF   FF7
0016A:  ADDLW  7C
0016C:  MOVWF  FF6
0016E:  MOVLW  01
00170:  ADDWFC FF7,F
00172:  MOVLW  00
00174:  MOVWF  FF8
00176:  TBLRD*+
00178:  MOVF   FF5,W
0017A:  RETURN 0
0017C:  DATA 53,4F
0017E:  DATA 46,54
00180:  DATA 57,41
00182:  DATA 52,45
00184:  DATA 20,52
00186:  DATA 45,53
00188:  DATA 45,54
0018A:  DATA 2D,00
0018C:  CLRF   FF7
0018E:  ADDLW  A0
00190:  MOVWF  FF6
00192:  MOVLW  01
00194:  ADDWFC FF7,F
00196:  MOVLW  00
00198:  MOVWF  FF8
0019A:  TBLRD*+
0019C:  MOVF   FF5,W
0019E:  RETURN 0
001A0:  DATA 48,41
001A2:  DATA 52,44
001A4:  DATA 57,41
001A6:  DATA 52,45
001A8:  DATA 20,52
001AA:  DATA 45,53
001AC:  DATA 45,54
001AE:  DATA 00,00
001B0:  CLRF   FF7
001B2:  ADDLW  C4
001B4:  MOVWF  FF6
001B6:  MOVLW  01
001B8:  ADDWFC FF7,F
001BA:  MOVLW  00
001BC:  MOVWF  FF8
001BE:  TBLRD*+
001C0:  MOVF   FF5,W
001C2:  RETURN 0
001C4:  DATA 36,33
001C6:  DATA 39,35
001C8:  DATA 36,34
001CA:  DATA 33,33
001CC:  DATA 34,39
001CE:  DATA 31,33
001D0:  DATA 00,00
*
00254:  DATA 69,6E
00256:  DATA 69,74
00258:  DATA 0D,00
0025A:  DATA 4C,54
0025C:  DATA 45,20
0025E:  DATA 49,6E
00260:  DATA 69,74
00262:  DATA 69,61
00264:  DATA 6C,69
00266:  DATA 7A,65
00268:  DATA 64,0A
0026A:  DATA 00,00
0026C:  DATA 73,69
0026E:  DATA 67,6E
00270:  DATA 61,6C
00272:  DATA 0D,00
00274:  DATA 0A,53
00276:  DATA 4D,53
00278:  DATA 20,53
0027A:  DATA 65,6E
0027C:  DATA 74,3A
0027E:  DATA 20,25
00280:  DATA 73,0A
00282:  DATA 00,00
00284:  DATA 4F,46
00286:  DATA 46,0D
00288:  DATA 00,00
0028A:  DATA 4F,4E
0028C:  DATA 0D,00
0028E:  DATA 69,67
00290:  DATA 74,0D
00292:  DATA 00,00
00294:  DATA 4C,54
00296:  DATA 45,20
00298:  DATA 49,67
0029A:  DATA 6E,69
0029C:  DATA 74,65
0029E:  DATA 64,0A
002A0:  DATA 00,00
002A2:  MOVLB  6
002A4:  MOVF   x54,W
002A6:  CLRF   01
002A8:  SUBWF  x53,W
002AA:  BC    02B2
002AC:  MOVFF  653,00
002B0:  BRA    02CA
002B2:  CLRF   00
002B4:  MOVLW  08
002B6:  MOVWF  x55
002B8:  RLCF   x53,F
002BA:  RLCF   00,F
002BC:  MOVF   x54,W
002BE:  SUBWF  00,W
002C0:  BTFSC  FD8.0
002C2:  MOVWF  00
002C4:  RLCF   01,F
002C6:  DECFSZ x55,F
002C8:  BRA    02B8
002CA:  MOVLB  0
002CC:  RETURN 0
002CE:  CLRF   01
002D0:  CLRF   02
002D2:  CLRF   00
002D4:  CLRF   03
002D6:  MOVLB  6
002D8:  MOVF   x56,W
002DA:  BNZ   02E0
002DC:  MOVF   x55,W
002DE:  BZ    0310
002E0:  MOVLW  10
002E2:  MOVWF  x57
002E4:  BCF    FD8.0
002E6:  RLCF   x53,F
002E8:  RLCF   x54,F
002EA:  RLCF   00,F
002EC:  RLCF   03,F
002EE:  MOVF   x56,W
002F0:  SUBWF  03,W
002F2:  BNZ   02F8
002F4:  MOVF   x55,W
002F6:  SUBWF  00,W
002F8:  BNC   0308
002FA:  MOVF   x55,W
002FC:  SUBWF  00,F
002FE:  BTFSS  FD8.0
00300:  DECF   03,F
00302:  MOVF   x56,W
00304:  SUBWF  03,F
00306:  BSF    FD8.0
00308:  RLCF   01,F
0030A:  RLCF   02,F
0030C:  DECFSZ x57,F
0030E:  BRA    02E4
00310:  MOVLB  0
00312:  GOTO   035E (RETURN)
*
00484:  DATA 52,54
00486:  DATA 43,20
00488:  DATA 64,61
0048A:  DATA 74,65
0048C:  DATA 20,61
0048E:  DATA 6E,64
00490:  DATA 20,74
00492:  DATA 69,6D
00494:  DATA 65,3A
00496:  DATA 20,25
00498:  DATA 73,0A
0049A:  DATA 00,00
0049C:  DATA 52,54
0049E:  DATA 43,20
004A0:  DATA 75,70
004A2:  DATA 64,61
004A4:  DATA 74,65
004A6:  DATA 64,0A
004A8:  DATA 00,00
004AA:  DATA 59,45
004AC:  DATA 41,52
004AE:  DATA 5F,50
004B0:  DATA 52,45
004B2:  DATA 56,3D
004B4:  DATA 25,69
004B6:  DATA 0A,00
004B8:  DATA 66,72
004BA:  DATA 6F,6D
004BC:  DATA 20,43
004BE:  DATA 4F,55
004C0:  DATA 4E,54
004C2:  DATA 45,52
004C4:  DATA 4E,45
004C6:  DATA 57,59
004C8:  DATA 45,41
004CA:  DATA 52,20
004CC:  DATA 3D,25
004CE:  DATA 73,0A
004D0:  DATA 00,00
004D2:  DATA 41,54
004D4:  DATA 2B,43
004D6:  DATA 43,4C
004D8:  DATA 4B,3D
004DA:  DATA 22,25
004DC:  DATA 73,22
004DE:  DATA 0D,00
004E0:  DATA 63,6C
004E2:  DATA 6F,63
004E4:  DATA 6B,20
004E6:  DATA 73,65
004E8:  DATA 74,0A
004EA:  DATA 00,00
004EC:  DATA 41,54
004EE:  DATA 2B,43
004F0:  DATA 43,4C
004F2:  DATA 4B,3F
004F4:  DATA 0D,00
004F6:  DATA 4D,43
004F8:  DATA 55,20
004FA:  DATA 63,6C
004FC:  DATA 6F,63
004FE:  DATA 6B,20
00500:  DATA 73,65
00502:  DATA 74,0A
00504:  DATA 00,00
00506:  DATA 4D,43
00508:  DATA 55,20
0050A:  DATA 64,61
0050C:  DATA 74,65
0050E:  DATA 20,61
00510:  DATA 6E,64
00512:  DATA 20,74
00514:  DATA 69,6D
00516:  DATA 65,3A
00518:  DATA 20,25
0051A:  DATA 73,0A
0051C:  DATA 00,00
0051E:  DATA 20,20
00520:  DATA 20,20
00522:  DATA 20,20
00524:  DATA 44,45
00526:  DATA 42,55
00528:  DATA 47,20
0052A:  DATA 4D,4F
0052C:  DATA 44,45
0052E:  DATA 20,4D
00530:  DATA 45,4E
00532:  DATA 55,0A
00534:  DATA 00,00
00536:  DATA 20,20
00538:  DATA 20,20
0053A:  DATA 20,20
0053C:  DATA 41,2E
0053E:  DATA 20,20
00540:  DATA 20,20
00542:  DATA 20,47
00544:  DATA 65,74
00546:  DATA 20,64
00548:  DATA 61,74
0054A:  DATA 61,20
0054C:  DATA 66,72
0054E:  DATA 6F,6D
00550:  DATA 20,74
00552:  DATA 68,65
00554:  DATA 20,73
00556:  DATA 65,6E
00558:  DATA 73,6F
0055A:  DATA 72,0A
0055C:  DATA 00,00
0055E:  DATA 20,20
00560:  DATA 20,20
00562:  DATA 20,20
00564:  DATA 42,2E
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,47
0056C:  DATA 65,74
0056E:  DATA 20,61
00570:  DATA 72,51
00572:  DATA 27,73
00574:  DATA 20,63
00576:  DATA 75,72
00578:  DATA 72,65
0057A:  DATA 6E,74
0057C:  DATA 20,63
0057E:  DATA 6F,6E
00580:  DATA 66,69
00582:  DATA 67,75
00584:  DATA 72,61
00586:  DATA 74,69
00588:  DATA 6F,6E
0058A:  DATA 73,0A
0058C:  DATA 00,00
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 20,20
00594:  DATA 43,2E
00596:  DATA 20,20
00598:  DATA 20,20
0059A:  DATA 20,44
0059C:  DATA 69,73
0059E:  DATA 70,6C
005A0:  DATA 61,79
005A2:  DATA 20,44
005A4:  DATA 45,42
005A6:  DATA 55,47
005A8:  DATA 20,6D
005AA:  DATA 65,6E
005AC:  DATA 75,0A
005AE:  DATA 00,00
005B0:  DATA 20,20
005B2:  DATA 20,20
005B4:  DATA 20,20
005B6:  DATA 44,2E
005B8:  DATA 20,20
005BA:  DATA 20,20
005BC:  DATA 20,43
005BE:  DATA 68,61
005C0:  DATA 6E,67
005C2:  DATA 65,20
005C4:  DATA 73,65
005C6:  DATA 6E,64
005C8:  DATA 69,6E
005CA:  DATA 67,20
005CC:  DATA 74,69
005CE:  DATA 6D,65
005D0:  DATA 0A,00
005D2:  DATA 20,20
005D4:  DATA 20,20
005D6:  DATA 20,20
005D8:  DATA 45,2E
005DA:  DATA 20,20
005DC:  DATA 20,20
005DE:  DATA 20,43
005E0:  DATA 68,65
005E2:  DATA 63,6B
005E4:  DATA 20,73
005E6:  DATA 61,74
005E8:  DATA 65,6C
005EA:  DATA 6C,69
005EC:  DATA 74,65
005EE:  DATA 20,73
005F0:  DATA 65,6E
005F2:  DATA 64,69
005F4:  DATA 6E,67
005F6:  DATA 0A,00
005F8:  DATA 20,20
005FA:  DATA 20,20
005FC:  DATA 20,20
005FE:  DATA 46,2E
00600:  DATA 20,20
00602:  DATA 20,20
00604:  DATA 20,53
00606:  DATA 65,74
00608:  DATA 20,73
0060A:  DATA 65,72
0060C:  DATA 76,65
0060E:  DATA 72,20
00610:  DATA 6E,75
00612:  DATA 6D,62
00614:  DATA 65,72
00616:  DATA 0A,00
00618:  DATA 20,20
0061A:  DATA 20,20
0061C:  DATA 20,20
0061E:  DATA 47,2E
00620:  DATA 20,20
00622:  DATA 20,20
00624:  DATA 20,4C
00626:  DATA 69,73
00628:  DATA 74,20
0062A:  DATA 72,65
0062C:  DATA 67,69
0062E:  DATA 73,74
00630:  DATA 65,72
00632:  DATA 65,64
00634:  DATA 20,6E
00636:  DATA 75,6D
00638:  DATA 62,65
0063A:  DATA 72,73
0063C:  DATA 0A,00
0063E:  DATA 20,20
00640:  DATA 20,20
00642:  DATA 20,20
00644:  DATA 48,2E
00646:  DATA 20,20
00648:  DATA 20,20
0064A:  DATA 20,47
0064C:  DATA 65,6E
0064E:  DATA 65,72
00650:  DATA 61,74
00652:  DATA 65,20
00654:  DATA 43,52
00656:  DATA 43,20
00658:  DATA 63,6F
0065A:  DATA 64,65
0065C:  DATA 0A,00
0065E:  DATA 20,20
00660:  DATA 20,20
00662:  DATA 20,20
00664:  DATA 49,2E
00666:  DATA 20,20
00668:  DATA 20,20
0066A:  DATA 20,53
0066C:  DATA 65,74
0066E:  DATA 20,64
00670:  DATA 61,74
00672:  DATA 65,20
00674:  DATA 61,6E
00676:  DATA 64,20
00678:  DATA 74,69
0067A:  DATA 6D,65
0067C:  DATA 0A,00
0067E:  DATA 20,20
00680:  DATA 20,20
00682:  DATA 20,20
00684:  DATA 4A,2E
00686:  DATA 20,20
00688:  DATA 20,20
0068A:  DATA 20,53
0068C:  DATA 65,74
0068E:  DATA 20,70
00690:  DATA 6F,77
00692:  DATA 65,72
00694:  DATA 20,62
00696:  DATA 6F,61
00698:  DATA 72,64
0069A:  DATA 20,63
0069C:  DATA 6F,6E
0069E:  DATA 66,69
006A0:  DATA 67,75
006A2:  DATA 72,61
006A4:  DATA 74,69
006A6:  DATA 6F,6E
006A8:  DATA 0A,00
006AA:  DATA 20,20
006AC:  DATA 20,20
006AE:  DATA 20,20
006B0:  DATA 4C,2E
006B2:  DATA 20,20
006B4:  DATA 20,20
006B6:  DATA 20,44
006B8:  DATA 6F,77
006BA:  DATA 6E,6C
006BC:  DATA 6F,61
006BE:  DATA 64,20
006C0:  DATA 64,61
006C2:  DATA 74,61
006C4:  DATA 20,66
006C6:  DATA 72,6F
006C8:  DATA 6D,20
006CA:  DATA 66,6C
006CC:  DATA 61,73
006CE:  DATA 68,20
006D0:  DATA 6D,65
006D2:  DATA 6D,6F
006D4:  DATA 72,79
006D6:  DATA 0A,00
006D8:  DATA 20,20
006DA:  DATA 20,20
006DC:  DATA 20,20
006DE:  DATA 4D,2E
006E0:  DATA 20,20
006E2:  DATA 20,20
006E4:  DATA 20,43
006E6:  DATA 68,61
006E8:  DATA 6E,67
006EA:  DATA 65,20
006EC:  DATA 70,61
006EE:  DATA 73,73
006F0:  DATA 77,6F
006F2:  DATA 72,64
006F4:  DATA 0A,00
006F6:  DATA 20,20
006F8:  DATA 20,20
006FA:  DATA 20,20
006FC:  DATA 4E,2E
006FE:  DATA 20,20
00700:  DATA 20,20
00702:  DATA 20,45
00704:  DATA 6E,61
00706:  DATA 62,6C
00708:  DATA 65,20
0070A:  DATA 73,61
0070C:  DATA 74,65
0070E:  DATA 6C,6C
00710:  DATA 69,74
00712:  DATA 65,0A
00714:  DATA 00,00
00716:  DATA 20,20
00718:  DATA 20,20
0071A:  DATA 20,20
0071C:  DATA 4F,2E
0071E:  DATA 20,20
00720:  DATA 20,20
00722:  DATA 20,53
00724:  DATA 65,74
00726:  DATA 20,74
00728:  DATA 68,65
0072A:  DATA 20,73
0072C:  DATA 65,6E
0072E:  DATA 73,6F
00730:  DATA 72,20
00732:  DATA 74,79
00734:  DATA 70,65
00736:  DATA 0A,00
00738:  DATA 20,20
0073A:  DATA 20,20
0073C:  DATA 20,20
0073E:  DATA 51,2E
00740:  DATA 20,20
00742:  DATA 20,20
00744:  DATA 54,65
00746:  DATA 73,74
00748:  DATA 20,49
0074A:  DATA 72,69
0074C:  DATA 64,69
0074E:  DATA 75,6D
00750:  DATA 20,73
00752:  DATA 61,74
00754:  DATA 65,6C
00756:  DATA 6C,69
00758:  DATA 74,65
0075A:  DATA 20,63
0075C:  DATA 6F,6D
0075E:  DATA 6D,61
00760:  DATA 6E,64
00762:  DATA 73,0A
00764:  DATA 00,00
00766:  DATA 20,20
00768:  DATA 20,20
0076A:  DATA 20,20
0076C:  DATA 53,2E
0076E:  DATA 20,20
00770:  DATA 20,20
00772:  DATA 20,54
00774:  DATA 75,72
00776:  DATA 6E,20
00778:  DATA 6F,66
0077A:  DATA 66,20
0077C:  DATA 77,61
0077E:  DATA 74,63
00780:  DATA 68,64
00782:  DATA 6F,67
00784:  DATA 0A,00
00786:  DATA 20,20
00788:  DATA 20,20
0078A:  DATA 20,20
0078C:  DATA 57,2E
0078E:  DATA 20,20
00790:  DATA 20,20
00792:  DATA 20,45
00794:  DATA 78,69
00796:  DATA 74,20
00798:  DATA 44,45
0079A:  DATA 42,55
0079C:  DATA 47,20
0079E:  DATA 6D,6F
007A0:  DATA 64,65
007A2:  DATA 0A,00
007A4:  DATA 20,20
007A6:  DATA 20,20
007A8:  DATA 20,20
007AA:  DATA 58,2E
007AC:  DATA 20,20
007AE:  DATA 20,20
007B0:  DATA 20,44
007B2:  DATA 65,6C
007B4:  DATA 65,74
007B6:  DATA 65,20
007B8:  DATA 72,65
007BA:  DATA 67,69
007BC:  DATA 73,74
007BE:  DATA 65,72
007C0:  DATA 65,64
007C2:  DATA 20,6E
007C4:  DATA 75,6D
007C6:  DATA 62,65
007C8:  DATA 72,0A
007CA:  DATA 00,00
007CC:  DATA 20,20
007CE:  DATA 20,20
007D0:  DATA 20,20
007D2:  DATA 61,2E
007D4:  DATA 20,20
007D6:  DATA 20,20
007D8:  DATA 20,52
007DA:  DATA 65,67
007DC:  DATA 69,73
007DE:  DATA 74,65
007E0:  DATA 72,20
007E2:  DATA 6E,75
007E4:  DATA 6D,62
007E6:  DATA 65,72
007E8:  DATA 0A,00
007EA:  DATA 0A,45
007EC:  DATA 6E,74
007EE:  DATA 65,72
007F0:  DATA 20,43
007F2:  DATA 68,6F
007F4:  DATA 69,63
007F6:  DATA 65,3A
007F8:  DATA 0A,00
007FA:  DATA 50,72
007FC:  DATA 65,73
007FE:  DATA 73,20
00800:  DATA 43,20
00802:  DATA 74,6F
00804:  DATA 20,63
00806:  DATA 68,61
00808:  DATA 6E,67
0080A:  DATA 65,0A
0080C:  DATA 00,00
0080E:  DATA 45,6E
00810:  DATA 74,65
00812:  DATA 72,20
00814:  DATA 44,61
00816:  DATA 74,65
00818:  DATA 20,61
0081A:  DATA 6E,64
0081C:  DATA 20,54
0081E:  DATA 69,6D
00820:  DATA 65,20
00822:  DATA 28,46
00824:  DATA 4F,52
00826:  DATA 4D,41
00828:  DATA 54,20
0082A:  DATA 22,59
0082C:  DATA 59,2F
0082E:  DATA 4D,4D
00830:  DATA 2F,44
00832:  DATA 44,2C
00834:  DATA 48,48
00836:  DATA 3A,4D
00838:  DATA 4D,3A
0083A:  DATA 53,53
0083C:  DATA 22,29
0083E:  DATA 00,00
00840:  DATA 50,6C
00842:  DATA 65,61
00844:  DATA 73,65
00846:  DATA 20,63
00848:  DATA 68,6F
0084A:  DATA 6F,73
0084C:  DATA 65,20
0084E:  DATA 61,6E
00850:  DATA 6F,74
00852:  DATA 68,65
00854:  DATA 72,20
00856:  DATA 6C,65
00858:  DATA 74,74
0085A:  DATA 65,72
0085C:  DATA 20,66
0085E:  DATA 72,6F
00860:  DATA 6D,20
00862:  DATA 74,68
00864:  DATA 65,20
00866:  DATA 44,45
00868:  DATA 42,55
0086A:  DATA 47,20
0086C:  DATA 6D,65
0086E:  DATA 6E,75
00870:  DATA 0A,00
00872:  DATA 4F,54
00874:  DATA 48,45
00876:  DATA 52,20
00878:  DATA 52,45
0087A:  DATA 53,45
0087C:  DATA 54,20
0087E:  DATA 43,41
00880:  DATA 55,53
00882:  DATA 45,20
00884:  DATA 28,25
00886:  DATA 69,29
00888:  DATA 00,00
0088A:  DATA 25,73
0088C:  DATA 20,2D
0088E:  DATA 20,25
00890:  DATA 73,00
00892:  DATA 0A,2A
00894:  DATA 2A,2A
00896:  DATA 2A,2A
00898:  DATA 2A,2A
0089A:  DATA 2A,2A
0089C:  DATA 2A,2A
0089E:  DATA 2A,2A
008A0:  DATA 2A,2A
008A2:  DATA 2A,2A
008A4:  DATA 2A,2A
008A6:  DATA 2A,2A
008A8:  DATA 2A,2A
008AA:  DATA 2A,2A
008AC:  DATA 2A,2A
008AE:  DATA 2A,2A
008B0:  DATA 2A,2A
008B2:  DATA 2A,2A
008B4:  DATA 2A,2A
008B6:  DATA 2A,2A
008B8:  DATA 2A,2A
008BA:  DATA 2A,2A
008BC:  DATA 2A,2A
008BE:  DATA 2A,2A
008C0:  DATA 2A,2A
008C2:  DATA 2A,2A
008C4:  DATA 0A,00
008C6:  DATA 55,4C
008C8:  DATA 41,54
008CA:  DATA 20,4C
008CC:  DATA 69,67
008CE:  DATA 68,74
008D0:  DATA 6E,69
008D2:  DATA 6E,67
008D4:  DATA 20,4D
008D6:  DATA 6F,6E
008D8:  DATA 69,74
008DA:  DATA 6F,72
008DC:  DATA 69,6E
008DE:  DATA 67,20
008E0:  DATA 53,74
008E2:  DATA 61,74
008E4:  DATA 69,6F
008E6:  DATA 6E,20
008E8:  DATA 28,42
008EA:  DATA 65,74
008EC:  DATA 61,20
008EE:  DATA 76,65
008F0:  DATA 72,73
008F2:  DATA 69,6F
008F4:  DATA 6E,29
008F6:  DATA 0A,00
008F8:  DATA 0A,49
008FA:  DATA 6E,69
008FC:  DATA 74,69
008FE:  DATA 61,6C
00900:  DATA 69,7A
00902:  DATA 69,6E
00904:  DATA 67,20
00906:  DATA 42,54
00908:  DATA 44,32
0090A:  DATA 30,30
0090C:  DATA 0A,00
0090E:  DATA 44,45
00910:  DATA 42,55
00912:  DATA 47,20
00914:  DATA 4D,4F
00916:  DATA 44,45
00918:  DATA 00,00
0091A:  DATA 52,65
0091C:  DATA 73,65
0091E:  DATA 74,20
00920:  DATA 4D,43
00922:  DATA 55,0A
00924:  DATA 00,00
00926:  DATA 54,69
00928:  DATA 6D,65
0092A:  DATA 20,53
0092C:  DATA 79,6E
0092E:  DATA 63,0A
00930:  DATA 00,00
*
0095C:  TBLRD*+
0095E:  MOVF   FF5,F
00960:  BZ    0988
00962:  MOVFF  FF6,63F
00966:  MOVFF  FF7,640
0096A:  MOVFF  FF8,641
0096E:  MOVF   FF5,W
00970:  BTFSS  FA4.4
00972:  BRA    0970
00974:  MOVLB  F
00976:  MOVWF  x1C
00978:  MOVFF  63F,FF6
0097C:  MOVFF  640,FF7
00980:  MOVFF  641,FF8
00984:  MOVLB  0
00986:  BRA    095C
00988:  RETURN 0
*
009A8:  MOVFF  490,FEA
009AC:  MOVFF  48F,FE9
009B0:  MOVLB  6
009B2:  MOVFF  64A,FEF
009B6:  INCF   FE9,F
009B8:  BTFSC  FD8.2
009BA:  INCF   FEA,F
009BC:  CLRF   FEF
009BE:  MOVLB  4
009C0:  INCF   x8F,F
009C2:  BTFSC  FD8.2
009C4:  INCF   x90,F
009C6:  MOVLB  0
009C8:  RETURN 0
009CA:  TBLRD*+
009CC:  MOVFF  FF6,5DC
009D0:  MOVFF  FF7,5DD
009D4:  MOVFF  FF8,5DE
009D8:  MOVFF  FF5,64A
009DC:  RCALL  09A8
009DE:  MOVFF  5DC,FF6
009E2:  MOVFF  5DD,FF7
009E6:  MOVFF  5DE,FF8
009EA:  MOVLB  5
009EC:  DECFSZ xDB,F
009EE:  BRA    09F2
009F0:  BRA    09F6
009F2:  MOVLB  0
009F4:  BRA    09CA
009F6:  MOVLB  0
009F8:  RETURN 0
009FA:  MOVLW  20
009FC:  MOVLB  6
009FE:  BTFSS  x2B.4
00A00:  MOVLW  30
00A02:  MOVWF  x2C
00A04:  MOVFF  62A,00
00A08:  BTFSS  00.7
00A0A:  BRA    0A1C
00A0C:  COMF   00,F
00A0E:  INCF   00,F
00A10:  MOVFF  00,62A
00A14:  MOVLW  2D
00A16:  MOVWF  x2C
00A18:  BSF    x2B.7
00A1A:  BSF    x2B.0
00A1C:  MOVF   01,W
00A1E:  CLRF   1B
00A20:  BTFSC  FF2.7
00A22:  BSF    1B.7
00A24:  BCF    FF2.7
00A26:  MOVFF  62A,653
00A2A:  MOVLW  64
00A2C:  MOVWF  x54
00A2E:  MOVLB  0
00A30:  RCALL  02A2
00A32:  BTFSC  1B.7
00A34:  BSF    FF2.7
00A36:  MOVFF  00,62A
00A3A:  MOVLW  30
00A3C:  ADDWF  01,W
00A3E:  MOVLB  6
00A40:  MOVWF  x2D
00A42:  CLRF   1B
00A44:  BTFSC  FF2.7
00A46:  BSF    1B.7
00A48:  BCF    FF2.7
00A4A:  MOVFF  62A,653
00A4E:  MOVLW  0A
00A50:  MOVWF  x54
00A52:  MOVLB  0
00A54:  RCALL  02A2
00A56:  BTFSC  1B.7
00A58:  BSF    FF2.7
00A5A:  MOVLW  30
00A5C:  ADDWF  00,W
00A5E:  MOVLB  6
00A60:  MOVWF  x2F
00A62:  MOVLW  30
00A64:  ADDWF  01,W
00A66:  MOVWF  x2E
00A68:  MOVFF  62C,00
00A6C:  MOVLW  30
00A6E:  SUBWF  x2D,W
00A70:  BZ    0A7A
00A72:  BSF    x2B.1
00A74:  BTFSC  x2B.7
00A76:  BSF    x2B.2
00A78:  BRA    0A9E
00A7A:  MOVFF  62C,62D
00A7E:  MOVLW  20
00A80:  MOVWF  x2C
00A82:  MOVLW  30
00A84:  SUBWF  x2E,W
00A86:  BZ    0A90
00A88:  BSF    x2B.0
00A8A:  BTFSC  x2B.7
00A8C:  BSF    x2B.1
00A8E:  BRA    0A9E
00A90:  BTFSS  FD8.2
00A92:  BSF    x2B.0
00A94:  BNZ   0A9E
00A96:  MOVFF  62D,62E
00A9A:  MOVLW  20
00A9C:  MOVWF  x2D
00A9E:  BTFSC  x2B.2
00AA0:  BRA    0AAC
00AA2:  BTFSC  x2B.1
00AA4:  BRA    0AB4
00AA6:  BTFSC  x2B.0
00AA8:  BRA    0ABC
00AAA:  BRA    0AC4
00AAC:  MOVFF  62C,64A
00AB0:  MOVLB  0
00AB2:  RCALL  09A8
00AB4:  MOVFF  62D,64A
00AB8:  MOVLB  0
00ABA:  RCALL  09A8
00ABC:  MOVFF  62E,64A
00AC0:  MOVLB  0
00AC2:  RCALL  09A8
00AC4:  MOVFF  62F,64A
00AC8:  MOVLB  0
00ACA:  RCALL  09A8
00ACC:  RETURN 0
00ACE:  MOVF   FEF,F
00AD0:  BZ    0AF6
00AD2:  MOVFF  FEA,649
00AD6:  MOVFF  FE9,648
00ADA:  MOVF   FEF,W
00ADC:  BTFSS  FA4.4
00ADE:  BRA    0ADC
00AE0:  MOVLB  F
00AE2:  MOVWF  x1C
00AE4:  MOVFF  649,FEA
00AE8:  MOVFF  648,FE9
00AEC:  INCF   FE9,F
00AEE:  BTFSC  FD8.2
00AF0:  INCF   FEA,F
00AF2:  MOVLB  0
00AF4:  BRA    0ACE
00AF6:  RETURN 0
*
00D3A:  MOVF   FEF,F
00D3C:  BZ    0D5C
00D3E:  MOVFF  FEA,5DC
00D42:  MOVFF  FE9,5DB
00D46:  MOVFF  FEF,64A
00D4A:  RCALL  09A8
00D4C:  MOVFF  5DC,FEA
00D50:  MOVFF  5DB,FE9
00D54:  INCF   FE9,F
00D56:  BTFSC  FD8.2
00D58:  INCF   FEA,F
00D5A:  BRA    0D3A
00D5C:  RETURN 0
*
011DC:  CLRF   00
011DE:  CLRF   01
011E0:  MOVLB  6
011E2:  MOVF   x46,W
011E4:  BCF    FD8.0
011E6:  BTFSC  x47.0
011E8:  ADDWF  00,F
011EA:  RRCF   00,F
011EC:  RRCF   01,F
011EE:  BTFSC  x47.1
011F0:  ADDWF  00,F
011F2:  RRCF   00,F
011F4:  RRCF   01,F
011F6:  BTFSC  x47.2
011F8:  ADDWF  00,F
011FA:  RRCF   00,F
011FC:  RRCF   01,F
011FE:  BTFSC  x47.3
01200:  ADDWF  00,F
01202:  RRCF   00,F
01204:  RRCF   01,F
01206:  BTFSC  x47.4
01208:  ADDWF  00,F
0120A:  RRCF   00,F
0120C:  RRCF   01,F
0120E:  BTFSC  x47.5
01210:  ADDWF  00,F
01212:  RRCF   00,F
01214:  RRCF   01,F
01216:  BTFSC  x47.6
01218:  ADDWF  00,F
0121A:  RRCF   00,F
0121C:  RRCF   01,F
0121E:  BTFSC  x47.7
01220:  ADDWF  00,F
01222:  RRCF   00,F
01224:  RRCF   01,F
01226:  MOVLB  0
01228:  GOTO   12FC (RETURN)
*
01734:  MOVF   01,W
01736:  CLRF   1B
01738:  BTFSC  FF2.7
0173A:  BSF    1B.7
0173C:  BCF    FF2.7
0173E:  MOVFF  648,653
01742:  MOVLW  64
01744:  MOVLB  6
01746:  MOVWF  x54
01748:  MOVLB  0
0174A:  CALL   02A2
0174E:  BTFSC  1B.7
01750:  BSF    FF2.7
01752:  MOVFF  00,648
01756:  MOVF   01,W
01758:  MOVLW  30
0175A:  BNZ   176C
0175C:  MOVLB  6
0175E:  BTFSS  x49.1
01760:  BRA    1782
01762:  BTFSC  x49.3
01764:  BRA    1782
01766:  BTFSC  x49.4
01768:  MOVLW  20
0176A:  BRA    1774
0176C:  MOVLB  6
0176E:  BCF    x49.3
01770:  BCF    x49.4
01772:  BSF    x49.0
01774:  ADDWF  01,F
01776:  MOVFF  01,64A
0177A:  MOVLB  0
0177C:  CALL   09A8
01780:  MOVLB  6
01782:  CLRF   1B
01784:  BTFSC  FF2.7
01786:  BSF    1B.7
01788:  BCF    FF2.7
0178A:  MOVFF  648,653
0178E:  MOVLW  0A
01790:  MOVWF  x54
01792:  MOVLB  0
01794:  CALL   02A2
01798:  BTFSC  1B.7
0179A:  BSF    FF2.7
0179C:  MOVFF  00,648
017A0:  MOVF   01,W
017A2:  MOVLW  30
017A4:  BNZ   17B6
017A6:  MOVLB  6
017A8:  BTFSC  x49.3
017AA:  BRA    17C2
017AC:  BTFSS  x49.0
017AE:  BRA    17C2
017B0:  BTFSC  x49.4
017B2:  MOVLW  20
017B4:  MOVLB  0
017B6:  ADDWF  01,F
017B8:  MOVFF  01,64A
017BC:  CALL   09A8
017C0:  MOVLB  6
017C2:  MOVLW  30
017C4:  ADDWF  x48,F
017C6:  MOVFF  648,64A
017CA:  MOVLB  0
017CC:  CALL   09A8
017D0:  RETURN 0
017D2:  TBLRD*+
017D4:  MOVFF  FF6,649
017D8:  MOVFF  FF7,64A
017DC:  MOVFF  FF8,64B
017E0:  MOVF   FF5,W
017E2:  BTFSS  FA4.4
017E4:  BRA    17E2
017E6:  MOVLB  F
017E8:  MOVWF  x1C
017EA:  MOVFF  649,FF6
017EE:  MOVFF  64A,FF7
017F2:  MOVFF  64B,FF8
017F6:  MOVLB  6
017F8:  DECFSZ x48,F
017FA:  BRA    17FE
017FC:  BRA    1802
017FE:  MOVLB  0
01800:  BRA    17D2
01802:  MOVLB  0
01804:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device adc=12
.................... #FUSES WDT_SW, WDT32768, INTRC_IO, SOSC_HIGH, NOPROTECT, NOIESO, BROWNOUT, PUT, NOCPD, STVREN, NODEBUG, NOWRT, NOWRTD, NOEBTR, NOCPB, NOEBTRB, NOWRTC, NOWRTB, FCMEN, NOXINST, MCLR, RTCOSC_T1
.................... #use delay(clock=16000000)
*
00932:  MOVLW  06
00934:  MOVWF  FEA
00936:  MOVLW  3F
00938:  MOVWF  FE9
0093A:  MOVF   FEF,W
0093C:  BZ    095A
0093E:  MOVLW  05
00940:  MOVWF  01
00942:  CLRF   00
00944:  DECFSZ 00,F
00946:  BRA    0944
00948:  DECFSZ 01,F
0094A:  BRA    0942
0094C:  MOVLW  2E
0094E:  MOVWF  00
00950:  DECFSZ 00,F
00952:  BRA    0950
00954:  BRA    0956
00956:  DECFSZ FEF,F
00958:  BRA    093E
0095A:  RETURN 0
.................... 
.................... #use spi(MASTER, FORCE_HW, SPI1, MODE=1, BITS=8)
.................... #use i2c(MASTER, sda=PIN_D5, scl=PIN_D6)
*
0140A:  BCF    F67.7
0140C:  BCF    FA1.5
0140E:  MOVFF  648,F6A
01412:  MOVLW  02
01414:  BTFSC  F67.7
01416:  BRA    1422
01418:  BTFSS  FA1.5
0141A:  BRA    1418
0141C:  MOVLW  00
0141E:  BTFSC  F66.6
01420:  MOVLW  01
01422:  MOVWF  01
01424:  RETURN 0
*
016F8:  BCF    F67.6
016FA:  BSF    F66.3
016FC:  BTFSC  F66.3
016FE:  BRA    16FC
01700:  BTFSC  00.0
01702:  BCF    F66.5
01704:  BTFSS  00.0
01706:  BSF    F66.5
01708:  BSF    F66.4
0170A:  BTFSC  F66.4
0170C:  BRA    170A
0170E:  MOVFF  F6A,01
01712:  GOTO   1892 (RETURN)
.................... 
.................... //#use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT2)
.................... #use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT1)
.................... 
.................... #use rs232(baud=57600, xmit=PIN_G4, rcv=PIN_G3, stream=RS232_BTD200)
.................... #use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=GSM)
.................... //!#use rs232(baud=57600, xmit=TX_B, rcv=RX_B, stream=RS232_BTD200)
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+3);
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
00B44:  MOVFF  62A,62E
00B48:  MOVFF  629,62D
00B4C:  MOVFF  62E,FEA
00B50:  MOVLB  6
00B52:  MOVFF  62D,FE9
00B56:  MOVF   FEF,F
00B58:  BZ    0B66
00B5A:  INCF   x2D,F
00B5C:  BTFSC  FD8.2
00B5E:  INCF   x2E,F
00B60:  MOVLB  0
00B62:  BRA    0B4C
00B64:  MOVLB  6
....................    while(*s2 != '\0')
00B66:  MOVFF  62C,FEA
00B6A:  MOVFF  62B,FE9
00B6E:  MOVF   FEF,F
00B70:  BZ    0B98
....................    {
....................       *s = *s2;
00B72:  MOVFF  62C,FEA
00B76:  MOVFF  62B,FE9
00B7A:  MOVFF  FEF,631
00B7E:  MOVFF  62E,FEA
00B82:  MOVFF  62D,FE9
00B86:  MOVFF  631,FEF
....................       ++s;
00B8A:  INCF   x2D,F
00B8C:  BTFSC  FD8.2
00B8E:  INCF   x2E,F
....................       ++s2;
00B90:  INCF   x2B,F
00B92:  BTFSC  FD8.2
00B94:  INCF   x2C,F
00B96:  BRA    0B66
....................    }
.................... 
....................    *s = '\0';
00B98:  MOVFF  62E,FEA
00B9C:  MOVFF  62D,FE9
00BA0:  CLRF   FEF
....................    return(s1);
00BA2:  MOVFF  629,01
00BA6:  MOVFF  62A,02
00BAA:  MOVLB  0
00BAC:  RETURN 0
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
00BAE:  MOVFF  628,62E
00BB2:  MOVFF  627,62D
00BB6:  MOVFF  62E,FEA
00BBA:  MOVLB  6
00BBC:  MOVFF  62D,FE9
00BC0:  MOVF   FEF,F
00BC2:  BZ    0BD0
00BC4:  INCF   x2D,F
00BC6:  BTFSC  FD8.2
00BC8:  INCF   x2E,F
00BCA:  MOVLB  0
00BCC:  BRA    0BB6
00BCE:  MOVLB  6
....................    while(*s2 != '\0' && 0<n)
00BD0:  MOVFF  62A,FEA
00BD4:  MOVFF  629,FE9
00BD8:  MOVF   FEF,F
00BDA:  BZ    0C14
00BDC:  MOVF   x2C,F
00BDE:  BNZ   0BE6
00BE0:  MOVF   x2B,W
00BE2:  SUBLW  00
00BE4:  BC    0C14
....................    {
....................       *s = *s2;
00BE6:  MOVFF  62A,FEA
00BEA:  MOVFF  629,FE9
00BEE:  MOVFF  FEF,631
00BF2:  MOVFF  62E,FEA
00BF6:  MOVFF  62D,FE9
00BFA:  MOVFF  631,FEF
....................       ++s;
00BFE:  INCF   x2D,F
00C00:  BTFSC  FD8.2
00C02:  INCF   x2E,F
....................       ++s2;
00C04:  INCF   x29,F
00C06:  BTFSC  FD8.2
00C08:  INCF   x2A,F
....................       --n;
00C0A:  MOVF   x2B,W
00C0C:  BTFSC  FD8.2
00C0E:  DECF   x2C,F
00C10:  DECF   x2B,F
00C12:  BRA    0BD0
....................    }
.................... 
....................    *s = '\0';
00C14:  MOVFF  62E,FEA
00C18:  MOVFF  62D,FE9
00C1C:  CLRF   FEF
....................    return(s1);
00C1E:  MOVFF  627,01
00C22:  MOVFF  628,02
00C26:  MOVLB  0
00C28:  GOTO   0CC4 (RETURN)
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
0107C:  MOVFF  648,64C
01080:  MOVFF  647,64B
01084:  MOVFF  64C,FEA
01088:  MOVLB  6
0108A:  MOVFF  64B,FE9
0108E:  MOVF   FEF,F
01090:  BZ    10E2
....................       for (sc2 = s2; *sc2 != 0; sc2++)
01092:  MOVFF  64A,64E
01096:  MOVFF  649,64D
0109A:  MOVFF  64E,FEA
0109E:  MOVFF  64D,FE9
010A2:  MOVF   FEF,F
010A4:  BZ    10D6
....................          if (*sc1 == *sc2)
010A6:  MOVFF  64C,03
010AA:  MOVFF  64B,FE9
010AE:  MOVFF  03,FEA
010B2:  MOVFF  FEF,64F
010B6:  MOVFF  64E,FEA
010BA:  MOVFF  64D,FE9
010BE:  MOVF   FEF,W
010C0:  SUBWF  x4F,W
010C2:  BNZ   10CE
....................             return(sc1);
010C4:  MOVFF  64B,01
010C8:  MOVFF  64C,02
010CC:  BRA    10E8
010CE:  INCF   x4D,F
010D0:  BTFSC  FD8.2
010D2:  INCF   x4E,F
010D4:  BRA    109A
010D6:  INCF   x4B,F
010D8:  BTFSC  FD8.2
010DA:  INCF   x4C,F
010DC:  MOVLB  0
010DE:  BRA    1084
010E0:  MOVLB  6
....................    return(0);
010E2:  MOVLW  00
010E4:  MOVWF  01
010E6:  MOVWF  02
010E8:  MOVLB  0
010EA:  GOTO   118A (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
00FF4:  MOVFF  648,64C
00FF8:  MOVFF  647,64B
00FFC:  MOVFF  64C,FEA
01000:  MOVLB  6
01002:  MOVFF  64B,FE9
01006:  MOVF   FEF,F
01008:  BZ    1064
....................       for (sc2 = s2; ; sc2++)
0100A:  MOVFF  64A,64E
0100E:  MOVFF  649,64D
....................     if (*sc2 == '\0')
01012:  MOVFF  64E,FEA
01016:  MOVFF  64D,FE9
0101A:  MOVF   FEF,F
0101C:  BNZ   1034
....................        return(sc1 - s1);
0101E:  MOVF   x47,W
01020:  SUBWF  x4B,W
01022:  MOVWF  00
01024:  MOVF   x48,W
01026:  SUBWFB x4C,W
01028:  MOVWF  03
0102A:  MOVFF  00,01
0102E:  MOVWF  02
01030:  BRA    1076
01032:  BRA    1050
....................          else if (*sc1 == *sc2)
01034:  MOVFF  64C,FEA
01038:  MOVFF  64B,FE9
0103C:  MOVFF  FEF,64F
01040:  MOVFF  64E,FEA
01044:  MOVFF  64D,FE9
01048:  MOVF   FEF,W
0104A:  SUBWF  x4F,W
0104C:  BNZ   1050
....................             break;
0104E:  BRA    1058
01050:  INCF   x4D,F
01052:  BTFSC  FD8.2
01054:  INCF   x4E,F
01056:  BRA    1012
01058:  INCF   x4B,F
0105A:  BTFSC  FD8.2
0105C:  INCF   x4C,F
0105E:  MOVLB  0
01060:  BRA    0FFC
01062:  MOVLB  6
....................    return(sc1 - s1);
01064:  MOVF   x47,W
01066:  SUBWF  x4B,W
01068:  MOVWF  00
0106A:  MOVF   x48,W
0106C:  SUBWFB x4C,W
0106E:  MOVWF  03
01070:  MOVFF  00,01
01074:  MOVWF  02
01076:  MOVLB  0
01078:  GOTO   1158 (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
010EE:  MOVFF  648,64A
010F2:  MOVFF  647,649
010F6:  MOVFF  64A,FEA
010FA:  MOVLB  6
010FC:  MOVFF  649,FE9
01100:  MOVF   FEF,F
01102:  BZ    1110
01104:  INCF   x49,F
01106:  BTFSC  FD8.2
01108:  INCF   x4A,F
0110A:  MOVLB  0
0110C:  BRA    10F6
0110E:  MOVLB  6
....................    return(sc - s);
01110:  MOVF   x47,W
01112:  SUBWF  x49,W
01114:  MOVWF  00
01116:  MOVF   x48,W
01118:  SUBWFB x4A,W
0111A:  MOVWF  03
0111C:  MOVFF  00,01
01120:  MOVWF  02
01122:  MOVLB  0
01124:  GOTO   11C2 (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
01128:  MOVLB  6
0112A:  MOVF   x3F,W
0112C:  IORWF  x40,W
0112E:  BZ    1138
01130:  MOVFF  640,03
01134:  MOVF   x3F,W
01136:  BRA    113E
01138:  MOVFF  1D,03
0113C:  MOVF   1C,W
0113E:  MOVWF  x43
01140:  MOVFF  03,644
....................    beg += strspn(beg, s2);
01144:  MOVFF  644,648
01148:  MOVFF  643,647
0114C:  MOVFF  642,64A
01150:  MOVFF  641,649
01154:  MOVLB  0
01156:  BRA    0FF4
01158:  MOVF   01,W
0115A:  MOVLB  6
0115C:  ADDWF  x43,F
0115E:  MOVF   02,W
01160:  ADDWFC x44,F
....................    if (*beg == '\0')
01162:  MOVFF  644,FEA
01166:  MOVFF  643,FE9
0116A:  MOVF   FEF,F
0116C:  BNZ   1176
....................       return(0);
0116E:  MOVLW  00
01170:  MOVWF  01
01172:  MOVWF  02
01174:  BRA    11D8
....................       
....................    end = strpbrk(beg, s2);
01176:  MOVFF  644,648
0117A:  MOVFF  643,647
0117E:  MOVFF  642,64A
01182:  MOVFF  641,649
01186:  MOVLB  0
01188:  BRA    107C
0118A:  MOVFF  02,646
0118E:  MOVFF  01,645
....................    if (end != '\0')
01192:  MOVLB  6
01194:  MOVF   x45,F
01196:  BNZ   119C
01198:  MOVF   x46,F
0119A:  BZ    11B6
....................    {
....................       *end = '\0';
0119C:  MOVFF  646,FEA
011A0:  MOVFF  645,FE9
011A4:  CLRF   FEF
....................       end++;
011A6:  INCF   x45,F
011A8:  BTFSC  FD8.2
011AA:  INCF   x46,F
....................       save = end;
011AC:  MOVFF  646,1D
011B0:  MOVFF  645,1C
....................    }
011B4:  BRA    11D0
....................    else
....................       save = beg + strlen(beg);
011B6:  MOVFF  644,648
011BA:  MOVFF  643,647
011BE:  MOVLB  0
011C0:  BRA    10EE
011C2:  MOVF   01,W
011C4:  MOVLB  6
011C6:  ADDWF  x43,W
011C8:  MOVWF  1C
011CA:  MOVF   02,W
011CC:  ADDWFC x44,W
011CE:  MOVWF  1D
....................    
....................    return(beg);
011D0:  MOVFF  643,01
011D4:  MOVFF  644,02
011D8:  MOVLB  0
011DA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
*
00EEE:  MOVFF  59F,FEA
00EF2:  MOVLB  5
00EF4:  MOVFF  59E,FE9
00EF8:  MOVFF  FEF,5A2
00EFC:  MOVFF  5A1,FEA
00F00:  MOVFF  5A0,FE9
00F04:  MOVF   FEF,W
00F06:  SUBWF  xA2,W
00F08:  BZ    0F8A
00F0A:  MOVFF  59F,FEA
00F0E:  MOVFF  59E,FE9
00F12:  MOVFF  FEF,5A2
00F16:  MOVF   xA2,W
00F18:  SUBLW  40
00F1A:  BC    0F22
00F1C:  MOVF   xA2,W
00F1E:  SUBLW  5A
00F20:  BC    0F2E
00F22:  MOVF   xA2,W
00F24:  SUBLW  60
00F26:  BC    0FB4
00F28:  MOVF   xA2,W
00F2A:  SUBLW  7A
00F2C:  BNC   0FB4
00F2E:  MOVFF  5A1,FEA
00F32:  MOVFF  5A0,FE9
00F36:  MOVFF  FEF,5A2
00F3A:  MOVF   xA2,W
00F3C:  SUBLW  40
00F3E:  BC    0F46
00F40:  MOVF   xA2,W
00F42:  SUBLW  5A
00F44:  BC    0F52
00F46:  MOVF   xA2,W
00F48:  SUBLW  60
00F4A:  BC    0FB4
00F4C:  MOVF   xA2,W
00F4E:  SUBLW  7A
00F50:  BNC   0FB4
00F52:  MOVFF  59F,FEA
00F56:  MOVFF  59E,FE9
00F5A:  MOVFF  FEF,5A2
00F5E:  MOVFF  5A1,FEA
00F62:  MOVFF  5A0,FE9
00F66:  MOVLW  20
00F68:  ADDWF  FEF,W
00F6A:  SUBWF  xA2,W
00F6C:  BZ    0F8A
00F6E:  MOVFF  5A1,FEA
00F72:  MOVFF  5A0,FE9
00F76:  MOVFF  FEF,5A2
00F7A:  MOVFF  59F,FEA
00F7E:  MOVFF  59E,FE9
00F82:  MOVLW  20
00F84:  ADDWF  FEF,W
00F86:  SUBWF  xA2,W
00F88:  BNZ   0FB4
....................     s1++, s2++)
....................     if (*s1 == '\0')
00F8A:  MOVFF  59F,FEA
00F8E:  MOVFF  59E,FE9
00F92:  MOVF   FEF,F
00F94:  BNZ   0F9C
....................        return(0);
00F96:  MOVLW  00
00F98:  MOVWF  01
00F9A:  BRA    0FDE
00F9C:  MOVFF  59F,03
00FA0:  MOVF   x9E,W
00FA2:  INCF   x9E,F
00FA4:  BTFSC  FD8.2
00FA6:  INCF   x9F,F
00FA8:  INCF   xA0,F
00FAA:  BTFSC  FD8.2
00FAC:  INCF   xA1,F
00FAE:  MOVLB  0
00FB0:  BRA    0EEE
00FB2:  MOVLB  5
....................  return((*s1 < *s2) ? -1: 1);
00FB4:  MOVFF  59F,03
00FB8:  MOVFF  59E,FE9
00FBC:  MOVFF  03,FEA
00FC0:  MOVFF  FEF,5A2
00FC4:  MOVFF  5A1,03
00FC8:  MOVFF  5A0,FE9
00FCC:  MOVFF  03,FEA
00FD0:  MOVF   FEF,W
00FD2:  SUBWF  xA2,W
00FD4:  BC    0FDA
00FD6:  MOVLW  FF
00FD8:  BRA    0FDC
00FDA:  MOVLW  01
00FDC:  MOVWF  01
00FDE:  MOVLB  0
00FE0:  RETURN 0
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
0122C:  MOVLB  6
0122E:  CLRF   x44
....................    sign = 0;
01230:  CLRF   x42
....................    base = 10;
01232:  MOVLW  0A
01234:  MOVWF  x43
....................    result = 0;
01236:  CLRF   x41
.................... 
....................    if (!s)
01238:  MOVF   x3F,W
0123A:  IORWF  x40,W
0123C:  BNZ   1244
....................       return 0;
0123E:  MOVLW  00
01240:  MOVWF  01
01242:  BRA    13BA
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
01244:  MOVF   x44,W
01246:  INCF   x44,F
01248:  ADDWF  x3F,W
0124A:  MOVWF  FE9
0124C:  MOVLW  00
0124E:  ADDWFC x40,W
01250:  MOVWF  FEA
01252:  MOVFF  FEF,645
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
01256:  MOVF   x45,W
01258:  SUBLW  2D
0125A:  BNZ   1274
....................    {
....................       sign = 1;         // Set the sign to negative
0125C:  MOVLW  01
0125E:  MOVWF  x42
....................       c = s[index++];
01260:  MOVF   x44,W
01262:  INCF   x44,F
01264:  ADDWF  x3F,W
01266:  MOVWF  FE9
01268:  MOVLW  00
0126A:  ADDWFC x40,W
0126C:  MOVWF  FEA
0126E:  MOVFF  FEF,645
....................    }
01272:  BRA    128C
....................    else if (c == '+')
01274:  MOVF   x45,W
01276:  SUBLW  2B
01278:  BNZ   128C
....................    {
....................       c = s[index++];
0127A:  MOVF   x44,W
0127C:  INCF   x44,F
0127E:  ADDWF  x3F,W
01280:  MOVWF  FE9
01282:  MOVLW  00
01284:  ADDWFC x40,W
01286:  MOVWF  FEA
01288:  MOVFF  FEF,645
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
0128C:  MOVF   x45,W
0128E:  SUBLW  2F
01290:  BTFSC  FD8.0
01292:  BRA    13AA
01294:  MOVF   x45,W
01296:  SUBLW  39
01298:  BTFSS  FD8.0
0129A:  BRA    13AA
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
0129C:  MOVF   x45,W
0129E:  SUBLW  30
012A0:  BNZ   12DE
012A2:  MOVF   x44,W
012A4:  ADDWF  x3F,W
012A6:  MOVWF  FE9
012A8:  MOVLW  00
012AA:  ADDWFC x40,W
012AC:  MOVWF  FEA
012AE:  MOVF   FEF,W
012B0:  SUBLW  78
012B2:  BZ    12C6
012B4:  MOVF   x44,W
012B6:  ADDWF  x3F,W
012B8:  MOVWF  FE9
012BA:  MOVLW  00
012BC:  ADDWFC x40,W
012BE:  MOVWF  FEA
012C0:  MOVF   FEF,W
012C2:  SUBLW  58
012C4:  BNZ   12DE
....................       {
....................          base = 16;
012C6:  MOVLW  10
012C8:  MOVWF  x43
....................          index++;
012CA:  INCF   x44,F
....................          c = s[index++];
012CC:  MOVF   x44,W
012CE:  INCF   x44,F
012D0:  ADDWF  x3F,W
012D2:  MOVWF  FE9
012D4:  MOVLW  00
012D6:  ADDWFC x40,W
012D8:  MOVWF  FEA
012DA:  MOVFF  FEF,645
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
012DE:  MOVF   x43,W
012E0:  SUBLW  0A
012E2:  BNZ   131C
....................       {
....................          while (c >= '0' && c <= '9')
012E4:  MOVF   x45,W
012E6:  SUBLW  2F
012E8:  BC    131A
012EA:  MOVF   x45,W
012EC:  SUBLW  39
012EE:  BNC   131A
....................          {
....................             result = 10*result + (c - '0');
012F0:  MOVLW  0A
012F2:  MOVWF  x46
012F4:  MOVFF  641,647
012F8:  MOVLB  0
012FA:  BRA    11DC
012FC:  MOVLW  30
012FE:  MOVLB  6
01300:  SUBWF  x45,W
01302:  ADDWF  01,W
01304:  MOVWF  x41
....................             c = s[index++];
01306:  MOVF   x44,W
01308:  INCF   x44,F
0130A:  ADDWF  x3F,W
0130C:  MOVWF  FE9
0130E:  MOVLW  00
01310:  ADDWFC x40,W
01312:  MOVWF  FEA
01314:  MOVFF  FEF,645
01318:  BRA    12E4
....................          }
....................       }
0131A:  BRA    13AA
....................       else if (base == 16)    // The number is a hexa number
0131C:  MOVF   x43,W
0131E:  SUBLW  10
01320:  BNZ   13AA
....................       {
....................          c = toupper(c);
01322:  MOVF   x45,W
01324:  SUBLW  60
01326:  BC    1334
01328:  MOVF   x45,W
0132A:  SUBLW  7A
0132C:  BNC   1334
0132E:  MOVF   x45,W
01330:  ANDLW  DF
01332:  BRA    1336
01334:  MOVF   x45,W
01336:  MOVWF  x45
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
01338:  MOVF   x45,W
0133A:  SUBLW  2F
0133C:  BC    1344
0133E:  MOVF   x45,W
01340:  SUBLW  39
01342:  BC    1350
01344:  MOVF   x45,W
01346:  SUBLW  40
01348:  BC    13AA
0134A:  MOVF   x45,W
0134C:  SUBLW  46
0134E:  BNC   13AA
....................          {
....................             if (c >= '0' && c <= '9')
01350:  MOVF   x45,W
01352:  SUBLW  2F
01354:  BC    136E
01356:  MOVF   x45,W
01358:  SUBLW  39
0135A:  BNC   136E
....................                result = (result << 4) + (c - '0');
0135C:  SWAPF  x41,W
0135E:  MOVWF  x46
01360:  MOVLW  F0
01362:  ANDWF  x46,F
01364:  MOVLW  30
01366:  SUBWF  x45,W
01368:  ADDWF  x46,W
0136A:  MOVWF  x41
0136C:  BRA    1380
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0136E:  SWAPF  x41,W
01370:  MOVWF  x46
01372:  MOVLW  F0
01374:  ANDWF  x46,F
01376:  MOVLW  41
01378:  SUBWF  x45,W
0137A:  ADDLW  0A
0137C:  ADDWF  x46,W
0137E:  MOVWF  x41
.................... 
....................             c = s[index++];
01380:  MOVF   x44,W
01382:  INCF   x44,F
01384:  ADDWF  x3F,W
01386:  MOVWF  FE9
01388:  MOVLW  00
0138A:  ADDWFC x40,W
0138C:  MOVWF  FEA
0138E:  MOVFF  FEF,645
....................             c = toupper(c);
01392:  MOVF   x45,W
01394:  SUBLW  60
01396:  BC    13A4
01398:  MOVF   x45,W
0139A:  SUBLW  7A
0139C:  BNC   13A4
0139E:  MOVF   x45,W
013A0:  ANDLW  DF
013A2:  BRA    13A6
013A4:  MOVF   x45,W
013A6:  MOVWF  x45
013A8:  BRA    1338
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
013AA:  DECFSZ x42,W
013AC:  BRA    13B6
013AE:  MOVF   x43,W
013B0:  SUBLW  0A
013B2:  BNZ   13B6
....................        result = -result;
013B4:  NEGF   x41
.................... 
....................    return(result);
013B6:  MOVFF  641,01
013BA:  MOVLB  0
013BC:  RETURN 0
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... /// TODO
.................... 
.................... /// intmax_t uintmax_t
.................... 
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX
.................... 
.................... /// INTMAX_C(value) UINTMAX_C(value)
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <arQ1010/globalVariables.h>
.................... #define BUFFER_SIZE      255
.................... 
.................... //reusable variables
.................... //int timeOut=0;
.................... //int try=0;
.................... char TOKEN[10]={};
.................... 
.................... //char funcReturnVar[BUFFER_SIZE]={}; //Global string variable used for functions returning string values 
.................... 
.................... //Variables for BTD200
.................... //Variables for USB Serial Interrupt RDA2
.................... char INTERRUPTUSB_Rxd[20]={};
.................... int1 InterruptUSB_Flag=0;
.................... int InterruptUSB_Counter=0;
.................... 
.................... //Variables for USB Serial Interrupt RDA2
.................... char InterruptGSM_Rxd[BUFFER_SIZE]={};
.................... int1 InterruptGSM_Flag=0;
.................... int InterruptGSM_Counter=0;
.................... int READ_CNTR = 0;
.................... 
.................... //Variables for gsm.c
.................... int NETWORK=0; //Registered GSM Network
.................... char SERVERNUMBER[15]={};
.................... char MYNUMBER1[15]={};
.................... char MYNUMBER2[15]={};
.................... char SMS_RCV[BUFFER_SIZE] = {};
.................... //char SMS_TOBE_SENT[BUFFER_SIZE]={};
.................... int1 EXT_FLAG=0;
.................... char GSM_RESPONSE[BUFFER_SIZE]={};
.................... char DESIRED_RESPONSE[17]={};
.................... //char BTDmessage[255] = {};
.................... 
.................... 
.................... 
.................... 
.................... //char cx[90] = {0xff, 0xff, 0x57, 0x00, 0x20, 0x00, 0x04, 0x26, 0x01, 0x04, 0x28, 0x0f, 0x01, 0x04, 0x16, 0x84, 0x00, 0x81, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x0c, 0xaf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0xde, 0x4d, 0x89, 0x3c}; 
.................... //char cx[90] = {0xff, 0xff, 0x57, 0x00, 0x20, 0x00, 0x04, 0x26, 0x01, 0x04, 0x28, 0x0f, 0x01, 0x04, 0x16, 0x84, 0x00, 0x81, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0xfe, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0x4d, 0x01, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0x68, 0x01, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0xdd, 0x00, 0x01, 0x01, 0x00, 0xde, 0x4d, 0x89, 0x3c};
.................... //char cx[90] = {};
.................... 
.................... int SEC=0;
.................... int MIN=0;
.................... int HOUR=0;
.................... int DAY=0;
.................... int MONTH=0;
.................... int YEAR=0;
.................... int YEAR_PREV=0;
.................... //char globalDT[20]={};
.................... 
.................... //char cx[100] = {};
.................... char strDateTime[20]={};
.................... char biralBT[20]={};
.................... char BTDLaLo[150]={};
.................... char distDir[10] = {};
.................... //char DTindex[5] = {};
.................... Char flashCount[10] = {};
.................... char strBTD_con [10] = {};
.................... char strBTD_info [20] = {};
.................... char btdCode[20] = {};
.................... //int BTDhealth[2] = {};
.................... 
.................... //long int reCounter = 0;
.................... //char btdRestart[2] = {};
.................... 
.................... 
.................... //char message[255]={};
.................... int powerGSMready = 0;
.................... 
.................... int SENDING_TIME=15;
.................... int1 SAMPLINGFLAG=FALSE;
.................... int1 CHECKMINUTE=0;
.................... int HOUROLD=0;
.................... int1 RESETCPU=0;
.................... 
.................... int1 TESTFLAG=0;
.................... int1 SYNCFLAG=0;
.................... int1 RESETFLAG=0;
.................... //!
.................... //!//int const CONNECT = 0xE0;
.................... //!int const DATETIME = 0xE1;
.................... //!int const SENSORTEST = 0xE2;
.................... //!int const FIRMWAREMODE = 0xE3;
.................... //!int const EXITCONFIG = 0xE4;
.................... //!int const FIRMWARECHAR = 0xE5;
.................... //!int const GOOD_DATA = 0xE6;
.................... //!int const BAD_DATA = 0xE7;
.................... //!int const SENSORINI = 0xE8;
.................... //!int const CONFIGSET = 0xEA;
.................... //!int const REDOWNLOADFIRMWARE = 0xEB;
.................... //!int const FIRMWAREFLASHDOWNLOAD = 0xEC;
.................... //!int const GSMTEST = 0xED;
.................... //!int const SATELLITE_TEST = 0xEE;
.................... 
.................... 
.................... 
.................... #include <arQ1010/pinDefinitions.c>
.................... 
.................... //**** RS485 *****//
.................... #define  TX2_RS485        PIN_E4
.................... #define  RX2_RS485        PIN_E7
.................... #define  EN_DE_RS485        PIN_E5
.................... #define  EN_RE_RS485        PIN_E6
.................... 
.................... //**** EXPOSED PIN FOR RS232
.................... #define  EN_UART        PIN_D1
.................... 
.................... //**** I2C PINS 
.................... #define  EN_I2C   PIN_D4
.................... #define  SDA_I2C  PIN_D5
.................... #define  SCL_I2C  PIN_D6
.................... 
.................... //**** SWITCH TO SELECT WHAT BATTERY TO USE
.................... #define  ENBA     PIN_J2
.................... #define  ENBB     PIN_J3
.................... 
.................... //**** GSM
.................... #define  RING_OUT    PIN_B1
.................... #define  RTS      PIN_A6
.................... #define  pin_CTS      PIN_A7
.................... #define  IGT      PIN_C2
.................... 
.................... //**** HARDWARE UART
.................... #define  RX_INT      PIN_C6
.................... #define  TX_INT      PIN_C5
.................... 
.................... #define  RX_USB       PIN_G2
.................... #define  TX_USB       PIN_G1
.................... 
.................... //**** RS232
.................... #define  TX_B        PIN_G4
.................... #define  RX_B        PIN_G3
.................... 
.................... //**** DIGITAL OUT
.................... #define  pin_OUT1        PIN_A3
.................... #define  OUT2        PIN_A2
.................... #define  OUT3        PIN_A1
.................... 
.................... //**** DIGITAL INPUTS
.................... #define  INTRUP4     PIN_D7
.................... #define  INTRUP1     PIN_B0
.................... #define  INTRUP2     PIN_B2
.................... #define  INTRUP3     PIN_B3
.................... 
.................... //**** SPI
.................... #define  SDO1        PIN_C5
.................... #define  SDA1        PIN_C4
.................... #define  SCK1        PIN_C3
.................... #define  EN1         PIN_F4
.................... #define  CS1         PIN_F5
.................... 
.................... //#define THUNDER_CS PIN_F4
.................... //#define SCP_CSB PIN_F4
.................... 
.................... //**** FLASH CHIP ENABLE
.................... #define  CS          PIN_E0
.................... 
.................... //**** USB PIN CHECK
.................... #define  pin_USB_STAT    PIN_G0
.................... 
.................... //**** DUAL COLOR LED
.................... #define  LED_STAT_A     PIN_E1
.................... #define  LED_STAT_B     PIN_H3
.................... 
.................... //**** SHT11
.................... #define  SHT_DATA_PIN       PIN_H2
.................... #define  SHT_CLK_PIN         PIN_B4
.................... 
.................... 
.................... //**** RESET
.................... #define  MCLR        PIN_G5
.................... 
.................... //**** ADC
.................... #define  VBAT_ADC       PIN_F7  //channel 5 3.3V MONITORING
.................... #define  IBOOST_ADC     PIN_H4  //channel 12 BOOST MONITORING
.................... #define  VBOOST_ADC     PIN_H5  //channel 13 BOOST MONITORING
.................... #define  IBOOST2_ADC    PIN_H7  //channel 15 BOOST MONITORING
.................... #define  VBOOST2_ADC    PIN_H6  //channel 14 BOOST MONITORING
.................... #define  VEXT1_ADC      PIN_F3  //channel 8 EXTERNAL ADC1
.................... #define  VEXT2_ADC      PIN_F2  //channel 7 EXTERNAL ADC2
.................... #define  INA_ADC        PIN_A5  //channel 4 INPUT VOLTAGE MONITORING 1
.................... #define  INB_ADC        PIN_A0  //channel 0 INPUT VOLTAGE MONITORING 2
.................... 
.................... #define  channel_VBAT_ADC       5  //channel 5 3.3V MONITORING
.................... #define  channel_IBOOST_ADC     12 //channel 12 BOOST MONITORING
.................... #define  channel_VBOOST_ADC     13  //channel 13 BOOST MONITORING
.................... #define  channel_IBOOST2_ADC    15  //channel 15 BOOST MONITORING
.................... #define  channel_VBOOST2_ADC    14  //channel 14 BOOST MONITORING
.................... #define  channel_VEXT1_ADC      8  //channel 8 EXTERNAL ADC1
.................... #define  channel_VEXT2_ADC      7  //channel 7 EXTERNAL ADC2
.................... #define  channel_INA_ADC        4  //channel 4 INPUT VOLTAGE MONITORING 1
.................... #define  channel_INB_ADC        0  //channel 0 INPUT VOLTAGE MONITORING 2
.................... 
.................... 
.................... //**** POWER BOARD PINS
.................... #define  pin_BOOST1          PIN_D0  //BOOST SWITCH
.................... #define  pin_BOOST2          PIN_F1  //BOOST SWITCH
.................... #define  pin_CHRG_STAT1     PIN_J7
.................... #define  pin_FAULT_STAT1    PIN_J6
.................... #define  pin_CHRG_STAT2     PIN_J4
.................... #define  pin_FAULT_STAT2    PIN_J5
.................... 
.................... 
.................... 
.................... #include <arQ1010/interruptSerial2_USB.c>
.................... #use rs232(baud=57600, xmit=TX_USB, rcv=RX_USB, stream=USB)
.................... 
.................... #int_rda2 //RS232 receive data available in buffer 2
.................... 
.................... void rda2_isr(void){
....................    InterruptUSB_Flag = 1;
*
001D2:  BSF    40.0
....................    InterruptUSB_Rxd[InterruptUSB_Counter++]=fgetc(USB);
001D4:  MOVF   41,W
001D6:  INCF   41,F
001D8:  CLRF   03
001DA:  ADDLW  2C
001DC:  MOVWF  FE9
001DE:  MOVLW  00
001E0:  ADDWFC 03,W
001E2:  MOVWF  FEA
001E4:  BTFSS  FA4.5
001E6:  BRA    01E4
001E8:  MOVLB  F
001EA:  MOVFF  F1D,FEF
....................    InterruptUSB_Rxd[InterruptUSB_Counter]=0x00; //'\0' or 'NULL' terminating character 
001EE:  CLRF   03
001F0:  MOVF   41,W
001F2:  ADDLW  2C
001F4:  MOVWF  FE9
001F6:  MOVLW  00
001F8:  ADDWFC 03,W
001FA:  MOVWF  FEA
001FC:  CLRF   FEF
001FE:  BCF    FA4.5
00200:  MOVLB  0
00202:  GOTO   0098
.................... }
.................... 
.................... void clear_InterruptUSB(){  
....................    //InterruptUSB_Rxd[0]='\0';
....................    strcpy(InterruptUSB_Rxd,"");
*
0098A:  CLRF   FEA
0098C:  MOVLW  2C
0098E:  MOVWF  FE9
00990:  MOVLW  00
00992:  CALL   00EE
00996:  TBLRD*-
00998:  TBLRD*+
0099A:  MOVF   FF5,W
0099C:  MOVWF  FEE
0099E:  IORLW  00
009A0:  BNZ   0998
....................    InterruptUSB_Flag=0;
009A2:  BCF    40.0
....................    InterruptUSB_Counter=0;
009A4:  CLRF   41
009A6:  RETURN 0
.................... }
.................... 
.................... 
.................... void getDataFromUSB(){
....................    clear_InterruptUSB();
*
00FE2:  RCALL  098A
....................    while(!InterruptUSB_Flag);
00FE4:  BTFSS  40.0
00FE6:  BRA    0FE4
....................    delay_ms(50); //needed to stabilize USB input
00FE8:  MOVLW  32
00FEA:  MOVLB  6
00FEC:  MOVWF  x3F
00FEE:  MOVLB  0
00FF0:  RCALL  0932
00FF2:  RETURN 0
.................... }
.................... 
.................... 
.................... #include <arQ1010/InterruptSerial1_GSM.c>
.................... //#use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=GSM)
.................... 
.................... #int_rda
.................... void rda_isr(void)
.................... {
....................    InterruptGSM_Flag = 1;
*
00206:  BSF    40.1
....................    InterruptGSM_Rxd[InterruptGSM_Counter++]=fgetc(GSM);
00208:  MOVLB  1
0020A:  MOVF   x41,W
0020C:  INCF   x41,F
0020E:  CLRF   03
00210:  ADDLW  42
00212:  MOVWF  FE9
00214:  MOVLW  00
00216:  ADDWFC 03,W
00218:  MOVWF  FEA
0021A:  BTFSS  F9E.5
0021C:  BRA    021A
0021E:  MOVFF  FAE,FEF
....................    //InterruptGSM_Rxd[InterruptGSM_Counter]=0x00;
00222:  BCF    F9E.5
00224:  MOVLB  0
00226:  GOTO   0098
.................... }
.................... 
.................... void clear_InterruptGSM()
.................... {
....................    int i=0;
....................    
....................    for (i=0;i<BUFFER_SIZE;i++)
....................    {
....................       InterruptGSM_Rxd[i]=NULL;
....................       GSM_RESPONSE[i]=NULL;
....................    }
.................... 
....................    InterruptGSM_Counter=0;
....................    READ_CNTR=0;
....................    InterruptGSM_Flag=0;
.................... }
.................... 
.................... void getDataFromGSM()
.................... {
....................    clear_InterruptGSM();
....................    while(!InterruptGSM_Flag);
....................    delay_ms(50); //needed to stabilize USB input
.................... }
.................... 
.................... //!void clear_InterruptGSM()
.................... //!{  
.................... //!   strcpy(InterruptGSM_Rxd,"");
.................... //!   InterruptGSM_Flag=0;
.................... //!   InterruptGSM_Counter=0;
.................... //!   READ_CNTR=0;
.................... //!
.................... //!}
.................... 
.................... 
.................... char *GetResponse(void)
.................... {
....................    int tempCntr = 0;
....................    int i=0, len=0;
....................    
....................    len = strlen(DESIRED_RESPONSE);
....................    while(((InterruptGSM_Counter - READ_CNTR) < len) && ++tempCntr < 30) delay_ms(100);
.................... 
....................    len = READ_CNTR;
....................    if(tempCntr < 30)
....................    {
....................       tempCntr = 0;
....................       do
....................       {
....................          do
....................          {                                                                                      
....................             for(; (READ_CNTR != InterruptGSM_Counter) && (InterruptGSM_Rxd[READ_CNTR] != DESIRED_RESPONSE[0]); READ_CNTR=(READ_CNTR+1) % BUFFER_SIZE);
....................             for(i = 0; (READ_CNTR != InterruptGSM_Counter) && (InterruptGSM_Rxd[READ_CNTR] == DESIRED_RESPONSE[i]) && (DESIRED_RESPONSE[i] != 0); i++, READ_CNTR=(READ_CNTR+1) % BUFFER_SIZE);
....................             if(DESIRED_RESPONSE[i] == 0)
....................             {
....................                // TODO: insert delay if necessary
....................                InterruptGSM_Rxd[InterruptGSM_Counter] = 0; // terminate string
....................                len = (InterruptGSM_Counter - READ_CNTR);
....................                for(i = 0; i <= len; i++)
....................                {
....................                   GSM_RESPONSE[i] = InterruptGSM_Rxd[READ_CNTR + i];
....................                   //fprintf(USB,"%c",GSM_RESPONSE[i]);
....................                }
....................                READ_CNTR = InterruptGSM_Counter;
....................                return &GSM_RESPONSE[0];
....................                
....................             }
....................          } while((DESIRED_RESPONSE[i] != 0) && (READ_CNTR != InterruptGSM_Counter));
....................          delay_ms(100);
....................          READ_CNTR = len;
....................       } while(++tempCntr < 10);
....................    }
.................... 
....................    READ_CNTR = InterruptGSM_Counter;
.................... 
.................... //    TODO: for debugging purposes, to be removed
.................... //   fprintf(PC, "\r\nMessage Received:");
.................... //   for(; len != InterruptGSM_Cunter; len++)
.................... //   {
.................... //      fprintf(PC, "%c", RXD_DATA[len]);
.................... //   }
.................... //   fprintf(PC, "READ_CNTR=%i\n", read_cntr);
.................... //   fprintf(PC, "InterruptGSM_Counter=%i\n", write_cntr);
....................    return NULL; // no match found
....................  }
.................... 
.................... 
.................... #include <arQ1010/interruptExt1_GSM.c>
.................... 
.................... #int_ext1
.................... void ext_isr1(void)
.................... {
....................    EXT_FLAG=1;
0022A:  BSF    40.2
....................    strcpy(SMS_RCV,InterruptGSM_Rxd);
0022C:  MOVLW  01
0022E:  MOVWF  FEA
00230:  MOVLW  71
00232:  MOVWF  FE9
00234:  CLRF   FE2
00236:  MOVLW  42
00238:  MOVWF  FE1
0023A:  MOVF   FE7,F
0023C:  MOVFF  FE6,FEE
00240:  BNZ   023A
.................... }
.................... 
00242:  BCF    FF0.0
00244:  GOTO   0098
.................... #include <arQ1010/interruptExt2_IN2.c>
.................... int1 InterruptInput2_Flag = 0;
.................... 
.................... #int_ext2 //when interrupt is enables on the main code the code is redirected on this include file
.................... void ext_isr2(void)
.................... {//if (input(PIN_B0))
.................... //fprintf(USB, "INTEEERRRRRUPPTTT"); 
....................    {
....................      InterruptInput2_Flag=1;
00248:  MOVLB  4
0024A:  BSF    x8E.1
....................      //fprintf(USB, "Interrupt!\n");
....................    }
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/dualColorLED.c>
.................... #define LED_OFF 0
.................... #define LED_GREEN 1
0024C:  BCF    FF0.1
0024E:  MOVLB  0
00250:  GOTO   0098
.................... #define LED_RED 2
.................... 
.................... void ledConfig(int mode)
.................... {
....................    switch (mode) {
*
00EC0:  MOVLB  5
00EC2:  MOVF   x9F,W
00EC4:  XORLW  02
00EC6:  MOVLB  0
00EC8:  BZ    0ED0
00ECA:  XORLW  03
00ECC:  BZ    0EDA
00ECE:  BRA    0EE4
....................       case LED_RED:
....................          output_high(LED_STAT_A);
00ED0:  BCF    F96.1
00ED2:  BSF    F8D.1
....................          output_low(LED_STAT_B);
00ED4:  BCF    F99.3
00ED6:  BCF    F90.3
....................          break;
00ED8:  BRA    0EEC
....................       case LED_GREEN:
....................          output_low(LED_STAT_A);
00EDA:  BCF    F96.1
00EDC:  BCF    F8D.1
....................          output_high(LED_STAT_B);
00EDE:  BCF    F99.3
00EE0:  BSF    F90.3
....................          //output_low(LED_STAT_B);
....................          break;
00EE2:  BRA    0EEC
....................       default:
....................          output_low(LED_STAT_A);
00EE4:  BCF    F96.1
00EE6:  BCF    F8D.1
....................          output_low(LED_STAT_B);
00EE8:  BCF    F99.3
00EEA:  BCF    F90.3
....................          break;
....................    }
00EEC:  RETURN 0
.................... }
.................... 
.................... void ledToggle(int1 color)
.................... {
....................    static int1 toggle=0;
....................    if (toggle==0)
*
01DBC:  MOVLB  4
01DBE:  BTFSC  x8E.2
01DC0:  BRA    1DEE
....................    {
....................       if (color == LED_GREEN)
01DC2:  MOVLB  5
01DC4:  DECFSZ x9E,W
01DC6:  BRA    1DD6
....................          ledConfig(LED_GREEN);
01DC8:  MOVLW  01
01DCA:  MOVWF  x9F
01DCC:  MOVLB  0
01DCE:  CALL   0EC0
01DD2:  BRA    1DE6
01DD4:  MOVLB  5
....................       else if (color == LED_RED)
01DD6:  MOVF   x9E,W
01DD8:  SUBLW  02
01DDA:  BNZ   1DE8
....................          ledConfig(LED_RED);
01DDC:  MOVLW  02
01DDE:  MOVWF  x9F
01DE0:  MOVLB  0
01DE2:  CALL   0EC0
01DE6:  MOVLB  5
....................       toggle=1;
01DE8:  MOVLB  4
01DEA:  BSF    x8E.2
....................    }
01DEC:  BRA    1DFC
....................    else
....................    {
....................       ledConfig(LED_OFF);
01DEE:  MOVLB  5
01DF0:  CLRF   x9F
01DF2:  MOVLB  0
01DF4:  CALL   0EC0
....................       toggle=0;
01DF8:  MOVLB  4
01DFA:  BCF    x8E.2
....................    }
01DFC:  MOVLB  0
01DFE:  GOTO   233C (RETURN)
.................... }
.................... 
.................... //#include <arQ1010/gsm.c>
.................... #include <arQ1010/LTE.c>
.................... void initLTE(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"init\r");
....................    delay_ms(1000);
....................    if(GetResponse())
....................       fprintf(USB,"LTE Initialized\n");
.................... }
.................... 
.................... char *signalLTE(){
....................    char *signal=NULL;
....................    //strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................     delay_ms(200);
....................    fprintf(GSM,"signal\r");
....................    delay_ms(200);
....................    signal = GetResponse();
....................    //fprintf(USB, signal);
....................    return signal;
.................... }
.................... 
.................... void sendToLTE(char *msg){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM, msg);
....................    if(GetResponse())
....................       fprintf(USB,"\nSMS Sent: %s\n", msg);
.................... }  
....................  
....................  void relayOFF(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"OFF\r");
....................    delay_ms(200);
.................... }
.................... 
....................  void relayON(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"ON\r");
....................    delay_ms(200);
.................... }
.................... 
.................... 
....................  void igtLTE(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"igt\r");
....................    delay_ms(2000);
....................    if(GetResponse())
....................       fprintf(USB,"LTE Ignited\n");   
.................... }
.................... 
.................... #include <arQ1010/interruptTimer1.c>
.................... #Byte TMR1H = 0xFCF   // TIMER1 HIGH BYTE LOOK DATASHEET
.................... #Byte T1CON = 0xFCD  //TIMER1 CONFIG REGISTER LOOK DATASHEET 
.................... 
.................... 
.................... 
.................... //#define IS_LEAP(year) (year%4 == 0)
.................... unsigned int INTERRUPTCHECKER=0;
.................... 
.................... int1 IS_LEAP(year)
*
00316:  MOVLB  6
00318:  CLRF   x52
0031A:  CLRF   x51
.................... {
....................    int16 year_ = 0;
....................    
....................    year_ = year + 2000;
0031C:  MOVLW  D0
0031E:  ADDWF  x50,W
00320:  MOVWF  x51
00322:  MOVLW  07
00324:  MOVWF  x52
00326:  BTFSC  FD8.0
00328:  INCF   x52,F
....................    if (((year_ % 4 == 0) && (year % 100 != 0)) || (year % 400 ==0))
0032A:  MOVF   x51,W
0032C:  ANDLW  03
0032E:  MOVWF  x53
00330:  CLRF   x54
00332:  MOVF   x53,F
00334:  BNZ   034C
00336:  MOVF   x54,F
00338:  BNZ   034C
0033A:  MOVFF  650,653
0033E:  MOVLW  64
00340:  MOVWF  x54
00342:  MOVLB  0
00344:  RCALL  02A2
00346:  MOVF   00,F
00348:  BNZ   0372
0034A:  MOVLB  6
0034C:  CLRF   x54
0034E:  MOVFF  650,653
00352:  MOVLW  01
00354:  MOVWF  x56
00356:  MOVLW  90
00358:  MOVWF  x55
0035A:  MOVLB  0
0035C:  BRA    02CE
0035E:  MOVFF  00,653
00362:  MOVLB  6
00364:  MOVFF  03,654
00368:  MOVF   x53,F
0036A:  BNZ   037C
0036C:  MOVF   x54,F
0036E:  BNZ   037C
00370:  MOVLB  0
....................       return 1;
00372:  MOVLW  01
00374:  MOVWF  01
00376:  BRA    0382
00378:  BRA    0382
0037A:  MOVLB  6
....................    else
....................       return 0;
0037C:  MOVLW  00
0037E:  MOVWF  01
00380:  MOVLB  0
00382:  GOTO   03C8 (RETURN)
.................... }
.................... 
.................... 
.................... #int_TIMER1 
.................... void TIMER1_isr()    
.................... { 
....................    bit_clear(T1CON,1);
00386:  BCF    FCD.1
....................    bit_set(TMR1H,7);
00388:  BSF    FCF.7
....................    bit_set(T1CON,1);
0038A:  BSF    FCD.1
....................    
....................    INTERRUPTCHECKER=0; 
0038C:  MOVLB  4
0038E:  CLRF   x91
....................    if (++SEC>59){
00390:  MOVLB  3
00392:  INCF   x80,F
00394:  MOVF   x80,W
00396:  SUBLW  3B
00398:  BC    0432
....................       SEC=0;
0039A:  CLRF   x80
....................       TESTFLAG=TRUE;
0039C:  BSF    40.6
....................       if(++MIN>59){
0039E:  INCF   x81,F
003A0:  MOVF   x81,W
003A2:  SUBLW  3B
003A4:  BC    0432
....................          MIN=0;
003A6:  CLRF   x81
....................          if(++HOUR>23){
003A8:  INCF   x82,F
003AA:  MOVF   x82,W
003AC:  SUBLW  17
003AE:  BC    0432
....................             HOUR=0;
003B0:  CLRF   x82
....................             ++DAY;
003B2:  INCF   x83,F
....................             if ((DAY == 29 && MONTH== 2 && !IS_LEAP(YEAR))
....................                || (DAY == 30 && MONTH==2)
....................                || (DAY == 31 && (MONTH==4 || MONTH==6 || MONTH==9 || MONTH==11))
....................                || (DAY == 32)
003B4:  MOVF   x83,W
003B6:  SUBLW  1D
003B8:  BNZ   03CE
003BA:  MOVF   x84,W
003BC:  SUBLW  02
003BE:  BNZ   03CE
003C0:  MOVFF  385,650
003C4:  MOVLB  0
003C6:  BRA    0316
003C8:  MOVF   01,F
003CA:  BZ    041C
003CC:  MOVLB  3
003CE:  MOVF   x83,W
003D0:  SUBLW  1E
003D2:  BNZ   03E0
003D4:  MOVF   x84,W
003D6:  SUBLW  02
003D8:  BTFSS  FD8.2
003DA:  BRA    03E0
003DC:  MOVLB  0
003DE:  BRA    041C
003E0:  MOVF   x83,W
003E2:  SUBLW  1F
003E4:  BNZ   0416
003E6:  MOVF   x84,W
003E8:  SUBLW  04
003EA:  BTFSS  FD8.2
003EC:  BRA    03F2
003EE:  MOVLB  0
003F0:  BRA    041C
003F2:  MOVF   x84,W
003F4:  SUBLW  06
003F6:  BTFSS  FD8.2
003F8:  BRA    03FE
003FA:  MOVLB  0
003FC:  BRA    041C
003FE:  MOVF   x84,W
00400:  SUBLW  09
00402:  BTFSS  FD8.2
00404:  BRA    040A
00406:  MOVLB  0
00408:  BRA    041C
0040A:  MOVF   x84,W
0040C:  SUBLW  0B
0040E:  BTFSS  FD8.2
00410:  BRA    0416
00412:  MOVLB  0
00414:  BRA    041C
00416:  MOVF   x83,W
00418:  SUBLW  20
0041A:  BNZ   0424
....................                ){MONTH++;DAY=1;}
0041C:  MOVLB  3
0041E:  INCF   x84,F
00420:  MOVLW  01
00422:  MOVWF  x83
....................             if(MONTH == 13) {YEAR++; MONTH=1;}
00424:  MOVF   x84,W
00426:  SUBLW  0D
00428:  BNZ   0430
0042A:  INCF   x85,F
0042C:  MOVLW  01
0042E:  MOVWF  x84
....................             RESETCPU=1;
00430:  BSF    40.5
....................          }
.................... //!         if (HOUR == 8)
.................... //!            RESETFLAG=TRUE;
....................       }
....................    }
....................    
....................    if ((HOUR == 23) && (MIN == 58)  && (SEC == 0))
00432:  MOVF   x82,W
00434:  SUBLW  17
00436:  BNZ   0444
00438:  MOVF   x81,W
0043A:  SUBLW  3A
0043C:  BNZ   0444
0043E:  MOVF   x80,F
00440:  BNZ   0444
....................        { 
.................... 
....................         SYNCFLAG=TRUE;
00442:  BSF    40.7
....................        }  
....................    
....................    if ((HOUROLD != HOUR) && (MIN == 58))
00444:  MOVF   x82,W
00446:  MOVLB  4
00448:  SUBWF  x8D,W
0044A:  BZ    0462
0044C:  MOVLB  3
0044E:  MOVF   x81,W
00450:  SUBLW  3A
00452:  BTFSC  FD8.2
00454:  BRA    045A
00456:  MOVLB  4
00458:  BRA    0462
....................    {  
....................       RESETFLAG=TRUE;
0045A:  MOVLB  4
0045C:  BSF    x8E.0
....................       HOUROLD=HOUR;
0045E:  MOVFF  382,48D
....................    }
....................    
....................    if ((MIN%SENDING_TIME) == 0)
00462:  MOVFF  381,653
00466:  MOVFF  48C,654
0046A:  MOVLB  0
0046C:  RCALL  02A2
0046E:  MOVF   00,F
00470:  BNZ   047C
....................    {
....................       if (CHECKMINUTE == FALSE)
00472:  BTFSC  40.4
00474:  BRA    047A
....................       {
....................          CHECKMINUTE = TRUE;
00476:  BSF    40.4
....................          SAMPLINGFLAG = TRUE;
00478:  BSF    40.3
....................       }
....................    }
0047A:  BRA    047E
....................    else
....................       CHECKMINUTE = FALSE;
0047C:  BCF    40.4
....................      
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/rtc.c>
.................... #define RTC_I2C_ADDR_2129     81
.................... #define RTC_I2C_ADDR_8523     104
.................... #define RTC_CONTROL1_REG      0x00
.................... #define RTC_CONTROL2_REG      0x01
.................... #define RTC_CONTROL3_REG      0x02
.................... 
.................... #define RTC_SEC_REG           0x03
.................... #define RTC_MIN_REG           0x04
.................... #define RTC_HOUR_REG          0x05
.................... #define RTC_DATE_REG          0x06
.................... #define RTC_WEEKDAY_REG       0x07
.................... #define RTC_MONTH_REG         0x08
0047E:  BCF    F9E.0
00480:  GOTO   0098
.................... #define RTC_YEAR_REG          0x09
.................... 
.................... 
.................... int8 get_ack_status(int8 address)
.................... {
....................    int8 status; 
....................    
....................    i2c_start(); 
....................    status = i2c_write(address);  // Status = 0 if got an ACK 
....................    i2c_stop(); 
....................    
....................    if(status == 0) 
....................       return(TRUE); 
....................    else 
....................       return(FALSE); 
.................... }
.................... 
.................... int32 rtcGetEpochDate(int32 year, int month, int day)
.................... {
....................     if (year >= 1900)
....................       {
....................         year -= 1900;
....................     }
....................     
....................     /* month must be cast to uint8_t or this fails on some platforms */
....................     int8 m = (int8)(month & 0xFF);
....................     return (1461 * (year + 6700 + (m - 14) / 12)) / 4 + (367 *
....................         (m - 2 - 12 * ((m - 14) / 12))) / 12 -
....................         (3 * ((year + 6800 + (m - 14) / 12) / 100)) / 4 +
....................         day - 2472663;
.................... }
.................... 
.................... int rtcAssignWeekday(int32 years, int months, int days)
.................... {
....................     int32 NrOfDay=0;
....................     int8 weekday=0;
....................     NrOfDay = rtcGetEpochDate(years, months, days);
....................     weekday = (NrOfDay + 3) % 7;
....................     //fprintf(PC,"NrOfDay=%lu\n",NrOfDay);
....................     //fprintf(PC,"weekday=%u\n",weekday);
....................     return weekday;
.................... }
.................... 
.................... int8 rtcBCDToDec(int8 val)
.................... {
....................     return (val >> 4) * 10 + (val & 0x0F);
*
01716:  MOVLB  6
01718:  SWAPF  x49,W
0171A:  MOVWF  00
0171C:  MOVLW  0F
0171E:  ANDWF  00,F
01720:  MOVF   00,W
01722:  MULLW  0A
01724:  MOVFF  FF3,64A
01728:  MOVF   x49,W
0172A:  ANDLW  0F
0172C:  ADDWF  x4A,W
0172E:  MOVWF  01
01730:  MOVLB  0
01732:  RETURN 0
.................... }   
.................... 
.................... int8 rtcDecToBCD(int8 val)
*
013BE:  CLRF   1B
013C0:  BTFSC  FF2.7
013C2:  BSF    1B.7
013C4:  BCF    FF2.7
.................... {
....................     return ((val / 10) << 4) | (val % 10);
013C6:  MOVFF  630,653
013CA:  MOVLW  0A
013CC:  MOVLB  6
013CE:  MOVWF  x54
013D0:  MOVLB  0
013D2:  CALL   02A2
013D6:  BTFSC  1B.7
013D8:  BSF    FF2.7
013DA:  SWAPF  01,W
013DC:  MOVLB  6
013DE:  MOVWF  x31
013E0:  MOVLW  F0
013E2:  ANDWF  x31,F
013E4:  CLRF   1B
013E6:  BTFSC  FF2.7
013E8:  BSF    1B.7
013EA:  BCF    FF2.7
013EC:  MOVFF  630,653
013F0:  MOVLW  0A
013F2:  MOVWF  x54
013F4:  MOVLB  0
013F6:  CALL   02A2
013FA:  BTFSC  1B.7
013FC:  BSF    FF2.7
013FE:  MOVF   00,W
01400:  MOVLB  6
01402:  IORWF  x31,W
01404:  MOVWF  01
01406:  MOVLB  0
01408:  RETURN 0
.................... }
.................... /*
.................... void GetDateTime()
.................... {
....................    
....................    int ii=0;
....................    int xx=0;
....................    char forTime[5]={};
....................    char strDateTime[20] ={};
....................    
....................    strcpy(funcReturnVar,"");
....................    for (xx=0;xx<=5;xx++) 
....................    {
....................       switch(xx) {
....................          case 0:
....................             itoa(years,10,forTime);
....................             break;
....................          case 1:
....................             itoa(months,10,forTime);
....................             break;
....................          case 2:
....................             itoa(days,10,forTime);
....................             break;
....................          case 3:
....................             itoa(hours,10,forTime);
....................             break;
....................          case 4:
....................             itoa(minutes,10,forTime);
....................             break;
....................          case 5:
....................             itoa(seconds,10,forTime);
....................             break;
....................       }
....................       if (strlen(forTime)==4) {
....................          strDateTime[ii++] = forTime[2];
....................          strDateTime[ii++] = forTime[3];
....................          strDateTime[ii++] = ':';
....................          }
....................       else if (strlen(forTime)<2) {
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = forTime[0];
....................          strDateTime[ii++] = ':';
....................          }
....................       else if (strlen(forTime)==2)  {
....................          strDateTime[ii++] = forTime[0];
....................          strDateTime[ii++] = forTime[1];
....................          strDateTime[ii++] = ':';
....................          }
....................       else {
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = ':';
....................          }
....................    }
....................    ii--;
....................    strDateTime[ii] = '\0';
....................   fprintf(PC,"strDateTime=%s\n",strDateTime);
....................    //strcpy(funcReturnVar,strDateTime);
.................... }
.................... */
.................... 
.................... // if storeToVariables = 1 then store rtc configs to date and time variables
.................... // used to read configs from rtc chip 
.................... char *readRtc() //int1 storeToVariables
*
01806:  MOVLB  6
01808:  CLRF   x24
0180A:  CLRF   x25
0180C:  CLRF   x26
0180E:  CLRF   x27
01810:  CLRF   x28
01812:  CLRF   x29
*
0183C:  CLRF   x3E
0183E:  CLRF   x47
.................... {
....................    int seconds=0;
....................    int minutes=0;
....................    int hours=0;
....................    int days=0;
....................    int months=0;
....................    int years=0;
....................     
....................    char strDateTime[20]={};
*
01814:  CLRF   x2A
01816:  CLRF   x2B
01818:  CLRF   x2C
0181A:  CLRF   x2D
0181C:  CLRF   x2E
0181E:  CLRF   x2F
01820:  CLRF   x30
01822:  CLRF   x31
01824:  CLRF   x32
01826:  CLRF   x33
01828:  CLRF   x34
0182A:  CLRF   x35
0182C:  CLRF   x36
0182E:  CLRF   x37
01830:  CLRF   x38
01832:  CLRF   x39
01834:  CLRF   x3A
01836:  CLRF   x3B
01838:  CLRF   x3C
0183A:  CLRF   x3D
....................    int status=0;
....................    int data[8];
....................    int i=0;
....................    
....................    //char *ptr=NULL;
....................    
....................    i2c_start();
*
01840:  BSF    F66.0
01842:  BTFSC  F66.0
01844:  BRA    1842
....................    i2c_write(0xA2);  
01846:  MOVLW  A2
01848:  MOVWF  x48
0184A:  MOVLB  0
0184C:  RCALL  140A
....................    i2c_write(RTC_SEC_REG);
0184E:  MOVLW  03
01850:  MOVLB  6
01852:  MOVWF  x48
01854:  MOVLB  0
01856:  RCALL  140A
....................    i2c_stop(); 
01858:  BSF    F66.2
0185A:  BTFSC  F66.2
0185C:  BRA    185A
....................    
....................    i2c_start();
0185E:  BSF    F66.0
01860:  BTFSC  F66.0
01862:  BRA    1860
....................    status = i2c_write(0xA2|0x01);
01864:  MOVLW  A3
01866:  MOVLB  6
01868:  MOVWF  x48
0186A:  MOVLB  0
0186C:  RCALL  140A
0186E:  MOVFF  01,63E
....................    //fprintf(PC,"for reading=%x\n",status);
....................    
....................    for (i=0;i<7;i++)
01872:  MOVLB  6
01874:  CLRF   x47
01876:  MOVF   x47,W
01878:  SUBLW  06
0187A:  BNC   189C
....................       data[i] = i2c_read();
0187C:  CLRF   03
0187E:  MOVF   x47,W
01880:  ADDLW  3F
01882:  MOVWF  FE9
01884:  MOVLW  06
01886:  ADDWFC 03,W
01888:  MOVWF  FEA
0188A:  MOVLW  01
0188C:  MOVWF  00
0188E:  MOVLB  0
01890:  BRA    16F8
01892:  MOVFF  01,FEF
01896:  MOVLB  6
01898:  INCF   x47,F
0189A:  BRA    1876
....................    i2c_stop(); 
0189C:  BSF    F66.2
0189E:  BTFSC  F66.2
018A0:  BRA    189E
....................    
....................    seconds  = rtcBCDToDec(data[0] & 0x7F);
018A2:  MOVF   x3F,W
018A4:  ANDLW  7F
018A6:  MOVWF  x48
018A8:  MOVWF  x49
018AA:  MOVLB  0
018AC:  RCALL  1716
018AE:  MOVFF  01,624
....................    minutes  = rtcBCDToDec(data[1]);
018B2:  MOVFF  640,649
018B6:  RCALL  1716
018B8:  MOVFF  01,625
....................    hours  = rtcBCDToDec(data[2]);
018BC:  MOVFF  641,649
018C0:  RCALL  1716
018C2:  MOVFF  01,626
....................    days  = rtcBCDToDec(data[3]);
018C6:  MOVFF  642,649
018CA:  RCALL  1716
018CC:  MOVFF  01,627
....................    months  = rtcBCDToDec(data[5]);
018D0:  MOVFF  644,649
018D4:  RCALL  1716
018D6:  MOVFF  01,628
....................    years  = rtcBCDToDec(data[6]);
018DA:  MOVFF  645,649
018DE:  RCALL  1716
018E0:  MOVFF  01,629
....................    //timezone = rtcBCDToDec(data[7]);
....................    
.................... /*   
....................    fprintf(PC,"sec=%u\n",seconds);
....................    fprintf(PC,"minutes=%u\n",minutes);
....................    fprintf(PC,"hours=%u\n",hours);
....................    fprintf(PC,"days=%u\n",days);
....................    fprintf(PC,"months=%u\n",months);
....................    fprintf(PC,"years=%u\n",years);
.................... */  
.................... 
....................    
.................... //!   if (storeToVariables==TRUE) // should be outside this function...
.................... //!   {
.................... //!      SEC = seconds;
.................... //!      MIN = minutes;
.................... //!      HOUR = hours;
.................... //!      DAY = days;
.................... //!      MONTH = months;
.................... //!      YEAR = years;
.................... //!      fprintf(USB,"MCU clock set\n");
.................... //!   }
....................       
....................       sprintf(strDateTime,"%u/%u/%u,%u:%u:%u",years,months,days,hours,minutes,seconds);
018E4:  MOVLW  06
018E6:  MOVLB  4
018E8:  MOVWF  x90
018EA:  MOVLW  2A
018EC:  MOVWF  x8F
018EE:  MOVFF  629,648
018F2:  MOVLW  1B
018F4:  MOVLB  6
018F6:  MOVWF  x49
018F8:  MOVLB  0
018FA:  RCALL  1734
018FC:  MOVLW  2F
018FE:  MOVLB  6
01900:  MOVWF  x4A
01902:  MOVLB  0
01904:  CALL   09A8
01908:  MOVFF  628,648
0190C:  MOVLW  1B
0190E:  MOVLB  6
01910:  MOVWF  x49
01912:  MOVLB  0
01914:  RCALL  1734
01916:  MOVLW  2F
01918:  MOVLB  6
0191A:  MOVWF  x4A
0191C:  MOVLB  0
0191E:  CALL   09A8
01922:  MOVFF  627,648
01926:  MOVLW  1B
01928:  MOVLB  6
0192A:  MOVWF  x49
0192C:  MOVLB  0
0192E:  RCALL  1734
01930:  MOVLW  2C
01932:  MOVLB  6
01934:  MOVWF  x4A
01936:  MOVLB  0
01938:  CALL   09A8
0193C:  MOVFF  626,648
01940:  MOVLW  1B
01942:  MOVLB  6
01944:  MOVWF  x49
01946:  MOVLB  0
01948:  RCALL  1734
0194A:  MOVLW  3A
0194C:  MOVLB  6
0194E:  MOVWF  x4A
01950:  MOVLB  0
01952:  CALL   09A8
01956:  MOVFF  625,648
0195A:  MOVLW  1B
0195C:  MOVLB  6
0195E:  MOVWF  x49
01960:  MOVLB  0
01962:  RCALL  1734
01964:  MOVLW  3A
01966:  MOVLB  6
01968:  MOVWF  x4A
0196A:  MOVLB  0
0196C:  CALL   09A8
01970:  MOVFF  624,648
01974:  MOVLW  1B
01976:  MOVLB  6
01978:  MOVWF  x49
0197A:  MOVLB  0
0197C:  RCALL  1734
....................       fprintf(USB,"RTC date and time: %s\n",strDateTime);
0197E:  MOVLW  84
01980:  MOVWF  FF6
01982:  MOVLW  04
01984:  MOVWF  FF7
01986:  MOVLW  00
01988:  MOVWF  FF8
0198A:  MOVLW  13
0198C:  MOVLB  6
0198E:  MOVWF  x48
01990:  MOVLB  0
01992:  RCALL  17D2
01994:  MOVLW  06
01996:  MOVWF  FEA
01998:  MOVLW  2A
0199A:  MOVWF  FE9
0199C:  CALL   0ACE
019A0:  MOVLW  0A
019A2:  BTFSS  FA4.4
019A4:  BRA    19A2
019A6:  MOVLB  F
019A8:  MOVWF  x1C
....................        
....................    return strDateTime;
019AA:  MOVLW  2A
019AC:  MOVWF  01
019AE:  MOVLW  06
019B0:  MOVWF  02
019B2:  MOVLB  0
019B4:  GOTO   1BE8 (RETURN)
....................    
.................... }
.................... 
.................... 
.................... void configI2C(int param1, int param2)
.................... {
....................    i2c_start(); 
*
01426:  BSF    F66.0
01428:  BTFSC  F66.0
0142A:  BRA    1428
....................    i2c_write(0xA2);  // Status = 0 if got an ACK 
0142C:  MOVLW  A2
0142E:  MOVLB  6
01430:  MOVWF  x48
01432:  MOVLB  0
01434:  RCALL  140A
....................    i2c_write(param1);
01436:  MOVFF  62F,648
0143A:  RCALL  140A
....................    i2c_write(param2);
0143C:  MOVFF  630,648
01440:  RCALL  140A
....................    i2c_stop();
01442:  BSF    F66.2
01444:  BTFSC  F66.2
01446:  BRA    1444
01448:  RETURN 0
.................... }
.................... 
.................... void setRtc(char *input)
0144A:  MOVLB  6
0144C:  CLRF   x10
0144E:  CLRF   x11
01450:  CLRF   x12
01452:  CLRF   x13
01454:  CLRF   x14
01456:  CLRF   x15
.................... {
....................     int seconds=0;
....................     int minutes=0;
....................     int hours=0;
....................     int days=0;
....................     int months=0;
....................     int years=0;
....................     
....................     char temp[20]={};
01458:  CLRF   x16
0145A:  CLRF   x17
0145C:  CLRF   x18
0145E:  CLRF   x19
01460:  CLRF   x1A
01462:  CLRF   x1B
01464:  CLRF   x1C
01466:  CLRF   x1D
01468:  CLRF   x1E
0146A:  CLRF   x1F
0146C:  CLRF   x20
0146E:  CLRF   x21
01470:  CLRF   x22
01472:  CLRF   x23
01474:  CLRF   x24
01476:  CLRF   x25
01478:  CLRF   x26
0147A:  CLRF   x27
0147C:  CLRF   x28
0147E:  CLRF   x29
....................     char tempx[3]={};
01480:  CLRF   x2A
01482:  CLRF   x2B
01484:  CLRF   x2C
....................     char *ptr;
....................     
....................    strcpy(TOKEN,"/,:\"");       //yy/mm/dd,hh:mm:ss
01486:  CLRF   FEA
01488:  MOVLW  22
0148A:  MOVWF  FE9
0148C:  MOVLW  00
0148E:  MOVLB  0
01490:  CALL   0104
01494:  TBLRD*-
01496:  TBLRD*+
01498:  MOVF   FF5,W
0149A:  MOVWF  FEE
0149C:  IORLW  00
0149E:  BNZ   1496
....................    strcpy(temp,input);
014A0:  MOVLW  06
014A2:  MOVWF  FEA
014A4:  MOVLW  16
014A6:  MOVWF  FE9
014A8:  MOVFF  60F,FE2
014AC:  MOVFF  60E,FE1
014B0:  MOVF   FE7,F
014B2:  MOVFF  FE6,FEE
014B6:  BNZ   14B0
....................    delay_ms(150);
014B8:  MOVLW  96
014BA:  MOVLB  6
014BC:  MOVWF  x3F
014BE:  MOVLB  0
014C0:  CALL   0932
....................    ptr = strtok(temp,TOKEN);
014C4:  MOVLW  06
014C6:  MOVLB  6
014C8:  MOVWF  x40
014CA:  MOVLW  16
014CC:  MOVWF  x3F
014CE:  CLRF   x42
014D0:  MOVLW  22
014D2:  MOVWF  x41
014D4:  MOVLB  0
014D6:  RCALL  1128
014D8:  MOVFF  02,62E
014DC:  MOVFF  01,62D
....................    strcpy(tempx,ptr);
014E0:  MOVLW  06
014E2:  MOVWF  FEA
014E4:  MOVLW  2A
014E6:  MOVWF  FE9
014E8:  MOVFF  62E,FE2
014EC:  MOVFF  62D,FE1
014F0:  MOVF   FE7,F
014F2:  MOVFF  FE6,FEE
014F6:  BNZ   14F0
.................... //!   YEAR = atoi(tempx);
....................    years  = rtcDecToBCD(atoi(tempx));
014F8:  MOVLW  06
014FA:  MOVLB  6
014FC:  MOVWF  x40
014FE:  MOVLW  2A
01500:  MOVWF  x3F
01502:  MOVLB  0
01504:  RCALL  122C
01506:  MOVFF  01,62F
0150A:  MOVFF  01,630
0150E:  RCALL  13BE
01510:  MOVFF  01,615
....................    //YEAR = YEAR + 2000;
....................    
....................    ptr = strtok(0,TOKEN);
01514:  MOVLB  6
01516:  CLRF   x40
01518:  CLRF   x3F
0151A:  CLRF   x42
0151C:  MOVLW  22
0151E:  MOVWF  x41
01520:  MOVLB  0
01522:  RCALL  1128
01524:  MOVFF  02,62E
01528:  MOVFF  01,62D
....................    strcpy(tempx,ptr);
0152C:  MOVLW  06
0152E:  MOVWF  FEA
01530:  MOVLW  2A
01532:  MOVWF  FE9
01534:  MOVFF  62E,FE2
01538:  MOVFF  62D,FE1
0153C:  MOVF   FE7,F
0153E:  MOVFF  FE6,FEE
01542:  BNZ   153C
.................... //!   MONTH = atoi(tempx);
....................    months  = rtcDecToBCD(atoi(tempx));
01544:  MOVLW  06
01546:  MOVLB  6
01548:  MOVWF  x40
0154A:  MOVLW  2A
0154C:  MOVWF  x3F
0154E:  MOVLB  0
01550:  RCALL  122C
01552:  MOVFF  01,62F
01556:  MOVFF  01,630
0155A:  RCALL  13BE
0155C:  MOVFF  01,614
....................    
....................    ptr = strtok(0,TOKEN);
01560:  MOVLB  6
01562:  CLRF   x40
01564:  CLRF   x3F
01566:  CLRF   x42
01568:  MOVLW  22
0156A:  MOVWF  x41
0156C:  MOVLB  0
0156E:  RCALL  1128
01570:  MOVFF  02,62E
01574:  MOVFF  01,62D
....................    strcpy(tempx,ptr);
01578:  MOVLW  06
0157A:  MOVWF  FEA
0157C:  MOVLW  2A
0157E:  MOVWF  FE9
01580:  MOVFF  62E,FE2
01584:  MOVFF  62D,FE1
01588:  MOVF   FE7,F
0158A:  MOVFF  FE6,FEE
0158E:  BNZ   1588
.................... //!   DAY = atoi(tempx);
....................    days  = rtcDecToBCD(atoi(tempx));
01590:  MOVLW  06
01592:  MOVLB  6
01594:  MOVWF  x40
01596:  MOVLW  2A
01598:  MOVWF  x3F
0159A:  MOVLB  0
0159C:  RCALL  122C
0159E:  MOVFF  01,62F
015A2:  MOVFF  01,630
015A6:  RCALL  13BE
015A8:  MOVFF  01,613
....................    
....................    ptr = strtok(0,TOKEN);
015AC:  MOVLB  6
015AE:  CLRF   x40
015B0:  CLRF   x3F
015B2:  CLRF   x42
015B4:  MOVLW  22
015B6:  MOVWF  x41
015B8:  MOVLB  0
015BA:  RCALL  1128
015BC:  MOVFF  02,62E
015C0:  MOVFF  01,62D
....................    strcpy(tempx,ptr);
015C4:  MOVLW  06
015C6:  MOVWF  FEA
015C8:  MOVLW  2A
015CA:  MOVWF  FE9
015CC:  MOVFF  62E,FE2
015D0:  MOVFF  62D,FE1
015D4:  MOVF   FE7,F
015D6:  MOVFF  FE6,FEE
015DA:  BNZ   15D4
.................... //!   HOUR = atoi(tempx);
....................    hours  = rtcDecToBCD(atoi(tempx));
015DC:  MOVLW  06
015DE:  MOVLB  6
015E0:  MOVWF  x40
015E2:  MOVLW  2A
015E4:  MOVWF  x3F
015E6:  MOVLB  0
015E8:  RCALL  122C
015EA:  MOVFF  01,62F
015EE:  MOVFF  01,630
015F2:  RCALL  13BE
015F4:  MOVFF  01,612
....................    
....................    ptr = strtok(0,TOKEN);
015F8:  MOVLB  6
015FA:  CLRF   x40
015FC:  CLRF   x3F
015FE:  CLRF   x42
01600:  MOVLW  22
01602:  MOVWF  x41
01604:  MOVLB  0
01606:  RCALL  1128
01608:  MOVFF  02,62E
0160C:  MOVFF  01,62D
....................    strcpy(tempx,ptr);
01610:  MOVLW  06
01612:  MOVWF  FEA
01614:  MOVLW  2A
01616:  MOVWF  FE9
01618:  MOVFF  62E,FE2
0161C:  MOVFF  62D,FE1
01620:  MOVF   FE7,F
01622:  MOVFF  FE6,FEE
01626:  BNZ   1620
.................... //!   MIN = atoi(tempx);
....................    minutes  = rtcDecToBCD(atoi(tempx));
01628:  MOVLW  06
0162A:  MOVLB  6
0162C:  MOVWF  x40
0162E:  MOVLW  2A
01630:  MOVWF  x3F
01632:  MOVLB  0
01634:  RCALL  122C
01636:  MOVFF  01,62F
0163A:  MOVFF  01,630
0163E:  RCALL  13BE
01640:  MOVFF  01,611
....................    
....................    ptr = strtok(0,TOKEN);
01644:  MOVLB  6
01646:  CLRF   x40
01648:  CLRF   x3F
0164A:  CLRF   x42
0164C:  MOVLW  22
0164E:  MOVWF  x41
01650:  MOVLB  0
01652:  RCALL  1128
01654:  MOVFF  02,62E
01658:  MOVFF  01,62D
....................    strcpy(tempx,ptr);
0165C:  MOVLW  06
0165E:  MOVWF  FEA
01660:  MOVLW  2A
01662:  MOVWF  FE9
01664:  MOVFF  62E,FE2
01668:  MOVFF  62D,FE1
0166C:  MOVF   FE7,F
0166E:  MOVFF  FE6,FEE
01672:  BNZ   166C
.................... //!   SEC = atoi(tempx);
....................    seconds  = rtcDecToBCD(atoi(tempx));   
01674:  MOVLW  06
01676:  MOVLB  6
01678:  MOVWF  x40
0167A:  MOVLW  2A
0167C:  MOVWF  x3F
0167E:  MOVLB  0
01680:  RCALL  122C
01682:  MOVFF  01,62F
01686:  MOVFF  01,630
0168A:  RCALL  13BE
0168C:  MOVFF  01,610
....................    
....................     configI2C(RTC_SEC_REG, seconds);
01690:  MOVLW  03
01692:  MOVLB  6
01694:  MOVWF  x2F
01696:  MOVFF  610,630
0169A:  MOVLB  0
0169C:  RCALL  1426
....................     configI2C(RTC_MIN_REG, minutes);
0169E:  MOVLW  04
016A0:  MOVLB  6
016A2:  MOVWF  x2F
016A4:  MOVFF  611,630
016A8:  MOVLB  0
016AA:  RCALL  1426
....................     configI2C(RTC_HOUR_REG, hours);
016AC:  MOVLW  05
016AE:  MOVLB  6
016B0:  MOVWF  x2F
016B2:  MOVFF  612,630
016B6:  MOVLB  0
016B8:  RCALL  1426
....................     configI2C(RTC_DATE_REG, days);
016BA:  MOVLW  06
016BC:  MOVLB  6
016BE:  MOVWF  x2F
016C0:  MOVFF  613,630
016C4:  MOVLB  0
016C6:  RCALL  1426
....................     configI2C(RTC_MONTH_REG, months);
016C8:  MOVLW  08
016CA:  MOVLB  6
016CC:  MOVWF  x2F
016CE:  MOVFF  614,630
016D2:  MOVLB  0
016D4:  RCALL  1426
....................     configI2C(RTC_YEAR_REG, years);
016D6:  MOVLW  09
016D8:  MOVLB  6
016DA:  MOVWF  x2F
016DC:  MOVFF  615,630
016E0:  MOVLB  0
016E2:  RCALL  1426
....................    // readRtc(0);
....................    
....................     fprintf(USB, "RTC updated\n");
016E4:  MOVLW  9C
016E6:  MOVWF  FF6
016E8:  MOVLW  04
016EA:  MOVWF  FF7
016EC:  MOVLW  00
016EE:  MOVWF  FF8
016F0:  CALL   095C
016F4:  GOTO   1D92 (RETURN)
.................... }
.................... 
.................... 
.................... #include <arQ1010/dateTimeDetails.c>
.................... void counterNewYear()
.................... {
....................    char *ptr=NULL;
....................    char temp[20]={};
....................    
....................    if (MIN == 0 && HOUR == 0 && DAY == 31 && MONTH == 12)
....................    {
....................       YEAR_PREV = YEAR - 2000;
....................       fprintf(USB, "YEAR_PREV=%i\n",YEAR_PREV);
....................    }
....................    
....................    if (MIN == 0 && HOUR == 0 && DAY == 1 && MONTH == 1)
....................    {
....................       strcpy(DESIRED_RESPONSE, "+CCLK: ");
....................       delay_ms(100);
....................       YEAR_PREV++;
....................       itoa(YEAR_PREV,10,InterruptUSB_Rxd);
....................       strcpy(temp,"/01/01,00:00:03");
....................       strcat(InterruptUSB_Rxd,temp);
....................       //strcat(InterruptUSB_Rxd,"/01/01,00:00:03");
....................       fprintf(USB, "from COUNTERNEWYEAR =%s\n",InterruptUSB_Rxd);
....................       clear_InterruptUSB();
....................       fprintf(GSM, "AT+CCLK=\"%s\"\r",InterruptUSB_Rxd);
....................       strcpy(InterruptUSB_Rxd,"");
....................       if (GetResponse())
....................          fprintf(USB,"clock set\n");
....................       delay_ms(200);
....................       clear_InterruptUSB();
....................       do {
....................          fprintf(GSM,"AT+CCLK?\r");
....................          delay_ms(200);
....................          ptr = GetResponse();
....................       }while(!ptr);
....................    }
.................... }
.................... 
.................... char *convertDateParam(int param)
.................... {
....................  char *funcSmallStr;
....................    
....................    //fprintf (USB,"param %i\n", param);
....................    
....................    if (param < 10)
*
00AF8:  MOVLB  6
00AFA:  MOVF   x27,W
00AFC:  SUBLW  09
00AFE:  BNC   0B22
....................       sprintf(funcSmallStr,"0%i",param);
00B00:  MOVFF  629,490
00B04:  MOVFF  628,48F
00B08:  MOVLW  30
00B0A:  MOVWF  x4A
00B0C:  MOVLB  0
00B0E:  RCALL  09A8
00B10:  MOVFF  627,62A
00B14:  MOVLW  18
00B16:  MOVLB  6
00B18:  MOVWF  x2B
00B1A:  MOVLB  0
00B1C:  RCALL  09FA
00B1E:  BRA    0B36
00B20:  MOVLB  6
....................    else
....................       sprintf(funcSmallStr,"%i",param);
00B22:  MOVFF  629,490
00B26:  MOVFF  628,48F
00B2A:  MOVFF  627,62A
00B2E:  MOVLW  18
00B30:  MOVWF  x2B
00B32:  MOVLB  0
00B34:  RCALL  09FA
....................    
....................    //fprintf (USB,"funSmallSTr %s\n", funcSmallStr);
....................    
....................    //delay_ms(50);
....................    return funcSmallStr;
00B36:  MOVLB  6
00B38:  MOVFF  628,01
00B3C:  MOVFF  629,02
00B40:  MOVLB  0
00B42:  RETURN 0
....................  }
.................... 
.................... char *getMcuDateTime() 
*
00C2C:  MOVLB  6
00C2E:  CLRF   x24
00C30:  CLRF   x26
00C32:  CLRF   x25
.................... // create a string composed of date and time in the format YY/MM/DD,HH:MM:SS
.................... // store it in funcReturnVar variable 
.................... {
.................... //!   char strDateTime[20] ={};
.................... //!   char *strDateTime;
....................    char charx = NULL;
....................    char *ptr = NULL;
....................       
....................    charx='/'; 
00C34:  MOVLW  2F
00C36:  MOVWF  x24
....................    
....................    //fprintf (USB,"YEAR: %i\n",YEAR);  
.................... //!   ptr = convertDateParam(YEAR);
.................... //!   strcpy(strDateTime,ptr);
....................    strcpy(strDateTime,convertDateParam(YEAR));
00C38:  MOVFF  385,627
00C3C:  MOVLB  0
00C3E:  RCALL  0AF8
00C40:  MOVFF  02,628
00C44:  MOVFF  01,627
00C48:  MOVLW  03
00C4A:  MOVWF  FEA
00C4C:  MOVLW  87
00C4E:  MOVWF  FE9
00C50:  MOVFF  02,FE2
00C54:  MOVFF  01,FE1
00C58:  MOVF   FE7,F
00C5A:  MOVFF  FE6,FEE
00C5E:  BNZ   0C58
.................... //!   strncat(strDateTime,&charx,1);
.................... 
.................... //!   ptr = convertDateParam(MONTH);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(MONTH));
00C60:  MOVFF  384,627
00C64:  RCALL  0AF8
00C66:  MOVFF  02,628
00C6A:  MOVFF  01,627
00C6E:  MOVLW  03
00C70:  MOVLB  6
00C72:  MOVWF  x2A
00C74:  MOVLW  87
00C76:  MOVWF  x29
00C78:  MOVFF  02,62C
00C7C:  MOVFF  01,62B
00C80:  MOVLB  0
00C82:  RCALL  0B44
.................... //!   strncat(strDateTime,&charx,1);
....................    
.................... //!   charx=',';
....................    
.................... //!   ptr = convertDateParam(DAY);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(DAY));
00C84:  MOVFF  383,627
00C88:  RCALL  0AF8
00C8A:  MOVFF  02,628
00C8E:  MOVFF  01,627
00C92:  MOVLW  03
00C94:  MOVLB  6
00C96:  MOVWF  x2A
00C98:  MOVLW  87
00C9A:  MOVWF  x29
00C9C:  MOVFF  02,62C
00CA0:  MOVFF  01,62B
00CA4:  MOVLB  0
00CA6:  RCALL  0B44
....................    strncat(strDateTime,&charx,1);   
00CA8:  MOVLW  03
00CAA:  MOVLB  6
00CAC:  MOVWF  x28
00CAE:  MOVLW  87
00CB0:  MOVWF  x27
00CB2:  MOVLW  06
00CB4:  MOVWF  x2A
00CB6:  MOVLW  24
00CB8:  MOVWF  x29
00CBA:  CLRF   x2C
00CBC:  MOVLW  01
00CBE:  MOVWF  x2B
00CC0:  MOVLB  0
00CC2:  BRA    0BAE
....................    
.................... //!   charx=':';
....................    
.................... //!   ptr = convertDateParam(HOUR);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(HOUR));
00CC4:  MOVFF  382,627
00CC8:  RCALL  0AF8
00CCA:  MOVFF  02,628
00CCE:  MOVFF  01,627
00CD2:  MOVLW  03
00CD4:  MOVLB  6
00CD6:  MOVWF  x2A
00CD8:  MOVLW  87
00CDA:  MOVWF  x29
00CDC:  MOVFF  02,62C
00CE0:  MOVFF  01,62B
00CE4:  MOVLB  0
00CE6:  RCALL  0B44
.................... //!   strncat(strDateTime,&charx,1);
....................    
.................... //!   ptr = convertDateParam(MIN);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(MIN));
00CE8:  MOVFF  381,627
00CEC:  RCALL  0AF8
00CEE:  MOVFF  02,628
00CF2:  MOVFF  01,627
00CF6:  MOVLW  03
00CF8:  MOVLB  6
00CFA:  MOVWF  x2A
00CFC:  MOVLW  87
00CFE:  MOVWF  x29
00D00:  MOVFF  02,62C
00D04:  MOVFF  01,62B
00D08:  MOVLB  0
00D0A:  RCALL  0B44
.................... //!   strncat(strDateTime,&charx,1);
.................... 
.................... //!   ptr = convertDateParam(SEC);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(SEC));
00D0C:  MOVFF  380,627
00D10:  RCALL  0AF8
00D12:  MOVFF  02,628
00D16:  MOVFF  01,627
00D1A:  MOVLW  03
00D1C:  MOVLB  6
00D1E:  MOVWF  x2A
00D20:  MOVLW  87
00D22:  MOVWF  x29
00D24:  MOVFF  02,62C
00D28:  MOVFF  01,62B
00D2C:  MOVLB  0
00D2E:  RCALL  0B44
.................... 
.................... //!   delay_ms(10);
....................   // fprintf(USB,"MCU date and time: %s\n",strDateTime);
....................     //strcpy(globalDT, strDateTime);
....................     
....................    return strDateTime;
00D30:  MOVLW  87
00D32:  MOVWF  01
00D34:  MOVLW  03
00D36:  MOVWF  02
00D38:  RETURN 0
....................    
.................... 
.................... }
.................... void updateMcuDateTime(char *ptx) //converts strings to integer and change date and time values
*
019B8:  MOVLB  6
019BA:  CLRF   x27
019BC:  CLRF   x26
.................... {
....................    char *dataz=NULL;
....................    char temp1[20]={};
019BE:  CLRF   x28
019C0:  CLRF   x29
019C2:  CLRF   x2A
019C4:  CLRF   x2B
019C6:  CLRF   x2C
019C8:  CLRF   x2D
019CA:  CLRF   x2E
019CC:  CLRF   x2F
019CE:  CLRF   x30
019D0:  CLRF   x31
019D2:  CLRF   x32
019D4:  CLRF   x33
019D6:  CLRF   x34
019D8:  CLRF   x35
019DA:  CLRF   x36
019DC:  CLRF   x37
019DE:  CLRF   x38
019E0:  CLRF   x39
019E2:  CLRF   x3A
019E4:  CLRF   x3B
....................    char tempx[3]={};
019E6:  CLRF   x3C
019E8:  CLRF   x3D
019EA:  CLRF   x3E
....................    
....................    //fprintf(USB,"ptx: %s\n",ptx);
....................    
....................    strcpy(TOKEN,"/,:\"");       //yy/mm/dd,hh:mm:ss
019EC:  CLRF   FEA
019EE:  MOVLW  22
019F0:  MOVWF  FE9
019F2:  MOVLW  00
019F4:  MOVLB  0
019F6:  CALL   0104
019FA:  TBLRD*-
019FC:  TBLRD*+
019FE:  MOVF   FF5,W
01A00:  MOVWF  FEE
01A02:  IORLW  00
01A04:  BNZ   19FC
....................    strcpy(temp1,ptx);
01A06:  MOVLW  06
01A08:  MOVWF  FEA
01A0A:  MOVLW  28
01A0C:  MOVWF  FE9
01A0E:  MOVFF  625,FE2
01A12:  MOVFF  624,FE1
01A16:  MOVF   FE7,F
01A18:  MOVFF  FE6,FEE
01A1C:  BNZ   1A16
....................    
....................    delay_ms(150);
01A1E:  MOVLW  96
01A20:  MOVLB  6
01A22:  MOVWF  x3F
01A24:  MOVLB  0
01A26:  CALL   0932
....................    dataz = strtok(temp1,TOKEN);
01A2A:  MOVLW  06
01A2C:  MOVLB  6
01A2E:  MOVWF  x40
01A30:  MOVLW  28
01A32:  MOVWF  x3F
01A34:  CLRF   x42
01A36:  MOVLW  22
01A38:  MOVWF  x41
01A3A:  MOVLB  0
01A3C:  CALL   1128
01A40:  MOVFF  02,627
01A44:  MOVFF  01,626
....................    strcpy(tempx,dataz);
01A48:  MOVLW  06
01A4A:  MOVWF  FEA
01A4C:  MOVLW  3C
01A4E:  MOVWF  FE9
01A50:  MOVFF  627,FE2
01A54:  MOVFF  626,FE1
01A58:  MOVF   FE7,F
01A5A:  MOVFF  FE6,FEE
01A5E:  BNZ   1A58
....................    YEAR = atoi(tempx);
01A60:  MOVLW  06
01A62:  MOVLB  6
01A64:  MOVWF  x40
01A66:  MOVLW  3C
01A68:  MOVWF  x3F
01A6A:  MOVLB  0
01A6C:  CALL   122C
01A70:  MOVFF  01,385
....................    //YEAR = YEAR + 2000;
....................    
....................    dataz = strtok(0,TOKEN);
01A74:  MOVLB  6
01A76:  CLRF   x40
01A78:  CLRF   x3F
01A7A:  CLRF   x42
01A7C:  MOVLW  22
01A7E:  MOVWF  x41
01A80:  MOVLB  0
01A82:  CALL   1128
01A86:  MOVFF  02,627
01A8A:  MOVFF  01,626
....................    strcpy(tempx,dataz);
01A8E:  MOVLW  06
01A90:  MOVWF  FEA
01A92:  MOVLW  3C
01A94:  MOVWF  FE9
01A96:  MOVFF  627,FE2
01A9A:  MOVFF  626,FE1
01A9E:  MOVF   FE7,F
01AA0:  MOVFF  FE6,FEE
01AA4:  BNZ   1A9E
....................    MONTH = atoi(tempx);
01AA6:  MOVLW  06
01AA8:  MOVLB  6
01AAA:  MOVWF  x40
01AAC:  MOVLW  3C
01AAE:  MOVWF  x3F
01AB0:  MOVLB  0
01AB2:  CALL   122C
01AB6:  MOVFF  01,384
....................    
....................    dataz = strtok(0,TOKEN);
01ABA:  MOVLB  6
01ABC:  CLRF   x40
01ABE:  CLRF   x3F
01AC0:  CLRF   x42
01AC2:  MOVLW  22
01AC4:  MOVWF  x41
01AC6:  MOVLB  0
01AC8:  CALL   1128
01ACC:  MOVFF  02,627
01AD0:  MOVFF  01,626
....................    strcpy(tempx,dataz);
01AD4:  MOVLW  06
01AD6:  MOVWF  FEA
01AD8:  MOVLW  3C
01ADA:  MOVWF  FE9
01ADC:  MOVFF  627,FE2
01AE0:  MOVFF  626,FE1
01AE4:  MOVF   FE7,F
01AE6:  MOVFF  FE6,FEE
01AEA:  BNZ   1AE4
....................    DAY = atoi(tempx);
01AEC:  MOVLW  06
01AEE:  MOVLB  6
01AF0:  MOVWF  x40
01AF2:  MOVLW  3C
01AF4:  MOVWF  x3F
01AF6:  MOVLB  0
01AF8:  CALL   122C
01AFC:  MOVFF  01,383
....................    
....................    dataz = strtok(0,TOKEN);
01B00:  MOVLB  6
01B02:  CLRF   x40
01B04:  CLRF   x3F
01B06:  CLRF   x42
01B08:  MOVLW  22
01B0A:  MOVWF  x41
01B0C:  MOVLB  0
01B0E:  CALL   1128
01B12:  MOVFF  02,627
01B16:  MOVFF  01,626
....................    strcpy(tempx,dataz);
01B1A:  MOVLW  06
01B1C:  MOVWF  FEA
01B1E:  MOVLW  3C
01B20:  MOVWF  FE9
01B22:  MOVFF  627,FE2
01B26:  MOVFF  626,FE1
01B2A:  MOVF   FE7,F
01B2C:  MOVFF  FE6,FEE
01B30:  BNZ   1B2A
....................    HOUR = atoi(tempx);
01B32:  MOVLW  06
01B34:  MOVLB  6
01B36:  MOVWF  x40
01B38:  MOVLW  3C
01B3A:  MOVWF  x3F
01B3C:  MOVLB  0
01B3E:  CALL   122C
01B42:  MOVFF  01,382
....................    
....................    dataz = strtok(0,TOKEN);
01B46:  MOVLB  6
01B48:  CLRF   x40
01B4A:  CLRF   x3F
01B4C:  CLRF   x42
01B4E:  MOVLW  22
01B50:  MOVWF  x41
01B52:  MOVLB  0
01B54:  CALL   1128
01B58:  MOVFF  02,627
01B5C:  MOVFF  01,626
....................    strcpy(tempx,dataz);
01B60:  MOVLW  06
01B62:  MOVWF  FEA
01B64:  MOVLW  3C
01B66:  MOVWF  FE9
01B68:  MOVFF  627,FE2
01B6C:  MOVFF  626,FE1
01B70:  MOVF   FE7,F
01B72:  MOVFF  FE6,FEE
01B76:  BNZ   1B70
....................    MIN = atoi(tempx);
01B78:  MOVLW  06
01B7A:  MOVLB  6
01B7C:  MOVWF  x40
01B7E:  MOVLW  3C
01B80:  MOVWF  x3F
01B82:  MOVLB  0
01B84:  CALL   122C
01B88:  MOVFF  01,381
....................    
....................    dataz = strtok(0,TOKEN);
01B8C:  MOVLB  6
01B8E:  CLRF   x40
01B90:  CLRF   x3F
01B92:  CLRF   x42
01B94:  MOVLW  22
01B96:  MOVWF  x41
01B98:  MOVLB  0
01B9A:  CALL   1128
01B9E:  MOVFF  02,627
01BA2:  MOVFF  01,626
....................    strcpy(tempx,dataz);
01BA6:  MOVLW  06
01BA8:  MOVWF  FEA
01BAA:  MOVLW  3C
01BAC:  MOVWF  FE9
01BAE:  MOVFF  627,FE2
01BB2:  MOVFF  626,FE1
01BB6:  MOVF   FE7,F
01BB8:  MOVFF  FE6,FEE
01BBC:  BNZ   1BB6
....................    SEC = atoi(tempx);
01BBE:  MOVLW  06
01BC0:  MOVLB  6
01BC2:  MOVWF  x40
01BC4:  MOVLW  3C
01BC6:  MOVWF  x3F
01BC8:  MOVLB  0
01BCA:  CALL   122C
01BCE:  MOVFF  01,380
.................... 
.................... 
.................... //!   fprintf(USB,"MCU date and time: %u/%u/%u,%u:%u:%u\n",YEAR,MONTH,DAY,HOUR,MIN,SEC);
....................    
.................... 
....................    fprintf(USB,"MCU clock set\n");
01BD2:  MOVLW  F6
01BD4:  MOVWF  FF6
01BD6:  MOVLW  04
01BD8:  MOVWF  FF7
01BDA:  MOVLW  00
01BDC:  MOVWF  FF8
01BDE:  CALL   095C
01BE2:  GOTO   1C16 (RETURN)
....................    
.................... }
.................... 
.................... void rtc_acquire_sync()
.................... { char *ptr;
....................   char temp[20];
....................   
....................   ptr = readRtc();
01BE6:  BRA    1806
01BE8:  MOVFF  02,60F
01BEC:  MOVFF  01,60E
.................... //!  fprintf(USB,"RTC date and time: %s\n",ptr);
.................... 
....................   strcpy(temp,ptr);
01BF0:  MOVLW  06
01BF2:  MOVWF  FEA
01BF4:  MOVLW  10
01BF6:  MOVWF  FE9
01BF8:  MOVFF  60F,FE2
01BFC:  MOVFF  60E,FE1
01C00:  MOVF   FE7,F
01C02:  MOVFF  FE6,FEE
01C06:  BNZ   1C00
....................   updateMcuDateTime(temp);
01C08:  MOVLW  06
01C0A:  MOVLB  6
01C0C:  MOVWF  x25
01C0E:  MOVLW  10
01C10:  MOVWF  x24
01C12:  MOVLB  0
01C14:  BRA    19B8
....................   
....................   ptr=getMcuDateTime();
01C16:  CALL   0C2C
01C1A:  MOVFF  02,60F
01C1E:  MOVFF  01,60E
....................   fprintf(USB,"MCU date and time: %s\n",ptr);
01C22:  MOVLW  06
01C24:  MOVWF  FF6
01C26:  MOVLW  05
01C28:  MOVWF  FF7
01C2A:  MOVLW  00
01C2C:  MOVWF  FF8
01C2E:  MOVLW  13
01C30:  MOVLB  6
01C32:  MOVWF  x48
01C34:  MOVLB  0
01C36:  RCALL  17D2
01C38:  MOVFF  60F,FEA
01C3C:  MOVFF  60E,FE9
01C40:  CALL   0ACE
01C44:  MOVLW  0A
01C46:  BTFSS  FA4.4
01C48:  BRA    1C46
01C4A:  MOVLB  F
01C4C:  MOVWF  x1C
01C4E:  MOVLB  0
01C50:  RETURN 0
.................... 
.................... //!    if(stopBTD200Sampling)
.................... //!      {ptr=getMcuDateTime();
.................... //!       strcpy(temp,ptr);
.................... //!       updateMcuDateTime(temp);
.................... //!      
.................... //!      }        
....................           
.................... }
.................... 
.................... 
.................... //!
.................... //!void rtc_acquire_sync_noGSM()
.................... //!{
.................... //!   readRtc(1);
.................... //!   GetDateTime();
.................... //!   //SetGSMTime(funcReturnVar);   
.................... //!}
.................... 
.................... //!
.................... //!void downloadDateTime()
.................... //!{
.................... //!   getDataFromUSB();
.................... //!   SetGSMTime(FROMSERIALPC);
.................... //!   fprintf(USB,"%s",funcReturnVar);
.................... //!   InsertTimeToVariables(funcReturnVar);
.................... //!}
.................... //!
.................... 
.................... 
.................... 
.................... #include <arQ1010/debugmode.c>
.................... //#use rs232(baud=9600, xmit=PIN_G4, rcv=PIN_G3, stream=IDP)// IDP
.................... 
.................... void debugMenu()
.................... {
....................    //fprintf(USB,"\n    FIRMWARE VERSION: %s\n",FIRMWARE);
....................    
....................    fprintf(USB,"      DEBUG MODE MENU\n");
....................    fprintf(USB,"      A.     Get data from the sensor\n");
....................    fprintf(USB,"      B.     Get arQ's current configurations\n");
....................    fprintf(USB,"      C.     Display DEBUG menu\n");
....................    fprintf(USB,"      D.     Change sending time\n");
....................    fprintf(USB,"      E.     Check satellite sending\n");
....................    fprintf(USB,"      F.     Set server number\n");
....................    fprintf(USB,"      G.     List registered numbers\n");
....................    fprintf(USB,"      H.     Generate CRC code\n");
....................    fprintf(USB,"      I.     Set date and time\n");
....................    fprintf(USB,"      J.     Set power board configuration\n");
.................... //!   fprintf(USB,"      K.     VAISALA settings\n");
....................    fprintf(USB,"      L.     Download data from flash memory\n");
....................    fprintf(USB,"      M.     Change password\n");
....................    fprintf(USB,"      N.     Enable satellite\n");
....................    fprintf(USB,"      O.     Set the sensor type\n");
.................... //!   fprintf(USB,"P.    Rain gauge test\n");
....................    fprintf(USB,"      Q.    Test Iridium satellite commands\n");
....................    //fprintf(USB,"      R.     Set soil sensor (5TE) ID\n");
....................    fprintf(USB,"      S.     Turn off watchdog\n");
.................... //!   fprintf(USB,"      T.     Check boost pin\n");
.................... //!   #ifdef DYNAMICRAIN
.................... //!   fprintf(USB,"U.    Set dynamic rain\n");
.................... //!   #endif
.................... //!   fprintf(USB,"V.    Change RMYOUNG ID\n");
....................    fprintf(USB,"      W.     Exit DEBUG mode\n");
....................    fprintf(USB,"      X.     Delete registered number\n");
....................    //fprintf(USB,"Z.    Change SENSLOPE command\n");
....................    fprintf(USB,"      a.     Register number\n");
....................    //fprintf(USB,"      b.     Set GSM provider\n");
....................    //fprintf(USB,"      c.     Manual GSM commads\n");
....................    //fprintf(USB,"d.    IDP test\n");
....................    delay_ms(10);
.................... }
.................... 
.................... 
.................... int1 debugDetails()
01C52:  MOVLB  5
01C54:  CLRF   x9F
01C56:  CLRF   x9E
01C58:  BCF    xA0.0
.................... {
....................    int16 yy=0;
....................    
....................    int1 exit_=0;
....................    char debugDataInquire[50]={};
01C5A:  CLRF   xA1
01C5C:  CLRF   xA2
01C5E:  CLRF   xA3
01C60:  CLRF   xA4
01C62:  CLRF   xA5
01C64:  CLRF   xA6
01C66:  CLRF   xA7
01C68:  CLRF   xA8
01C6A:  CLRF   xA9
01C6C:  CLRF   xAA
01C6E:  CLRF   xAB
01C70:  CLRF   xAC
01C72:  CLRF   xAD
01C74:  CLRF   xAE
01C76:  CLRF   xAF
01C78:  CLRF   xB0
01C7A:  CLRF   xB1
01C7C:  CLRF   xB2
01C7E:  CLRF   xB3
01C80:  CLRF   xB4
01C82:  CLRF   xB5
01C84:  CLRF   xB6
01C86:  CLRF   xB7
01C88:  CLRF   xB8
01C8A:  CLRF   xB9
01C8C:  CLRF   xBA
01C8E:  CLRF   xBB
01C90:  CLRF   xBC
01C92:  CLRF   xBD
01C94:  CLRF   xBE
01C96:  CLRF   xBF
01C98:  CLRF   xC0
01C9A:  CLRF   xC1
01C9C:  CLRF   xC2
01C9E:  CLRF   xC3
01CA0:  CLRF   xC4
01CA2:  CLRF   xC5
01CA4:  CLRF   xC6
01CA6:  CLRF   xC7
01CA8:  CLRF   xC8
01CAA:  CLRF   xC9
01CAC:  CLRF   xCA
01CAE:  CLRF   xCB
01CB0:  CLRF   xCC
01CB2:  CLRF   xCD
01CB4:  CLRF   xCE
01CB6:  CLRF   xCF
01CB8:  CLRF   xD0
01CBA:  CLRF   xD1
01CBC:  CLRF   xD2
....................    char passwordx[15]={};
01CBE:  CLRF   xD3
01CC0:  CLRF   xD4
01CC2:  CLRF   xD5
01CC4:  CLRF   xD6
01CC6:  CLRF   xD7
01CC8:  CLRF   xD8
01CCA:  CLRF   xD9
01CCC:  CLRF   xDA
01CCE:  CLRF   xDB
01CD0:  CLRF   xDC
01CD2:  CLRF   xDD
01CD4:  CLRF   xDE
01CD6:  CLRF   xDF
01CD8:  CLRF   xE0
01CDA:  CLRF   xE1
....................    
....................    char strx[20]={};
01CDC:  CLRF   xE2
01CDE:  CLRF   xE3
01CE0:  CLRF   xE4
01CE2:  CLRF   xE5
01CE4:  CLRF   xE6
01CE6:  CLRF   xE7
01CE8:  CLRF   xE8
01CEA:  CLRF   xE9
01CEC:  CLRF   xEA
01CEE:  CLRF   xEB
01CF0:  CLRF   xEC
01CF2:  CLRF   xED
01CF4:  CLRF   xEE
01CF6:  CLRF   xEF
01CF8:  CLRF   xF0
01CFA:  CLRF   xF1
01CFC:  CLRF   xF2
01CFE:  CLRF   xF3
01D00:  CLRF   xF4
01D02:  CLRF   xF5
....................    char spacex[2]=" ";
01D04:  MOVLW  20
01D06:  MOVWF  xF6
01D08:  CLRF   xF7
....................    char temp[20]={}; 
01D0A:  CLRF   xF8
01D0C:  CLRF   xF9
01D0E:  CLRF   xFA
01D10:  CLRF   xFB
01D12:  CLRF   xFC
01D14:  CLRF   xFD
01D16:  CLRF   xFE
01D18:  CLRF   xFF
01D1A:  MOVLB  6
01D1C:  CLRF   x00
01D1E:  CLRF   x01
01D20:  CLRF   x02
01D22:  CLRF   x03
01D24:  CLRF   x04
01D26:  CLRF   x05
01D28:  CLRF   x06
01D2A:  CLRF   x07
01D2C:  CLRF   x08
01D2E:  CLRF   x09
01D30:  CLRF   x0A
01D32:  CLRF   x0B
....................    
....................    char *ptrx;
....................  
....................    //strcpy(funcReturnVar,"");
.................... //   readDataEEprom(EEPROM_PASSWORD);
.................... //   strcpy(passwordx,funcReturnVar);
....................    
....................    fprintf(USB,"\nEnter Choice:\n");
01D34:  MOVLW  EA
01D36:  MOVWF  FF6
01D38:  MOVLW  07
01D3A:  MOVWF  FF7
01D3C:  MOVLW  00
01D3E:  MOVWF  FF8
01D40:  MOVLB  0
01D42:  CALL   095C
....................      
....................    getDataFromUSB();
01D46:  CALL   0FE2
....................    
....................    switch(InterruptUSB_Rxd[0])
01D4A:  MOVF   2C,W
01D4C:  XORLW  49
01D4E:  BZ    1D52
01D50:  BRA    1D96
....................    {
....................       case 'I': //SET DATE AND TIME
....................       {  
....................          getMCUDateTime();
01D52:  CALL   0C2C
....................          //fprintf(USB,"Current date and time: %s\n",funcReturnVar);
....................          fprintf(USB,"Press C to change\n");
01D56:  MOVLW  FA
01D58:  MOVWF  FF6
01D5A:  MOVLW  07
01D5C:  MOVWF  FF7
01D5E:  MOVLW  00
01D60:  MOVWF  FF8
01D62:  CALL   095C
....................          
....................          getDataFromUSB();
01D66:  CALL   0FE2
....................                   
....................          if (InterruptUSB_Rxd[0] == 'C')
01D6A:  MOVF   2C,W
01D6C:  SUBLW  43
01D6E:  BNZ   1D94
....................          {
....................             fprintf(USB,"Enter Date and Time (FORMAT \"YY/MM/DD,HH:MM:SS\")");
01D70:  MOVLW  0E
01D72:  MOVWF  FF6
01D74:  MOVLW  08
01D76:  MOVWF  FF7
01D78:  MOVLW  00
01D7A:  MOVWF  FF8
01D7C:  CALL   095C
....................             
....................             getDataFromUSB();
01D80:  CALL   0FE2
....................             
....................             setRtc(InterruptUSB_Rxd);
01D84:  MOVLB  6
01D86:  CLRF   x0F
01D88:  MOVLW  2C
01D8A:  MOVWF  x0E
01D8C:  MOVLB  0
01D8E:  GOTO   144A
....................             
....................             rtc_acquire_sync();
01D92:  RCALL  1BE6
....................             
....................             //delay_ms(50); //needed to stabilize USB input
....................             //sprintf(debugDataInquire,"DATETIME %s %s",passwordx,InterruptUSB_Rxd);
....................            
....................             //fprintf(USB, "%s",debugDataInquire);
....................             // gsmInquire(debugDataInquire,1);
....................            
.................... //!            InsertTimeToVariables(debugDataInquire);
.................... //!            rtcCreateTime();
.................... //!            //dateTimeStatus();
.................... //!            sprintf(SMS_TOBE_SENT,"DT-%s\n",funcReturnVar);
.................... 
....................          }
....................          break;
01D94:  BRA    1DAC
....................       }
.................... //!      case 'J': //PBOARD CONFIG
.................... //!      {
.................... //!         //readDataEEprom(EEPROM_SERVER_IP);
.................... //!         //strcpy(strx,funcReturnVar); // get server ip
.................... //!         fprintf(PC,"PBOARDCONFIG = %s\n",PBOARDCONFIG);
.................... //!         fprintf(PC,"Press C to change\n");
.................... //!         getDataFromPC();
.................... //!         if (FROMSERIALPC[0] == 'C')
.................... //!         {
.................... //!            fprintf(PC,"ENTER NEW VALUE\n");
.................... //!            getDataFromPC();
.................... //!            delay_ms(10);
.................... //!            sprintf(debugDataInquire,"PBOARDCONFIG %s %s",passwordx,FROMSERIALPC);
.................... //!            gsmInquire(debugDataInquire,1);
.................... //!         }   
.................... //!         break;
.................... //!      }
.................... //!
....................       default:
....................          fprintf(USB,"Please choose another letter from the DEBUG menu\n");
01D96:  MOVLW  40
01D98:  MOVWF  FF6
01D9A:  MOVLW  08
01D9C:  MOVWF  FF7
01D9E:  MOVLW  00
01DA0:  MOVWF  FF8
01DA2:  CALL   095C
....................          break;
01DA6:  BRA    1DAC
....................       
....................    clear_InterruptUSB();
01DA8:  CALL   098A
....................    }
....................    return exit_;
01DAC:  MOVLW  00
01DAE:  MOVLB  5
01DB0:  BTFSC  xA0.0
01DB2:  MOVLW  01
01DB4:  MOVWF  01
01DB6:  MOVLB  0
01DB8:  GOTO   229C (RETURN)
.................... }
.................... //!
.................... //!void testDTR()
.................... //!{
.................... //!   int x;
.................... //!   int y=0;
.................... //!   if (DEBUGMODE != IN_DEBUG_MENU)
.................... //!   {
.................... //!      if (input(pin_USB_STAT))
.................... //!      {
.................... //!         for (x=0;x<=60;x++)
.................... //!         {
.................... //!            if (input(pin_USB_STAT)) 
.................... //!               y++;
.................... //!            else
.................... //!               return;
.................... //!            delay_ms(25);
.................... //!         }
.................... //!      }
.................... //!      if (y >= 50)
.................... //!         DEBUGMODE = USB_DETECTED;
.................... //!      else
.................... //!         DEBUGMODE = NO_USB;
.................... //!   }
.................... //!}
.................... 
.................... 
.................... #include <arQ1010/crc_generate.c>
.................... 
.................... int16 crc_generator(int8 *data, int16 len){
....................    int16 i;
....................    int16 crc = 0xFFFF;
....................    char crc_string[6];
....................    
....................    while(len--){
....................       i = make8(crc,1) ^ *data++;
....................       i ^= i>>4;
....................       crc = (crc << 8) ^ (i << 12) ^ (i <<5) ^ i;
....................    }
....................    //fprintf(PC,"CRC: %LX\n",crc);
....................    //sprintf(convto_string, "<%lu>", crc);
....................    itoa(crc,16,crc_string);
....................    //strcpy(funcReturnVar,crc_string);
....................    //fprintf(PC,"string: %lu\n",crc);
.................... 
....................    return crc;
.................... }
.................... 
.................... //#include <arQ1010/voltageDetails.c>
.................... #include <arQ1010/rs485.c>
.................... #define RS485_DE PIN_E5
.................... #define RS485_RE PIN_E6
.................... 
.................... void disable485(){
....................    output_high(RS485_RE);
....................    output_low(RS485_DE);
.................... }
.................... 
.................... void writeToRS485(){
....................    output_high(RS485_RE);
....................    output_high(RS485_DE);
.................... }
....................    
.................... void readFromRS485(){
....................    output_low(RS485_RE);
....................    output_low(RS485_DE);
.................... }
.................... 
.................... 
.................... 
.................... #include <sensors/as3935.h>
.................... #include <sensors/btd200.h>
.................... 
.................... 
.................... void mcuStatusOnStartUp(){
....................    char strx[20] = {};
....................    //char *msgP1=NULL;
....................    char message[40];
*
00D5E:  MOVLB  5
00D60:  CLRF   x9E
00D62:  CLRF   x9F
00D64:  CLRF   xA0
00D66:  CLRF   xA1
00D68:  CLRF   xA2
00D6A:  CLRF   xA3
00D6C:  CLRF   xA4
00D6E:  CLRF   xA5
00D70:  CLRF   xA6
00D72:  CLRF   xA7
00D74:  CLRF   xA8
00D76:  CLRF   xA9
00D78:  CLRF   xAA
00D7A:  CLRF   xAB
00D7C:  CLRF   xAC
00D7E:  CLRF   xAD
00D80:  CLRF   xAE
00D82:  CLRF   xAF
00D84:  CLRF   xB0
00D86:  CLRF   xB1
....................    int cause;
....................    
....................    cause=restart_cause();
....................    switch (cause){
....................       case WDT_TIMEOUT:{ 
00D88:  MOVF   FD0,W
00D8A:  ANDLW  0F
00D8C:  BTFSS  FD0.4
00D8E:  MOVLW  00
00D90:  BSF    FD0.0
00D92:  BSF    FD0.1
00D94:  BSF    FD0.4
00D96:  BSF    FD8.3
00D98:  BSF    FD8.4
00D9A:  MOVWF  xDA
....................           strcpy(strx,"WATCHDOG TIMEOUT");
00D9C:  MOVF   xDA,W
00D9E:  XORLW  07
00DA0:  MOVLB  0
00DA2:  BZ    0DB2
00DA4:  XORLW  0B
00DA6:  BZ    0DCE
00DA8:  XORLW  0C
00DAA:  BZ    0DEA
00DAC:  XORLW  0F
00DAE:  BZ    0E06
00DB0:  BRA    0E22
....................           break;
....................       }
00DB2:  MOVLW  05
00DB4:  MOVWF  FEA
00DB6:  MOVLW  9E
00DB8:  MOVWF  FE9
00DBA:  MOVLW  00
00DBC:  CALL   011E
00DC0:  TBLRD*-
00DC2:  TBLRD*+
00DC4:  MOVF   FF5,W
00DC6:  MOVWF  FEE
00DC8:  IORLW  00
00DCA:  BNZ   0DC2
....................       
00DCC:  BRA    0E5A
....................      
....................       case NORMAL_POWER_UP:{  //12 after upload of firmware
....................          strcpy(strx,"FRESH POWER UP!");
....................          break;
....................       }
00DCE:  MOVLW  05
00DD0:  MOVWF  FEA
00DD2:  MOVLW  9E
00DD4:  MOVWF  FE9
00DD6:  MOVLW  00
00DD8:  CALL   0144
00DDC:  TBLRD*-
00DDE:  TBLRD*+
00DE0:  MOVF   FF5,W
00DE2:  MOVWF  FEE
00DE4:  IORLW  00
00DE6:  BNZ   0DDE
....................       
00DE8:  BRA    0E5A
....................     
....................       case RESET_INSTRUCTION:{   //0
....................          //readDataEEprom(EEPROM_RESET_NUMBER);
....................          strcpy(strx, "SOFTWARE RESET-");
....................          //strcat(strx, funcReturnVar);
....................          break;
00DEA:  MOVLW  05
00DEC:  MOVWF  FEA
00DEE:  MOVLW  9E
00DF0:  MOVWF  FE9
00DF2:  MOVLW  00
00DF4:  CALL   0168
00DF8:  TBLRD*-
00DFA:  TBLRD*+
00DFC:  MOVF   FF5,W
00DFE:  MOVWF  FEE
00E00:  IORLW  00
00E02:  BNZ   0DFA
....................       }
....................       
00E04:  BRA    0E5A
....................       case MCLR_FROM_RUN:{    //15
....................          strcpy(strx,"HARDWARE RESET");
....................          break;
....................       }
00E06:  MOVLW  05
00E08:  MOVWF  FEA
00E0A:  MOVLW  9E
00E0C:  MOVWF  FE9
00E0E:  MOVLW  00
00E10:  CALL   018C
00E14:  TBLRD*-
00E16:  TBLRD*+
00E18:  MOVF   FF5,W
00E1A:  MOVWF  FEE
00E1C:  IORLW  00
00E1E:  BNZ   0E16
....................       
00E20:  BRA    0E5A
....................       default:{
....................          sprintf(strx, "OTHER RESET CAUSE (%i)", cause );
....................       }
....................    }
00E22:  MOVLW  05
00E24:  MOVLB  4
00E26:  MOVWF  x90
00E28:  MOVLW  9E
00E2A:  MOVWF  x8F
00E2C:  MOVLW  72
00E2E:  MOVWF  FF6
00E30:  MOVLW  08
00E32:  MOVWF  FF7
00E34:  MOVLW  00
00E36:  MOVWF  FF8
00E38:  MOVLW  13
00E3A:  MOVLB  5
00E3C:  MOVWF  xDB
00E3E:  MOVLB  0
00E40:  RCALL  09CA
00E42:  MOVFF  5DA,62A
00E46:  MOVLW  18
00E48:  MOVLB  6
00E4A:  MOVWF  x2B
00E4C:  MOVLB  0
00E4E:  RCALL  09FA
00E50:  MOVLW  29
00E52:  MOVLB  6
00E54:  MOVWF  x4A
00E56:  MOVLB  0
00E58:  RCALL  09A8
....................    
....................    fprintf(USB,"%s\n",strx);
....................    //strcpy(SMS_TOBE_SENT,strx);
....................    getMcuDateTime();
00E5A:  MOVLW  05
00E5C:  MOVWF  FEA
00E5E:  MOVLW  9E
00E60:  MOVWF  FE9
00E62:  RCALL  0ACE
00E64:  MOVLW  0A
00E66:  BTFSS  FA4.4
00E68:  BRA    0E66
00E6A:  MOVLB  F
00E6C:  MOVWF  x1C
....................    //sprintf(SMS_TOBE_SENT, "%s - %s", strx, getMcuDateTime()); //getDateTime()
....................    //sprintf(message, "%s - %s", strx, globalDT); //getDateTime()  
00E6E:  MOVLB  0
00E70:  RCALL  0C2C
....................    sprintf(message, "%s - %s", strx, strDateTime); //getDateTime() 
....................    //AttemptToSend(message,MYNUMBER2);
.................... }
00E72:  MOVLW  05
00E74:  MOVLB  4
00E76:  MOVWF  x90
00E78:  MOVLW  B2
00E7A:  MOVWF  x8F
00E7C:  MOVFF  490,FEA
00E80:  MOVFF  48F,FE9
00E84:  CLRF   FEF
00E86:  MOVLW  05
00E88:  MOVWF  FEA
00E8A:  MOVLW  9E
00E8C:  MOVWF  FE9
00E8E:  MOVLB  0
00E90:  RCALL  0D3A
00E92:  MOVLW  8C
00E94:  MOVWF  FF6
00E96:  MOVLW  08
00E98:  MOVWF  FF7
00E9A:  MOVLW  00
00E9C:  MOVWF  FF8
00E9E:  MOVLW  03
00EA0:  MOVLB  5
00EA2:  MOVWF  xDB
00EA4:  MOVLB  0
00EA6:  RCALL  09CA
00EA8:  MOVFF  490,FEA
00EAC:  MOVFF  48F,FE9
00EB0:  CLRF   FEF
00EB2:  MOVLW  03
00EB4:  MOVWF  FEA
00EB6:  MOVLW  87
00EB8:  MOVWF  FE9
00EBA:  RCALL  0D3A
00EBC:  GOTO   2218 (RETURN)
.................... 
.................... 
.................... 
.................... void main(){
....................    char dbg[6]="debug";
....................    char reset[6]="reset";
*
01E02:  CLRF   FF8
01E04:  BCF    FD0.7
01E06:  BSF    07.7
01E08:  MOVLW  72
01E0A:  MOVWF  FD3
01E0C:  CLRF   F9B
01E0E:  CLRF   F64
01E10:  BCF    FC6.5
01E12:  MOVLW  00
01E14:  MOVWF  FC7
01E16:  MOVLW  20
01E18:  MOVWF  FC6
01E1A:  BCF    F94.5
01E1C:  BSF    F94.4
01E1E:  BCF    F94.3
01E20:  BSF    F95.6
01E22:  BSF    F95.5
01E24:  MOVLW  27
01E26:  MOVWF  F69
01E28:  MOVLW  28
01E2A:  MOVWF  F67
01E2C:  BSF    F68.7
01E2E:  BCF    F68.6
01E30:  BCF    F96.4
01E32:  BSF    F8D.4
01E34:  BCF    F98.4
01E36:  BSF    F8F.4
01E38:  BCF    F65.3
01E3A:  MOVLW  0C
01E3C:  MOVWF  FAF
01E3E:  MOVLW  A2
01E40:  MOVWF  FAC
01E42:  MOVLW  90
01E44:  MOVWF  FAB
01E46:  BCF    40.0
01E48:  CLRF   41
01E4A:  BCF    40.1
01E4C:  MOVLB  1
01E4E:  CLRF   x41
01E50:  CLRF   x42
01E52:  CLRF   x43
01E54:  BCF    40.2
01E56:  MOVLB  3
01E58:  CLRF   x80
01E5A:  CLRF   x81
01E5C:  CLRF   x82
01E5E:  CLRF   x83
01E60:  CLRF   x84
01E62:  CLRF   x85
01E64:  CLRF   x86
01E66:  MOVLB  4
01E68:  CLRF   x8B
01E6A:  MOVLW  0F
01E6C:  MOVWF  x8C
01E6E:  BCF    40.3
01E70:  BCF    40.4
01E72:  CLRF   x8D
01E74:  BCF    40.5
01E76:  BCF    40.6
01E78:  BCF    40.7
01E7A:  BCF    x8E.0
01E7C:  MOVLB  F
01E7E:  BSF    x20.3
01E80:  MOVLW  44
01E82:  MOVWF  x1E
01E84:  MOVLW  00
01E86:  MOVWF  x1F
01E88:  MOVLW  A6
01E8A:  MOVWF  x21
01E8C:  MOVLW  90
01E8E:  MOVWF  x22
01E90:  MOVLB  4
01E92:  BCF    x8E.1
01E94:  CLRF   x90
01E96:  CLRF   x8F
01E98:  CLRF   x91
01E9A:  MOVLW  00
01E9C:  MOVLB  F
01E9E:  MOVWF  x23
01EA0:  MOVWF  x24
01EA2:  MOVWF  x25
01EA4:  BCF    FC1.3
01EA6:  BCF    FC1.4
01EA8:  BCF    FC1.5
01EAA:  CLRF   x2E
01EAC:  CLRF   x2F
01EAE:  CLRF   x54
01EB0:  MOVLB  4
01EB2:  BCF    x8E.2
01EB4:  BRA    1ED6
01EB6:  DATA 02,00
01EB8:  DATA 1C,00
01EBA:  DATA 00,1E
01EBC:  DATA 40,22
01EBE:  DATA 00,FF
01EC0:  DATA 40,42
01EC2:  DATA 00,FF
01EC4:  DATA 41,44
01EC6:  DATA 00,FF
01EC8:  DATA C0,00
01ECA:  DATA 3E,C0
01ECC:  DATA 00,FF
01ECE:  DATA 43,87
01ED0:  DATA 00,05
01ED2:  DATA C0,00
01ED4:  DATA 00,00
01ED6:  MOVLW  00
01ED8:  MOVWF  FF8
01EDA:  MOVLW  1E
01EDC:  MOVWF  FF7
01EDE:  MOVLW  B6
01EE0:  MOVWF  FF6
01EE2:  TBLRD*+
01EE4:  MOVF   FF5,W
01EE6:  MOVWF  00
01EE8:  XORLW  00
01EEA:  BZ    1F12
01EEC:  TBLRD*+
01EEE:  MOVF   FF5,W
01EF0:  MOVWF  01
01EF2:  BTFSC  FE8.7
01EF4:  BRA    1F00
01EF6:  ANDLW  3F
01EF8:  MOVWF  FEA
01EFA:  TBLRD*+
01EFC:  MOVFF  FF5,FE9
01F00:  BTFSC  01.6
01F02:  TBLRD*+
01F04:  BTFSS  01.6
01F06:  TBLRD*+
01F08:  MOVFF  FF5,FEE
01F0C:  DCFSNZ 00,F
01F0E:  BRA    1EE2
01F10:  BRA    1F04
01F12:  CLRF   FF8
.................... 
01F14:  MOVLW  64
01F16:  MOVWF  x92
01F18:  MOVLW  65
01F1A:  MOVWF  x93
01F1C:  MOVLW  62
01F1E:  MOVWF  x94
01F20:  MOVLW  75
01F22:  MOVWF  x95
01F24:  MOVLW  67
01F26:  MOVWF  x96
01F28:  CLRF   x97
....................    unsigned int8 tmp1;
01F2A:  MOVLW  72
01F2C:  MOVWF  x98
01F2E:  MOVLW  65
01F30:  MOVWF  x99
01F32:  MOVLW  73
01F34:  MOVWF  x9A
01F36:  MOVLW  65
01F38:  MOVWF  x9B
01F3A:  MOVLW  74
01F3C:  MOVWF  x9C
01F3E:  CLRF   x9D
....................    
....................    //int byteCount;
....................    char message[255]={};
....................    delay_ms(500);
....................    
01F40:  CLRF   x9F
01F42:  CLRF   xA0
01F44:  CLRF   xA1
01F46:  CLRF   xA2
01F48:  CLRF   xA3
01F4A:  CLRF   xA4
01F4C:  CLRF   xA5
01F4E:  CLRF   xA6
01F50:  CLRF   xA7
01F52:  CLRF   xA8
01F54:  CLRF   xA9
01F56:  CLRF   xAA
01F58:  CLRF   xAB
01F5A:  CLRF   xAC
01F5C:  CLRF   xAD
01F5E:  CLRF   xAE
01F60:  CLRF   xAF
01F62:  CLRF   xB0
01F64:  CLRF   xB1
01F66:  CLRF   xB2
01F68:  CLRF   xB3
01F6A:  CLRF   xB4
01F6C:  CLRF   xB5
01F6E:  CLRF   xB6
01F70:  CLRF   xB7
01F72:  CLRF   xB8
01F74:  CLRF   xB9
01F76:  CLRF   xBA
01F78:  CLRF   xBB
01F7A:  CLRF   xBC
01F7C:  CLRF   xBD
01F7E:  CLRF   xBE
01F80:  CLRF   xBF
01F82:  CLRF   xC0
01F84:  CLRF   xC1
01F86:  CLRF   xC2
01F88:  CLRF   xC3
01F8A:  CLRF   xC4
01F8C:  CLRF   xC5
01F8E:  CLRF   xC6
01F90:  CLRF   xC7
01F92:  CLRF   xC8
01F94:  CLRF   xC9
01F96:  CLRF   xCA
01F98:  CLRF   xCB
01F9A:  CLRF   xCC
01F9C:  CLRF   xCD
01F9E:  CLRF   xCE
01FA0:  CLRF   xCF
01FA2:  CLRF   xD0
01FA4:  CLRF   xD1
01FA6:  CLRF   xD2
01FA8:  CLRF   xD3
01FAA:  CLRF   xD4
01FAC:  CLRF   xD5
01FAE:  CLRF   xD6
01FB0:  CLRF   xD7
01FB2:  CLRF   xD8
01FB4:  CLRF   xD9
01FB6:  CLRF   xDA
01FB8:  CLRF   xDB
01FBA:  CLRF   xDC
01FBC:  CLRF   xDD
01FBE:  CLRF   xDE
01FC0:  CLRF   xDF
01FC2:  CLRF   xE0
01FC4:  CLRF   xE1
01FC6:  CLRF   xE2
01FC8:  CLRF   xE3
01FCA:  CLRF   xE4
01FCC:  CLRF   xE5
01FCE:  CLRF   xE6
01FD0:  CLRF   xE7
01FD2:  CLRF   xE8
01FD4:  CLRF   xE9
01FD6:  CLRF   xEA
01FD8:  CLRF   xEB
01FDA:  CLRF   xEC
01FDC:  CLRF   xED
01FDE:  CLRF   xEE
01FE0:  CLRF   xEF
01FE2:  CLRF   xF0
01FE4:  CLRF   xF1
01FE6:  CLRF   xF2
01FE8:  CLRF   xF3
01FEA:  CLRF   xF4
01FEC:  CLRF   xF5
01FEE:  CLRF   xF6
01FF0:  CLRF   xF7
01FF2:  CLRF   xF8
01FF4:  CLRF   xF9
01FF6:  CLRF   xFA
01FF8:  CLRF   xFB
01FFA:  CLRF   xFC
01FFC:  CLRF   xFD
01FFE:  CLRF   xFE
02000:  CLRF   xFF
02002:  MOVLB  5
02004:  CLRF   x00
02006:  CLRF   x01
02008:  CLRF   x02
0200A:  CLRF   x03
0200C:  CLRF   x04
0200E:  CLRF   x05
02010:  CLRF   x06
02012:  CLRF   x07
02014:  CLRF   x08
02016:  CLRF   x09
02018:  CLRF   x0A
0201A:  CLRF   x0B
0201C:  CLRF   x0C
0201E:  CLRF   x0D
02020:  CLRF   x0E
02022:  CLRF   x0F
02024:  CLRF   x10
02026:  CLRF   x11
02028:  CLRF   x12
0202A:  CLRF   x13
0202C:  CLRF   x14
0202E:  CLRF   x15
02030:  CLRF   x16
02032:  CLRF   x17
02034:  CLRF   x18
02036:  CLRF   x19
02038:  CLRF   x1A
0203A:  CLRF   x1B
0203C:  CLRF   x1C
0203E:  CLRF   x1D
02040:  CLRF   x1E
02042:  CLRF   x1F
02044:  CLRF   x20
02046:  CLRF   x21
02048:  CLRF   x22
0204A:  CLRF   x23
0204C:  CLRF   x24
0204E:  CLRF   x25
02050:  CLRF   x26
02052:  CLRF   x27
02054:  CLRF   x28
02056:  CLRF   x29
02058:  CLRF   x2A
0205A:  CLRF   x2B
0205C:  CLRF   x2C
0205E:  CLRF   x2D
02060:  CLRF   x2E
02062:  CLRF   x2F
02064:  CLRF   x30
02066:  CLRF   x31
02068:  CLRF   x32
0206A:  CLRF   x33
0206C:  CLRF   x34
0206E:  CLRF   x35
02070:  CLRF   x36
02072:  CLRF   x37
02074:  CLRF   x38
02076:  CLRF   x39
02078:  CLRF   x3A
0207A:  CLRF   x3B
0207C:  CLRF   x3C
0207E:  CLRF   x3D
02080:  CLRF   x3E
02082:  CLRF   x3F
02084:  CLRF   x40
02086:  CLRF   x41
02088:  CLRF   x42
0208A:  CLRF   x43
0208C:  CLRF   x44
0208E:  CLRF   x45
02090:  CLRF   x46
02092:  CLRF   x47
02094:  CLRF   x48
02096:  CLRF   x49
02098:  CLRF   x4A
0209A:  CLRF   x4B
0209C:  CLRF   x4C
0209E:  CLRF   x4D
020A0:  CLRF   x4E
020A2:  CLRF   x4F
020A4:  CLRF   x50
020A6:  CLRF   x51
020A8:  CLRF   x52
020AA:  CLRF   x53
020AC:  CLRF   x54
020AE:  CLRF   x55
020B0:  CLRF   x56
020B2:  CLRF   x57
020B4:  CLRF   x58
020B6:  CLRF   x59
020B8:  CLRF   x5A
020BA:  CLRF   x5B
020BC:  CLRF   x5C
020BE:  CLRF   x5D
020C0:  CLRF   x5E
020C2:  CLRF   x5F
020C4:  CLRF   x60
020C6:  CLRF   x61
020C8:  CLRF   x62
020CA:  CLRF   x63
020CC:  CLRF   x64
020CE:  CLRF   x65
020D0:  CLRF   x66
020D2:  CLRF   x67
020D4:  CLRF   x68
020D6:  CLRF   x69
020D8:  CLRF   x6A
020DA:  CLRF   x6B
020DC:  CLRF   x6C
020DE:  CLRF   x6D
020E0:  CLRF   x6E
020E2:  CLRF   x6F
020E4:  CLRF   x70
020E6:  CLRF   x71
020E8:  CLRF   x72
020EA:  CLRF   x73
020EC:  CLRF   x74
020EE:  CLRF   x75
020F0:  CLRF   x76
020F2:  CLRF   x77
020F4:  CLRF   x78
020F6:  CLRF   x79
020F8:  CLRF   x7A
020FA:  CLRF   x7B
020FC:  CLRF   x7C
020FE:  CLRF   x7D
02100:  CLRF   x7E
02102:  CLRF   x7F
02104:  CLRF   x80
02106:  CLRF   x81
02108:  CLRF   x82
0210A:  CLRF   x83
0210C:  CLRF   x84
0210E:  CLRF   x85
02110:  CLRF   x86
02112:  CLRF   x87
02114:  CLRF   x88
02116:  CLRF   x89
02118:  CLRF   x8A
0211A:  CLRF   x8B
0211C:  CLRF   x8C
0211E:  CLRF   x8D
02120:  CLRF   x8E
02122:  CLRF   x8F
02124:  CLRF   x90
02126:  CLRF   x91
02128:  CLRF   x92
0212A:  CLRF   x93
0212C:  CLRF   x94
0212E:  CLRF   x95
02130:  CLRF   x96
02132:  CLRF   x97
02134:  CLRF   x98
02136:  CLRF   x99
02138:  CLRF   x9A
0213A:  CLRF   x9B
0213C:  CLRF   x9C
0213E:  CLRF   x9D
....................    fprintf(USB, "\n*************************************************\n");
02140:  MOVLW  02
02142:  MOVWF  x9E
02144:  MOVLW  FA
02146:  MOVLB  6
02148:  MOVWF  x3F
0214A:  MOVLB  0
0214C:  CALL   0932
02150:  MOVLB  5
02152:  DECFSZ x9E,F
02154:  BRA    2144
....................    fprintf(USB, "ULAT Lightning Monitoring Station (Beta version)\n");
....................   
02156:  MOVLW  92
02158:  MOVWF  FF6
0215A:  MOVLW  08
0215C:  MOVWF  FF7
0215E:  MOVLW  00
02160:  MOVWF  FF8
02162:  MOVLB  0
02164:  CALL   095C
....................    enable_interrupts(INT_TIMER1); // enable timer1 interrupt, through the use of the 32 khz oscillator, it will be triggered every second   
02168:  MOVLW  C6
0216A:  MOVWF  FF6
0216C:  MOVLW  08
0216E:  MOVWF  FF7
02170:  MOVLW  00
02172:  MOVWF  FF8
02174:  CALL   095C
....................    enable_interrupts(INT_RDA);    // hardware UART interrupt, used by Radio/GSM module
....................    enable_interrupts(INT_RDA2);   // hardware UART interrupt, used by USB through RS232 interface via the USB port
02178:  BSF    F9D.0
....................    enable_interrupts(INT_EXT);    // B0 used by rain gauge
0217A:  BSF    F9D.5
....................    enable_interrupts(INT_EXT1);   // RING OUT - will be triggered once a call or text is received by the gsm module
0217C:  BSF    FA3.5
....................    //enable_interrupts(INT_EXT2);   // Interrupt 2 is triggered when there is interrupt signal from the AS3935
0217E:  BSF    FF2.4
....................    enable_interrupts(GLOBAL);     // main switch for all the interrupts
02180:  BSF    FF0.3
....................  
....................    ext_int_edge(2,H_TO_L);         // configure INT2 state change to trigger interrupt 2  
02182:  MOVLW  C0
02184:  IORWF  FF2,F
....................    
....................    setup_wdt(WDT_ON);// enable watch dog
02186:  BCF    FF1.4
....................    //setup_wdt(WDT_128S);  
....................    
02188:  BSF    FD1.0
....................    setup_timer_1(T1_EXTERNAL|T1_DIV_BY_1|T1_ENABLE_SOSC); //no T1_CLK_OUT
....................    
....................    setup_spi(SPI_MASTER |SPI_L_TO_H | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);  // Working with AS3935, set as default
0218A:  MOVLW  8F
0218C:  MOVWF  FCD
0218E:  CLRF   FAA
....................     
....................    delay_ms(500);
02190:  BCF    FC6.5
02192:  BCF    F94.5
02194:  BSF    F94.4
02196:  BCF    F94.3
02198:  MOVLW  22
0219A:  MOVWF  FC6
0219C:  MOVLW  00
0219E:  MOVWF  FC7
....................    //Thunder_Init();
....................     
021A0:  MOVLW  02
021A2:  MOVLB  5
021A4:  MOVWF  x9E
021A6:  MOVLW  FA
021A8:  MOVLB  6
021AA:  MOVWF  x3F
021AC:  MOVLB  0
021AE:  CALL   0932
021B2:  MOVLB  5
021B4:  DECFSZ x9E,F
021B6:  BRA    21A6
....................    
....................    //igniteGSM();
....................    //InitGSM();                      // initialize GSM
....................    
....................    
....................    
....................    // igtLTE();
....................    delay_ms(2000);
....................   
....................    
021B8:  MOVLW  08
021BA:  MOVWF  x9E
021BC:  MOVLW  FA
021BE:  MOVLB  6
021C0:  MOVWF  x3F
021C2:  MOVLB  0
021C4:  CALL   0932
021C8:  MOVLB  5
021CA:  DECFSZ x9E,F
021CC:  BRA    21BC
....................    
....................    
....................    //fprintf(GSM, "init\r");
....................    //rtc_acquire_sync();             // sync datetime from rtc chip to both GSM and MCU
....................    
.................... 
....................    InterruptInput2_Flag=0;
....................       
....................    clear_InterruptUSB();
021CE:  MOVLB  4
021D0:  BCF    x8E.1
.................... 
....................   
021D2:  MOVLB  0
021D4:  CALL   098A
....................    //Send to server through message format
.................... 
....................    strcpy(SERVERNUMBER,"639564334913");
....................    //strcpy(MYNUMBER1,"639564334913");
....................    strcpy(MYNUMBER2,"639564334913");
021D8:  MOVLW  01
021DA:  MOVWF  FEA
021DC:  MOVLW  44
021DE:  MOVWF  FE9
021E0:  MOVLW  00
021E2:  CALL   01B0
021E6:  TBLRD*-
021E8:  TBLRD*+
021EA:  MOVF   FF5,W
021EC:  MOVWF  FEE
021EE:  IORLW  00
021F0:  BNZ   21E8
....................    //strcpy(MyNUMBER,"");
....................    SENDING_TIME = 60; //60
021F2:  MOVLW  01
021F4:  MOVWF  FEA
021F6:  MOVLW  62
021F8:  MOVWF  FE9
021FA:  MOVLW  00
021FC:  CALL   01B0
02200:  TBLRD*-
02202:  TBLRD*+
02204:  MOVF   FF5,W
02206:  MOVWF  FEE
02208:  IORLW  00
0220A:  BNZ   2202
....................    
....................    mcuStatusOnStartUp(); // function determines cause of MCU restart
0220C:  MOVLW  3C
0220E:  MOVLB  4
02210:  MOVWF  x8C
....................    
....................    //output_high(pin_BOOST1);  //5 volts
02212:  MOVLB  0
02214:  GOTO   0D5E
....................    //output_high(pin_BOOST2); //18 volts
....................    
....................    fprintf(USB, "\nInitializing BTD200\n");
....................    //igtLTE();
....................    //char gsLTE;
02218:  MOVLW  F8
0221A:  MOVWF  FF6
0221C:  MOVLW  08
0221E:  MOVWF  FF7
02220:  MOVLW  00
02222:  MOVWF  FF8
02224:  CALL   095C
....................   
....................    delay_ms(200);
....................    //clear_inputs();
....................    
02228:  MOVLW  C8
0222A:  MOVLB  6
0222C:  MOVWF  x3F
0222E:  MOVLB  0
02230:  CALL   0932
....................    
....................    delay_ms(200);
....................  
....................    
02234:  MOVLW  C8
02236:  MOVLB  6
02238:  MOVWF  x3F
0223A:  MOVLB  0
0223C:  CALL   0932
....................             
....................    while(1){
....................       restart_wdt();
....................       //readSerial();
....................       
02240:  CLRWDT
....................          
.................... 
....................       if (InterruptUSB_Flag==1){              // if there is a character from USB, the interrupt will trigger            
....................          ledConfig(LED_GREEN);
....................          
02242:  BTFSS  40.0
02244:  BRA    22E8
....................          InterruptUSB_Rxd[InterruptUSB_Counter-1]='\0';       
02246:  MOVLW  01
02248:  MOVLB  5
0224A:  MOVWF  x9F
0224C:  MOVLB  0
0224E:  CALL   0EC0
....................          if (!stricmp(InterruptUSB_Rxd,dbg)){ // if data from USB = debug, it will go into debug mode.
....................             ledConfig(LED_GREEN);
02252:  MOVLW  01
02254:  SUBWF  41,W
02256:  CLRF   03
02258:  ADDLW  2C
0225A:  MOVWF  FE9
0225C:  MOVLW  00
0225E:  ADDWFC 03,W
02260:  MOVWF  FEA
02262:  CLRF   FEF
....................             fprintf(USB,"DEBUG MODE");
02264:  MOVLB  5
02266:  CLRF   x9F
02268:  MOVLW  2C
0226A:  MOVWF  x9E
0226C:  MOVLW  04
0226E:  MOVWF  xA1
02270:  MOVLW  92
02272:  MOVWF  xA0
02274:  MOVLB  0
02276:  CALL   0EEE
0227A:  MOVF   01,F
0227C:  BNZ   229E
....................             debugDetails();
0227E:  MOVLW  01
02280:  MOVLB  5
02282:  MOVWF  x9F
02284:  MOVLB  0
02286:  CALL   0EC0
....................             //whilex=1;
0228A:  MOVLW  0E
0228C:  MOVWF  FF6
0228E:  MOVLW  09
02290:  MOVWF  FF7
02292:  MOVLW  00
02294:  MOVWF  FF8
02296:  CALL   095C
....................             //debugMenu();
0229A:  BRA    1C52
....................             //while(whilex==1){
....................             //if (debugDetails()){
....................                //whilex=0;
....................             //}   
....................          }
....................          
....................          else if (!stricmp(InterruptUSB_Rxd,reset )){ // if data from USB = debug, it will go into debug mode.
0229C:  BRA    22E2
....................             ledConfig(LED_GREEN);
....................             fprintf(USB,"Reset MCU\n");
0229E:  MOVLB  5
022A0:  CLRF   x9F
022A2:  MOVLW  2C
022A4:  MOVWF  x9E
022A6:  MOVLW  04
022A8:  MOVWF  xA1
022AA:  MOVLW  98
022AC:  MOVWF  xA0
022AE:  MOVLB  0
022B0:  CALL   0EEE
022B4:  MOVF   01,F
022B6:  BNZ   22E2
....................             delay_ms(50);
022B8:  MOVLW  01
022BA:  MOVLB  5
022BC:  MOVWF  x9F
022BE:  MOVLB  0
022C0:  CALL   0EC0
....................             reset_cpu();
022C4:  MOVLW  1A
022C6:  MOVWF  FF6
022C8:  MOVLW  09
022CA:  MOVWF  FF7
022CC:  MOVLW  00
022CE:  MOVWF  FF8
022D0:  CALL   095C
....................          }
022D4:  MOVLW  32
022D6:  MOVLB  6
022D8:  MOVWF  x3F
022DA:  MOVLB  0
022DC:  CALL   0932
....................          clear_InterruptUSB();
022E0:  RESET
....................       }
....................         
022E2:  CALL   098A
....................       else{ //nothing happens in otherwords no interrupts  
022E6:  BRA    2356
....................       
....................       if (SAMPLINGFLAG == TRUE){        
....................          ledConfig(LED_GREEN);
....................                
022E8:  BTFSS  40.3
022EA:  BRA    22F8
....................          //readRtc(0);
022EC:  MOVLW  01
022EE:  MOVLB  5
022F0:  MOVWF  x9F
022F2:  MOVLB  0
022F4:  CALL   0EC0
....................          //getMcuDateTime();
....................          //SAMPLINGFLAG = FALSE;
....................       }
....................             
....................       if (SYNCFLAG==TRUE){                      
....................          ledConfig(LED_GREEN);
....................          fprintf(USB,"Time Sync\n");
022F8:  BTFSS  40.7
022FA:  BRA    231C
....................    
022FC:  MOVLW  01
022FE:  MOVLB  5
02300:  MOVWF  x9F
02302:  MOVLB  0
02304:  CALL   0EC0
....................          rtc_acquire_sync();           // sync rtc datetime to both mcu and gsm 
02308:  MOVLW  26
0230A:  MOVWF  FF6
0230C:  MOVLW  09
0230E:  MOVWF  FF7
02310:  MOVLW  00
02312:  MOVWF  FF8
02314:  CALL   095C
....................          SYNCFLAG = FALSE;             // two minutes before reaching the next hour, this will be activated      
....................       }
02318:  RCALL  1BE6
....................                
0231A:  BCF    40.7
....................       if (RESETFLAG==TRUE){                      
....................          ledConfig(LED_GREEN);
....................          //Thunder_Init();
0231C:  MOVLB  4
0231E:  BTFSS  x8E.0
02320:  BRA    2332
....................          RESETFLAG=FALSE;
02322:  MOVLW  01
02324:  MOVLB  5
02326:  MOVWF  x9F
02328:  MOVLB  0
0232A:  CALL   0EC0
....................       }   
....................                
0232E:  MOVLB  4
02330:  BCF    x8E.0
....................             
....................       ledToggle(LED_GREEN);
....................       delay_ms(500);                   
....................       }  
02332:  MOVLW  01
02334:  MOVLB  5
02336:  MOVWF  x9E
02338:  MOVLB  0
0233A:  BRA    1DBC
....................    }
0233C:  MOVLW  02
0233E:  MOVLB  5
02340:  MOVWF  x9E
02342:  MOVLW  FA
02344:  MOVLB  6
02346:  MOVWF  x3F
02348:  MOVLB  0
0234A:  CALL   0932
0234E:  MOVLB  5
02350:  DECFSZ x9E,F
02352:  BRA    2342
02354:  MOVLB  0
.................... }  
02356:  BRA    2240
.................... 
.................... 
.................... 
02358:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: 481D   VREGSLEEP INTRC_HP SOSC_HIGH NOXINST INTRC_IO NOPLLEN FCMEN NOIESO
   Word  2: 3E7E   PUT BROWNOUT BORV18 ZPBORM WDT_SW WDT32768
   Word  3: 8BF9   RTCOSC_T1 EXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
