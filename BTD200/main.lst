CCS PCH C Compiler, Version 5.091, 49613               08-Aug-25 15:59

               Filename:   C:\Users\JohnCarloBCarbonel\gitProject\BTD200\main.lst

               ROM used:   23102 bytes (18%)
                           Largest free fragment is 65536
               RAM used:   1441 (37%) at main() level
                           1786 (46%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

00000:  GOTO   56CC
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   0726
00068:  BTFSS  FF0.3
0006A:  GOTO   0074
0006E:  BTFSC  FF0.0
00070:  GOTO   031C
00074:  BTFSS  FF0.4
00076:  GOTO   0080
0007A:  BTFSC  FF0.1
0007C:  GOTO   033A
00080:  BTFSS  F9D.5
00082:  GOTO   008C
00086:  BTFSC  F9E.5
00088:  GOTO   02F8
0008C:  BTFSS  FA3.5
0008E:  GOTO   0098
00092:  BTFSC  FA4.5
00094:  GOTO   02C4
00098:  MOVFF  0E,00
0009C:  MOVFF  0F,01
000A0:  MOVFF  10,02
000A4:  MOVFF  11,03
000A8:  MOVFF  0C,FE9
000AC:  MOVFF  07,FEA
000B0:  BSF    07.7
000B2:  MOVFF  08,FE1
000B6:  MOVFF  09,FE2
000BA:  MOVFF  0A,FD9
000BE:  MOVFF  0B,FDA
000C2:  MOVFF  12,FF3
000C6:  MOVFF  13,FF4
000CA:  MOVFF  14,FFA
000CE:  MOVFF  15,FF5
000D2:  MOVFF  16,FF6
000D6:  MOVFF  17,FF7
000DA:  MOVFF  18,FF8
000DE:  MOVFF  19,FFB
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
.................... //Author: Glenn Vincent Lopez
.................... //May 11, 2022
.................... 
.................... #include <18F87K22.h>
.................... //////////// Standard Header file for the PIC18F87K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F87K22
000EE:  CLRF   FF7
000F0:  ADDLW  02
000F2:  MOVWF  FF6
000F4:  MOVLW  01
000F6:  ADDWFC FF7,F
000F8:  MOVLW  00
000FA:  MOVWF  FF8
000FC:  TBLRD*+
000FE:  MOVF   FF5,W
00100:  RETURN 0
00102:  DATA 00,00
00104:  CLRF   FF7
00106:  ADDLW  18
00108:  MOVWF  FF6
0010A:  MOVLW  01
0010C:  ADDWFC FF7,F
0010E:  MOVLW  00
00110:  MOVWF  FF8
00112:  TBLRD*+
00114:  MOVF   FF5,W
00116:  RETURN 0
00118:  DATA 4F,4B
0011A:  DATA 00,00
0011C:  CLRF   FF7
0011E:  ADDLW  30
00120:  MOVWF  FF6
00122:  MOVLW  01
00124:  ADDWFC FF7,F
00126:  MOVLW  00
00128:  MOVWF  FF8
0012A:  TBLRD*+
0012C:  MOVF   FF5,W
0012E:  RETURN 0
00130:  DATA 2F,2C
00132:  DATA 3A,22
00134:  DATA 00,00
00136:  CLRF   FF7
00138:  ADDLW  4A
0013A:  MOVWF  FF6
0013C:  MOVLW  01
0013E:  ADDWFC FF7,F
00140:  MOVLW  00
00142:  MOVWF  FF8
00144:  TBLRD*+
00146:  MOVF   FF5,W
00148:  RETURN 0
0014A:  DATA 42,54
0014C:  DATA 44,72
0014E:  DATA 65,63
00150:  DATA 6F,6E
00152:  DATA 0D,00
00154:  CLRF   FF7
00156:  ADDLW  68
00158:  MOVWF  FF6
0015A:  MOVLW  01
0015C:  ADDWFC FF7,F
0015E:  MOVLW  00
00160:  MOVWF  FF8
00162:  TBLRD*+
00164:  MOVF   FF5,W
00166:  RETURN 0
00168:  DATA 42,54
0016A:  DATA 44,63
0016C:  DATA 6F,6E
0016E:  DATA 0D,00
00170:  CLRF   FF7
00172:  ADDLW  84
00174:  MOVWF  FF6
00176:  MOVLW  01
00178:  ADDWFC FF7,F
0017A:  MOVLW  00
0017C:  MOVWF  FF8
0017E:  TBLRD*+
00180:  MOVF   FF5,W
00182:  RETURN 0
00184:  DATA 42,54
00186:  DATA 44,73
00188:  DATA 74,61
0018A:  DATA 62,6C
0018C:  DATA 65,0D
0018E:  DATA 00,00
00190:  CLRF   FF7
00192:  ADDLW  A4
00194:  MOVWF  FF6
00196:  MOVLW  01
00198:  ADDWFC FF7,F
0019A:  MOVLW  00
0019C:  MOVWF  FF8
0019E:  TBLRD*+
001A0:  MOVF   FF5,W
001A2:  RETURN 0
001A4:  DATA 52,4D
001A6:  DATA 53,2A
001A8:  DATA 00,00
001AA:  CLRF   FF7
001AC:  ADDLW  BE
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  MOVLW  00
001B6:  MOVWF  FF8
001B8:  TBLRD*+
001BA:  MOVF   FF5,W
001BC:  RETURN 0
001BE:  DATA 4E,46
001C0:  DATA 44,2A
001C2:  DATA 00,00
001C4:  CLRF   FF7
001C6:  ADDLW  D8
001C8:  MOVWF  FF6
001CA:  MOVLW  01
001CC:  ADDWFC FF7,F
001CE:  MOVLW  00
001D0:  MOVWF  FF8
001D2:  TBLRD*+
001D4:  MOVF   FF5,W
001D6:  RETURN 0
001D8:  DATA 43,52
001DA:  DATA 53,2A
001DC:  DATA 00,00
001DE:  CLRF   FF7
001E0:  ADDLW  F2
001E2:  MOVWF  FF6
001E4:  MOVLW  01
001E6:  ADDWFC FF7,F
001E8:  MOVLW  00
001EA:  MOVWF  FF8
001EC:  TBLRD*+
001EE:  MOVF   FF5,W
001F0:  RETURN 0
001F2:  DATA 43,57
001F4:  DATA 53,2A
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 2E,2B
0020E:  DATA 00,00
00210:  CLRF   FF7
00212:  ADDLW  24
00214:  MOVWF  FF6
00216:  MOVLW  02
00218:  ADDWFC FF7,F
0021A:  MOVLW  00
0021C:  MOVWF  FF8
0021E:  TBLRD*+
00220:  MOVF   FF5,W
00222:  RETURN 0
00224:  DATA 57,41
00226:  DATA 54,43
00228:  DATA 48,44
0022A:  DATA 4F,47
0022C:  DATA 20,54
0022E:  DATA 49,4D
00230:  DATA 45,4F
00232:  DATA 55,54
00234:  DATA 00,00
00236:  CLRF   FF7
00238:  ADDLW  4A
0023A:  MOVWF  FF6
0023C:  MOVLW  02
0023E:  ADDWFC FF7,F
00240:  MOVLW  00
00242:  MOVWF  FF8
00244:  TBLRD*+
00246:  MOVF   FF5,W
00248:  RETURN 0
0024A:  DATA 46,52
0024C:  DATA 45,53
0024E:  DATA 48,20
00250:  DATA 50,4F
00252:  DATA 57,45
00254:  DATA 52,20
00256:  DATA 55,50
00258:  DATA 21,00
0025A:  CLRF   FF7
0025C:  ADDLW  6E
0025E:  MOVWF  FF6
00260:  MOVLW  02
00262:  ADDWFC FF7,F
00264:  MOVLW  00
00266:  MOVWF  FF8
00268:  TBLRD*+
0026A:  MOVF   FF5,W
0026C:  RETURN 0
0026E:  DATA 53,4F
00270:  DATA 46,54
00272:  DATA 57,41
00274:  DATA 52,45
00276:  DATA 20,52
00278:  DATA 45,53
0027A:  DATA 45,54
0027C:  DATA 2D,00
0027E:  CLRF   FF7
00280:  ADDLW  92
00282:  MOVWF  FF6
00284:  MOVLW  02
00286:  ADDWFC FF7,F
00288:  MOVLW  00
0028A:  MOVWF  FF8
0028C:  TBLRD*+
0028E:  MOVF   FF5,W
00290:  RETURN 0
00292:  DATA 48,41
00294:  DATA 52,44
00296:  DATA 57,41
00298:  DATA 52,45
0029A:  DATA 20,52
0029C:  DATA 45,53
0029E:  DATA 45,54
002A0:  DATA 00,00
002A2:  CLRF   FF7
002A4:  ADDLW  B6
002A6:  MOVWF  FF6
002A8:  MOVLW  02
002AA:  ADDWFC FF7,F
002AC:  MOVLW  00
002AE:  MOVWF  FF8
002B0:  TBLRD*+
002B2:  MOVF   FF5,W
002B4:  RETURN 0
002B6:  DATA 36,33
002B8:  DATA 39,35
002BA:  DATA 36,34
002BC:  DATA 33,33
002BE:  DATA 34,39
002C0:  DATA 31,33
002C2:  DATA 00,00
*
00346:  DATA 41,54
00348:  DATA 2B,43
0034A:  DATA 4F,50
0034C:  DATA 53,3F
0034E:  DATA 0D,00
00350:  DATA 41,54
00352:  DATA 2B,43
00354:  DATA 52,45
00356:  DATA 47,3F
00358:  DATA 0D,00
0035A:  DATA 41,54
0035C:  DATA 0D,00
0035E:  DATA 47,53
00360:  DATA 4D,20
00362:  DATA 6D,6F
00364:  DATA 64,75
00366:  DATA 6C,65
00368:  DATA 20,61
0036A:  DATA 63,74
0036C:  DATA 69,76
0036E:  DATA 65,0A
00370:  DATA 00,00
00372:  DATA 47,53
00374:  DATA 4D,20
00376:  DATA 6D,6F
00378:  DATA 64,75
0037A:  DATA 6C,65
0037C:  DATA 20,6E
0037E:  DATA 6F,20
00380:  DATA 72,65
00382:  DATA 73,70
00384:  DATA 6F,6E
00386:  DATA 73,65
00388:  DATA 0A,00
0038A:  DATA 49,67
0038C:  DATA 6E,69
0038E:  DATA 74,65
00390:  DATA 20,47
00392:  DATA 53,4D
00394:  DATA 20,6D
00396:  DATA 6F,64
00398:  DATA 75,6C
0039A:  DATA 65,0A
0039C:  DATA 00,00
0039E:  DATA 41,54
003A0:  DATA 5E,53
003A2:  DATA 4D,53
003A4:  DATA 4F,0D
003A6:  DATA 00,00
003A8:  DATA 47,53
003AA:  DATA 4D,20
003AC:  DATA 4D,6F
003AE:  DATA 64,75
003B0:  DATA 6C,65
003B2:  DATA 20,53
003B4:  DATA 68,75
003B6:  DATA 74,64
003B8:  DATA 6F,77
003BA:  DATA 6E,0A
003BC:  DATA 00,00
003BE:  DATA 49,6E
003C0:  DATA 69,74
003C2:  DATA 69,61
003C4:  DATA 6C,69
003C6:  DATA 7A,65
003C8:  DATA 20,47
003CA:  DATA 53,4D
003CC:  DATA 20,4D
003CE:  DATA 6F,64
003D0:  DATA 75,6C
003D2:  DATA 65,0A
003D4:  DATA 00,00
003D6:  DATA 43,68
003D8:  DATA 65,63
003DA:  DATA 6B,69
003DC:  DATA 6E,67
003DE:  DATA 20,6E
003E0:  DATA 65,74
003E2:  DATA 77,6F
003E4:  DATA 72,6B
003E6:  DATA 20,72
003E8:  DATA 65,67
003EA:  DATA 69,73
003EC:  DATA 74,72
003EE:  DATA 61,74
003F0:  DATA 69,6F
003F2:  DATA 6E,2C
003F4:  DATA 20,70
003F6:  DATA 6C,65
003F8:  DATA 61,73
003FA:  DATA 65,20
003FC:  DATA 77,61
003FE:  DATA 69,74
00400:  DATA 0A,00
00402:  DATA 52,65
00404:  DATA 67,69
00406:  DATA 73,74
00408:  DATA 65,72
0040A:  DATA 65,64
0040C:  DATA 20,74
0040E:  DATA 6F,20
00410:  DATA 6E,65
00412:  DATA 74,77
00414:  DATA 6F,72
00416:  DATA 6B,3A
00418:  DATA 20,25
0041A:  DATA 73,0A
0041C:  DATA 00,00
0041E:  DATA 4E,65
00420:  DATA 74,77
00422:  DATA 6F,72
00424:  DATA 6B,20
00426:  DATA 72,65
00428:  DATA 67,69
0042A:  DATA 73,74
0042C:  DATA 72,61
0042E:  DATA 74,69
00430:  DATA 6F,6E
00432:  DATA 20,66
00434:  DATA 61,69
00436:  DATA 6C,65
00438:  DATA 64,0A
0043A:  DATA 00,00
0043C:  DATA 50,65
0043E:  DATA 72,66
00440:  DATA 6F,72
00442:  DATA 6D,69
00444:  DATA 6E,67
00446:  DATA 20,47
00448:  DATA 53,4D
0044A:  DATA 20,6D
0044C:  DATA 6F,64
0044E:  DATA 75,6C
00450:  DATA 65,20
00452:  DATA 72,65
00454:  DATA 62,6F
00456:  DATA 6F,74
00458:  DATA 0A,00
0045A:  DATA 41,54
0045C:  DATA 26,46
0045E:  DATA 30,0D
00460:  DATA 00,00
00462:  DATA 41,54
00464:  DATA 45,30
00466:  DATA 0D,00
00468:  DATA 41,54
0046A:  DATA 5E,53
0046C:  DATA 53,59
0046E:  DATA 4E,43
00470:  DATA 3D,31
00472:  DATA 0D,00
00474:  DATA 41,54
00476:  DATA 2B,43
00478:  DATA 4E,4D
0047A:  DATA 49,3D
0047C:  DATA 31,2C
0047E:  DATA 31,2C
00480:  DATA 30,2C
00482:  DATA 30,2C
00484:  DATA 31,0D
00486:  DATA 00,00
00488:  DATA 41,54
0048A:  DATA 2B,43
0048C:  DATA 4D,47
0048E:  DATA 46,3D
00490:  DATA 31,0D
00492:  DATA 00,00
00494:  DATA 41,54
00496:  DATA 2B,43
00498:  DATA 53,4D
0049A:  DATA 53,3D
0049C:  DATA 30,0D
0049E:  DATA 00,00
004A0:  DATA 41,54
004A2:  DATA 2B,43
004A4:  DATA 4C,49
004A6:  DATA 50,3D
004A8:  DATA 31,0D
004AA:  DATA 00,00
004AC:  DATA 41,54
004AE:  DATA 2B,43
004B0:  DATA 50,42
004B2:  DATA 53,3D
004B4:  DATA 4F,4E
004B6:  DATA 0D,00
004B8:  DATA 41,54
004BA:  DATA 2B,43
004BC:  DATA 50,4D
004BE:  DATA 53,3D
004C0:  DATA 4D,54
004C2:  DATA 2C,4D
004C4:  DATA 54,2C
004C6:  DATA 4D,54
004C8:  DATA 0D,00
004CA:  DATA 47,53
004CC:  DATA 4D,20
004CE:  DATA 72,65
004D0:  DATA 61,64
004D2:  DATA 79,0A
004D4:  DATA 00,00
004D6:  DATA 41,54
004D8:  DATA 2B,43
004DA:  DATA 4D,47
004DC:  DATA 44,3D
004DE:  DATA 25,69
004E0:  DATA 0D,00
004E2:  DATA 41,54
004E4:  DATA 2B,43
004E6:  DATA 4D,47
004E8:  DATA 53,3D
004EA:  DATA 25,63
004EC:  DATA 25,73
004EE:  DATA 25,63
004F0:  DATA 2C,31
004F2:  DATA 32,39
004F4:  DATA 0D,00
004F6:  DATA 4D,65
004F8:  DATA 73,73
004FA:  DATA 61,67
004FC:  DATA 65,20
004FE:  DATA 73,65
00500:  DATA 6E,74
00502:  DATA 20,74
00504:  DATA 6F,3A
00506:  DATA 20,25
00508:  DATA 73,0A
0050A:  DATA 00,00
0050C:  DATA 47,53
0050E:  DATA 4D,20
00510:  DATA 65,72
00512:  DATA 72,6F
00514:  DATA 72,20
00516:  DATA 32,3A
00518:  DATA 20,4D
0051A:  DATA 65,73
0051C:  DATA 73,61
0051E:  DATA 67,65
00520:  DATA 20,4E
00522:  DATA 4F,54
00524:  DATA 20,73
00526:  DATA 65,6E
00528:  DATA 74,2E
0052A:  DATA 0A,00
0052C:  DATA 47,53
0052E:  DATA 4D,20
00530:  DATA 54,69
00532:  DATA 6D,65
00534:  DATA 6F,75
00536:  DATA 74,20
00538:  DATA 32,3A
0053A:  DATA 20,4D
0053C:  DATA 65,73
0053E:  DATA 73,61
00540:  DATA 67,65
00542:  DATA 20,4E
00544:  DATA 4F,54
00546:  DATA 20,73
00548:  DATA 65,6E
0054A:  DATA 74,2E
0054C:  DATA 0A,00
0054E:  DATA 47,53
00550:  DATA 4D,20
00552:  DATA 65,72
00554:  DATA 72,6F
00556:  DATA 72,20
00558:  DATA 31,3A
0055A:  DATA 20,20
0055C:  DATA 4D,65
0055E:  DATA 73,73
00560:  DATA 61,67
00562:  DATA 65,20
00564:  DATA 4E,4F
00566:  DATA 54,20
00568:  DATA 73,65
0056A:  DATA 6E,74
0056C:  DATA 2E,0A
0056E:  DATA 00,00
00570:  DATA 47,53
00572:  DATA 4D,20
00574:  DATA 54,69
00576:  DATA 6D,65
00578:  DATA 6F,75
0057A:  DATA 74,20
0057C:  DATA 31,3A
0057E:  DATA 20,4D
00580:  DATA 65,73
00582:  DATA 73,61
00584:  DATA 67,65
00586:  DATA 20,4E
00588:  DATA 4F,54
0058A:  DATA 20,73
0058C:  DATA 65,6E
0058E:  DATA 74,2E
00590:  DATA 0A,00
00592:  DATA 41,54
00594:  DATA 2B,43
00596:  DATA 53,51
00598:  DATA 0D,00
0059A:  DATA 53,4D
0059C:  DATA 53,3A
0059E:  DATA 20,25
005A0:  DATA 73,0A
005A2:  DATA 00,00
005A4:  DATA 54,72
005A6:  DATA 79,20
005A8:  DATA 74,6F
005AA:  DATA 20,73
005AC:  DATA 65,6E
005AE:  DATA 64,20
005B0:  DATA 25,69
005B2:  DATA 20,2D
005B4:  DATA 3E,20
005B6:  DATA 00,00
005B8:  DATA 41,54
005BA:  DATA 2B,43
005BC:  DATA 43,4C
005BE:  DATA 4B,3D
005C0:  DATA 22,25
005C2:  DATA 73,22
005C4:  DATA 0D,00
005C6:  DATA 47,53
005C8:  DATA 4D,20
005CA:  DATA 63,6C
005CC:  DATA 6F,63
005CE:  DATA 6B,20
005D0:  DATA 73,65
005D2:  DATA 74,0A
005D4:  DATA 00,00
005D6:  DATA 47,53
005D8:  DATA 4D,20
005DA:  DATA 63,6C
005DC:  DATA 6F,63
005DE:  DATA 6B,20
005E0:  DATA 4E,4F
005E2:  DATA 54,20
005E4:  DATA 73,65
005E6:  DATA 74,0A
005E8:  DATA 00,00
005EA:  DATA 41,54
005EC:  DATA 2B,43
005EE:  DATA 43,4C
005F0:  DATA 4B,3F
005F2:  DATA 0D,00
005F4:  DATA 69,6E
005F6:  DATA 69,74
005F8:  DATA 0D,00
005FA:  DATA 4C,54
005FC:  DATA 45,20
005FE:  DATA 49,6E
00600:  DATA 69,74
00602:  DATA 69,61
00604:  DATA 6C,69
00606:  DATA 7A,65
00608:  DATA 64,0A
0060A:  DATA 00,00
0060C:  DATA 73,69
0060E:  DATA 67,6E
00610:  DATA 61,6C
00612:  DATA 0D,00
00614:  DATA 0A,53
00616:  DATA 4D,53
00618:  DATA 20,53
0061A:  DATA 65,6E
0061C:  DATA 74,3A
0061E:  DATA 20,25
00620:  DATA 73,0A
00622:  DATA 00,00
00624:  DATA 4F,46
00626:  DATA 46,0D
00628:  DATA 00,00
0062A:  DATA 4F,4E
0062C:  DATA 0D,00
0062E:  DATA 69,67
00630:  DATA 74,0D
00632:  DATA 00,00
00634:  DATA 4C,54
00636:  DATA 45,20
00638:  DATA 49,67
0063A:  DATA 6E,69
0063C:  DATA 74,65
0063E:  DATA 64,0A
00640:  DATA 00,00
00642:  MOVLB  6
00644:  MOVF   xF6,W
00646:  CLRF   01
00648:  SUBWF  xF5,W
0064A:  BC    0652
0064C:  MOVFF  6F5,00
00650:  BRA    066A
00652:  CLRF   00
00654:  MOVLW  08
00656:  MOVWF  xF7
00658:  RLCF   xF5,F
0065A:  RLCF   00,F
0065C:  MOVF   xF6,W
0065E:  SUBWF  00,W
00660:  BTFSC  FD8.0
00662:  MOVWF  00
00664:  RLCF   01,F
00666:  DECFSZ xF7,F
00668:  BRA    0658
0066A:  MOVLB  0
0066C:  RETURN 0
0066E:  CLRF   01
00670:  CLRF   02
00672:  CLRF   00
00674:  CLRF   03
00676:  MOVLB  6
00678:  MOVF   xF8,W
0067A:  BNZ   0680
0067C:  MOVF   xF7,W
0067E:  BZ    06B0
00680:  MOVLW  10
00682:  MOVWF  xF9
00684:  BCF    FD8.0
00686:  RLCF   xF5,F
00688:  RLCF   xF6,F
0068A:  RLCF   00,F
0068C:  RLCF   03,F
0068E:  MOVF   xF8,W
00690:  SUBWF  03,W
00692:  BNZ   0698
00694:  MOVF   xF7,W
00696:  SUBWF  00,W
00698:  BNC   06A8
0069A:  MOVF   xF7,W
0069C:  SUBWF  00,F
0069E:  BTFSS  FD8.0
006A0:  DECF   03,F
006A2:  MOVF   xF8,W
006A4:  SUBWF  03,F
006A6:  BSF    FD8.0
006A8:  RLCF   01,F
006AA:  RLCF   02,F
006AC:  DECFSZ xF9,F
006AE:  BRA    0684
006B0:  MOVLB  0
006B2:  GOTO   06FE (RETURN)
*
00824:  DATA 52,54
00826:  DATA 43,20
00828:  DATA 64,61
0082A:  DATA 74,65
0082C:  DATA 20,61
0082E:  DATA 6E,64
00830:  DATA 20,74
00832:  DATA 69,6D
00834:  DATA 65,3A
00836:  DATA 20,25
00838:  DATA 73,0A
0083A:  DATA 00,00
0083C:  DATA 52,54
0083E:  DATA 43,20
00840:  DATA 75,70
00842:  DATA 64,61
00844:  DATA 74,65
00846:  DATA 64,0A
00848:  DATA 00,00
0084A:  DATA 59,45
0084C:  DATA 41,52
0084E:  DATA 5F,50
00850:  DATA 52,45
00852:  DATA 56,3D
00854:  DATA 25,69
00856:  DATA 0A,00
00858:  DATA 66,72
0085A:  DATA 6F,6D
0085C:  DATA 20,43
0085E:  DATA 4F,55
00860:  DATA 4E,54
00862:  DATA 45,52
00864:  DATA 4E,45
00866:  DATA 57,59
00868:  DATA 45,41
0086A:  DATA 52,20
0086C:  DATA 3D,25
0086E:  DATA 73,0A
00870:  DATA 00,00
00872:  DATA 41,54
00874:  DATA 2B,43
00876:  DATA 43,4C
00878:  DATA 4B,3D
0087A:  DATA 22,25
0087C:  DATA 73,22
0087E:  DATA 0D,00
00880:  DATA 63,6C
00882:  DATA 6F,63
00884:  DATA 6B,20
00886:  DATA 73,65
00888:  DATA 74,0A
0088A:  DATA 00,00
0088C:  DATA 41,54
0088E:  DATA 2B,43
00890:  DATA 43,4C
00892:  DATA 4B,3F
00894:  DATA 0D,00
00896:  DATA 4D,43
00898:  DATA 55,20
0089A:  DATA 63,6C
0089C:  DATA 6F,63
0089E:  DATA 6B,20
008A0:  DATA 73,65
008A2:  DATA 74,0A
008A4:  DATA 00,00
008A6:  DATA 4D,43
008A8:  DATA 55,20
008AA:  DATA 64,61
008AC:  DATA 74,65
008AE:  DATA 20,61
008B0:  DATA 6E,64
008B2:  DATA 20,74
008B4:  DATA 69,6D
008B6:  DATA 65,3A
008B8:  DATA 20,25
008BA:  DATA 73,0A
008BC:  DATA 00,00
008BE:  DATA 20,20
008C0:  DATA 20,20
008C2:  DATA 20,20
008C4:  DATA 44,45
008C6:  DATA 42,55
008C8:  DATA 47,20
008CA:  DATA 4D,4F
008CC:  DATA 44,45
008CE:  DATA 20,4D
008D0:  DATA 45,4E
008D2:  DATA 55,0A
008D4:  DATA 00,00
008D6:  DATA 20,20
008D8:  DATA 20,20
008DA:  DATA 20,20
008DC:  DATA 41,2E
008DE:  DATA 20,20
008E0:  DATA 20,20
008E2:  DATA 20,47
008E4:  DATA 65,74
008E6:  DATA 20,64
008E8:  DATA 61,74
008EA:  DATA 61,20
008EC:  DATA 66,72
008EE:  DATA 6F,6D
008F0:  DATA 20,74
008F2:  DATA 68,65
008F4:  DATA 20,73
008F6:  DATA 65,6E
008F8:  DATA 73,6F
008FA:  DATA 72,0A
008FC:  DATA 00,00
008FE:  DATA 20,20
00900:  DATA 20,20
00902:  DATA 20,20
00904:  DATA 42,2E
00906:  DATA 20,20
00908:  DATA 20,20
0090A:  DATA 20,47
0090C:  DATA 65,74
0090E:  DATA 20,61
00910:  DATA 72,51
00912:  DATA 27,73
00914:  DATA 20,63
00916:  DATA 75,72
00918:  DATA 72,65
0091A:  DATA 6E,74
0091C:  DATA 20,63
0091E:  DATA 6F,6E
00920:  DATA 66,69
00922:  DATA 67,75
00924:  DATA 72,61
00926:  DATA 74,69
00928:  DATA 6F,6E
0092A:  DATA 73,0A
0092C:  DATA 00,00
0092E:  DATA 20,20
00930:  DATA 20,20
00932:  DATA 20,20
00934:  DATA 43,2E
00936:  DATA 20,20
00938:  DATA 20,20
0093A:  DATA 20,44
0093C:  DATA 69,73
0093E:  DATA 70,6C
00940:  DATA 61,79
00942:  DATA 20,44
00944:  DATA 45,42
00946:  DATA 55,47
00948:  DATA 20,6D
0094A:  DATA 65,6E
0094C:  DATA 75,0A
0094E:  DATA 00,00
00950:  DATA 20,20
00952:  DATA 20,20
00954:  DATA 20,20
00956:  DATA 44,2E
00958:  DATA 20,20
0095A:  DATA 20,20
0095C:  DATA 20,43
0095E:  DATA 68,61
00960:  DATA 6E,67
00962:  DATA 65,20
00964:  DATA 73,65
00966:  DATA 6E,64
00968:  DATA 69,6E
0096A:  DATA 67,20
0096C:  DATA 74,69
0096E:  DATA 6D,65
00970:  DATA 0A,00
00972:  DATA 20,20
00974:  DATA 20,20
00976:  DATA 20,20
00978:  DATA 45,2E
0097A:  DATA 20,20
0097C:  DATA 20,20
0097E:  DATA 20,43
00980:  DATA 68,65
00982:  DATA 63,6B
00984:  DATA 20,73
00986:  DATA 61,74
00988:  DATA 65,6C
0098A:  DATA 6C,69
0098C:  DATA 74,65
0098E:  DATA 20,73
00990:  DATA 65,6E
00992:  DATA 64,69
00994:  DATA 6E,67
00996:  DATA 0A,00
00998:  DATA 20,20
0099A:  DATA 20,20
0099C:  DATA 20,20
0099E:  DATA 46,2E
009A0:  DATA 20,20
009A2:  DATA 20,20
009A4:  DATA 20,53
009A6:  DATA 65,74
009A8:  DATA 20,73
009AA:  DATA 65,72
009AC:  DATA 76,65
009AE:  DATA 72,20
009B0:  DATA 6E,75
009B2:  DATA 6D,62
009B4:  DATA 65,72
009B6:  DATA 0A,00
009B8:  DATA 20,20
009BA:  DATA 20,20
009BC:  DATA 20,20
009BE:  DATA 47,2E
009C0:  DATA 20,20
009C2:  DATA 20,20
009C4:  DATA 20,4C
009C6:  DATA 69,73
009C8:  DATA 74,20
009CA:  DATA 72,65
009CC:  DATA 67,69
009CE:  DATA 73,74
009D0:  DATA 65,72
009D2:  DATA 65,64
009D4:  DATA 20,6E
009D6:  DATA 75,6D
009D8:  DATA 62,65
009DA:  DATA 72,73
009DC:  DATA 0A,00
009DE:  DATA 20,20
009E0:  DATA 20,20
009E2:  DATA 20,20
009E4:  DATA 48,2E
009E6:  DATA 20,20
009E8:  DATA 20,20
009EA:  DATA 20,47
009EC:  DATA 65,6E
009EE:  DATA 65,72
009F0:  DATA 61,74
009F2:  DATA 65,20
009F4:  DATA 43,52
009F6:  DATA 43,20
009F8:  DATA 63,6F
009FA:  DATA 64,65
009FC:  DATA 0A,00
009FE:  DATA 20,20
00A00:  DATA 20,20
00A02:  DATA 20,20
00A04:  DATA 49,2E
00A06:  DATA 20,20
00A08:  DATA 20,20
00A0A:  DATA 20,53
00A0C:  DATA 65,74
00A0E:  DATA 20,64
00A10:  DATA 61,74
00A12:  DATA 65,20
00A14:  DATA 61,6E
00A16:  DATA 64,20
00A18:  DATA 74,69
00A1A:  DATA 6D,65
00A1C:  DATA 0A,00
00A1E:  DATA 20,20
00A20:  DATA 20,20
00A22:  DATA 20,20
00A24:  DATA 4A,2E
00A26:  DATA 20,20
00A28:  DATA 20,20
00A2A:  DATA 20,53
00A2C:  DATA 65,74
00A2E:  DATA 20,70
00A30:  DATA 6F,77
00A32:  DATA 65,72
00A34:  DATA 20,62
00A36:  DATA 6F,61
00A38:  DATA 72,64
00A3A:  DATA 20,63
00A3C:  DATA 6F,6E
00A3E:  DATA 66,69
00A40:  DATA 67,75
00A42:  DATA 72,61
00A44:  DATA 74,69
00A46:  DATA 6F,6E
00A48:  DATA 0A,00
00A4A:  DATA 20,20
00A4C:  DATA 20,20
00A4E:  DATA 20,20
00A50:  DATA 4C,2E
00A52:  DATA 20,20
00A54:  DATA 20,20
00A56:  DATA 20,44
00A58:  DATA 6F,77
00A5A:  DATA 6E,6C
00A5C:  DATA 6F,61
00A5E:  DATA 64,20
00A60:  DATA 64,61
00A62:  DATA 74,61
00A64:  DATA 20,66
00A66:  DATA 72,6F
00A68:  DATA 6D,20
00A6A:  DATA 66,6C
00A6C:  DATA 61,73
00A6E:  DATA 68,20
00A70:  DATA 6D,65
00A72:  DATA 6D,6F
00A74:  DATA 72,79
00A76:  DATA 0A,00
00A78:  DATA 20,20
00A7A:  DATA 20,20
00A7C:  DATA 20,20
00A7E:  DATA 4D,2E
00A80:  DATA 20,20
00A82:  DATA 20,20
00A84:  DATA 20,43
00A86:  DATA 68,61
00A88:  DATA 6E,67
00A8A:  DATA 65,20
00A8C:  DATA 70,61
00A8E:  DATA 73,73
00A90:  DATA 77,6F
00A92:  DATA 72,64
00A94:  DATA 0A,00
00A96:  DATA 20,20
00A98:  DATA 20,20
00A9A:  DATA 20,20
00A9C:  DATA 4E,2E
00A9E:  DATA 20,20
00AA0:  DATA 20,20
00AA2:  DATA 20,45
00AA4:  DATA 6E,61
00AA6:  DATA 62,6C
00AA8:  DATA 65,20
00AAA:  DATA 73,61
00AAC:  DATA 74,65
00AAE:  DATA 6C,6C
00AB0:  DATA 69,74
00AB2:  DATA 65,0A
00AB4:  DATA 00,00
00AB6:  DATA 20,20
00AB8:  DATA 20,20
00ABA:  DATA 20,20
00ABC:  DATA 4F,2E
00ABE:  DATA 20,20
00AC0:  DATA 20,20
00AC2:  DATA 20,53
00AC4:  DATA 65,74
00AC6:  DATA 20,74
00AC8:  DATA 68,65
00ACA:  DATA 20,73
00ACC:  DATA 65,6E
00ACE:  DATA 73,6F
00AD0:  DATA 72,20
00AD2:  DATA 74,79
00AD4:  DATA 70,65
00AD6:  DATA 0A,00
00AD8:  DATA 20,20
00ADA:  DATA 20,20
00ADC:  DATA 20,20
00ADE:  DATA 51,2E
00AE0:  DATA 20,20
00AE2:  DATA 20,20
00AE4:  DATA 54,65
00AE6:  DATA 73,74
00AE8:  DATA 20,49
00AEA:  DATA 72,69
00AEC:  DATA 64,69
00AEE:  DATA 75,6D
00AF0:  DATA 20,73
00AF2:  DATA 61,74
00AF4:  DATA 65,6C
00AF6:  DATA 6C,69
00AF8:  DATA 74,65
00AFA:  DATA 20,63
00AFC:  DATA 6F,6D
00AFE:  DATA 6D,61
00B00:  DATA 6E,64
00B02:  DATA 73,0A
00B04:  DATA 00,00
00B06:  DATA 20,20
00B08:  DATA 20,20
00B0A:  DATA 20,20
00B0C:  DATA 53,2E
00B0E:  DATA 20,20
00B10:  DATA 20,20
00B12:  DATA 20,54
00B14:  DATA 75,72
00B16:  DATA 6E,20
00B18:  DATA 6F,66
00B1A:  DATA 66,20
00B1C:  DATA 77,61
00B1E:  DATA 74,63
00B20:  DATA 68,64
00B22:  DATA 6F,67
00B24:  DATA 0A,00
00B26:  DATA 20,20
00B28:  DATA 20,20
00B2A:  DATA 20,20
00B2C:  DATA 57,2E
00B2E:  DATA 20,20
00B30:  DATA 20,20
00B32:  DATA 20,45
00B34:  DATA 78,69
00B36:  DATA 74,20
00B38:  DATA 44,45
00B3A:  DATA 42,55
00B3C:  DATA 47,20
00B3E:  DATA 6D,6F
00B40:  DATA 64,65
00B42:  DATA 0A,00
00B44:  DATA 20,20
00B46:  DATA 20,20
00B48:  DATA 20,20
00B4A:  DATA 58,2E
00B4C:  DATA 20,20
00B4E:  DATA 20,20
00B50:  DATA 20,44
00B52:  DATA 65,6C
00B54:  DATA 65,74
00B56:  DATA 65,20
00B58:  DATA 72,65
00B5A:  DATA 67,69
00B5C:  DATA 73,74
00B5E:  DATA 65,72
00B60:  DATA 65,64
00B62:  DATA 20,6E
00B64:  DATA 75,6D
00B66:  DATA 62,65
00B68:  DATA 72,0A
00B6A:  DATA 00,00
00B6C:  DATA 20,20
00B6E:  DATA 20,20
00B70:  DATA 20,20
00B72:  DATA 61,2E
00B74:  DATA 20,20
00B76:  DATA 20,20
00B78:  DATA 20,52
00B7A:  DATA 65,67
00B7C:  DATA 69,73
00B7E:  DATA 74,65
00B80:  DATA 72,20
00B82:  DATA 6E,75
00B84:  DATA 6D,62
00B86:  DATA 65,72
00B88:  DATA 0A,00
00B8A:  DATA 0A,45
00B8C:  DATA 6E,74
00B8E:  DATA 65,72
00B90:  DATA 20,43
00B92:  DATA 68,6F
00B94:  DATA 69,63
00B96:  DATA 65,3A
00B98:  DATA 0A,00
00B9A:  DATA 50,72
00B9C:  DATA 65,73
00B9E:  DATA 73,20
00BA0:  DATA 43,20
00BA2:  DATA 74,6F
00BA4:  DATA 20,63
00BA6:  DATA 68,61
00BA8:  DATA 6E,67
00BAA:  DATA 65,0A
00BAC:  DATA 00,00
00BAE:  DATA 45,6E
00BB0:  DATA 74,65
00BB2:  DATA 72,20
00BB4:  DATA 44,61
00BB6:  DATA 74,65
00BB8:  DATA 20,61
00BBA:  DATA 6E,64
00BBC:  DATA 20,54
00BBE:  DATA 69,6D
00BC0:  DATA 65,20
00BC2:  DATA 28,46
00BC4:  DATA 4F,52
00BC6:  DATA 4D,41
00BC8:  DATA 54,20
00BCA:  DATA 22,59
00BCC:  DATA 59,2F
00BCE:  DATA 4D,4D
00BD0:  DATA 2F,44
00BD2:  DATA 44,2C
00BD4:  DATA 48,48
00BD6:  DATA 3A,4D
00BD8:  DATA 4D,3A
00BDA:  DATA 53,53
00BDC:  DATA 22,29
00BDE:  DATA 00,00
00BE0:  DATA 50,6C
00BE2:  DATA 65,61
00BE4:  DATA 73,65
00BE6:  DATA 20,63
00BE8:  DATA 68,6F
00BEA:  DATA 6F,73
00BEC:  DATA 65,20
00BEE:  DATA 61,6E
00BF0:  DATA 6F,74
00BF2:  DATA 68,65
00BF4:  DATA 72,20
00BF6:  DATA 6C,65
00BF8:  DATA 74,74
00BFA:  DATA 65,72
00BFC:  DATA 20,66
00BFE:  DATA 72,6F
00C00:  DATA 6D,20
00C02:  DATA 74,68
00C04:  DATA 65,20
00C06:  DATA 44,45
00C08:  DATA 42,55
00C0A:  DATA 47,20
00C0C:  DATA 6D,65
00C0E:  DATA 6E,75
00C10:  DATA 0A,00
00C12:  DATA 41,53
00C14:  DATA 33,39
00C16:  DATA 33,35
00C18:  DATA 20,52
00C1A:  DATA 65,61
00C1C:  DATA 64,79
00C1E:  DATA 0A,00
00C20:  DATA 0A,4C
00C22:  DATA 69,67
00C24:  DATA 68,74
00C26:  DATA 6E,69
00C28:  DATA 6E,67
00C2A:  DATA 20,44
00C2C:  DATA 65,74
00C2E:  DATA 65,63
00C30:  DATA 74,65
00C32:  DATA 64,21
00C34:  DATA 21,21
00C36:  DATA 0A,2A
00C38:  DATA 2A,2A
00C3A:  DATA 2A,2A
00C3C:  DATA 2A,2A
00C3E:  DATA 2A,2A
00C40:  DATA 2A,2A
00C42:  DATA 2A,2A
00C44:  DATA 2A,2A
00C46:  DATA 2A,2A
00C48:  DATA 2A,2A
00C4A:  DATA 2A,2A
00C4C:  DATA 2A,2A
00C4E:  DATA 2A,2A
00C50:  DATA 2A,2A
00C52:  DATA 2A,2A
00C54:  DATA 2A,2A
00C56:  DATA 2A,2A
00C58:  DATA 2A,2A
00C5A:  DATA 2A,2A
00C5C:  DATA 2A,2A
00C5E:  DATA 2A,2A
00C60:  DATA 2A,2A
00C62:  DATA 2A,2A
00C64:  DATA 2A,2A
00C66:  DATA 2A,2A
00C68:  DATA 2A,2A
00C6A:  DATA 2A,2A
00C6C:  DATA 2A,2A
00C6E:  DATA 2A,2A
00C70:  DATA 2A,2A
00C72:  DATA 2A,2A
00C74:  DATA 2A,2A
00C76:  DATA 2A,2A
00C78:  DATA 2A,2A
00C7A:  DATA 2A,2A
00C7C:  DATA 2A,2A
00C7E:  DATA 2A,2A
00C80:  DATA 2A,2A
00C82:  DATA 2A,2A
00C84:  DATA 2A,2A
00C86:  DATA 2A,2A
00C88:  DATA 2A,2A
00C8A:  DATA 2A,2A
00C8C:  DATA 2A,2A
00C8E:  DATA 2A,2A
00C90:  DATA 2A,2A
00C92:  DATA 2A,2A
00C94:  DATA 2A,2A
00C96:  DATA 2A,2A
00C98:  DATA 2A,2A
00C9A:  DATA 2A,2A
00C9C:  DATA 2A,2A
00C9E:  DATA 2A,2A
00CA0:  DATA 2A,2A
00CA2:  DATA 2A,2A
00CA4:  DATA 2A,2A
00CA6:  DATA 2A,2A
00CA8:  DATA 2A,2A
00CAA:  DATA 2A,2A
00CAC:  DATA 2A,2A
00CAE:  DATA 2A,2A
00CB0:  DATA 2A,2A
00CB2:  DATA 2A,2A
00CB4:  DATA 2A,2A
00CB6:  DATA 2A,2A
00CB8:  DATA 2A,2A
00CBA:  DATA 2A,2A
00CBC:  DATA 2A,2A
00CBE:  DATA 2A,2A
00CC0:  DATA 2A,2A
00CC2:  DATA 2A,2A
00CC4:  DATA 2A,2A
00CC6:  DATA 2A,2A
00CC8:  DATA 2A,2A
00CCA:  DATA 2A,2A
00CCC:  DATA 2A,00
00CCE:  DATA 46,43
00CD0:  DATA 3A,25
00CD2:  DATA 73,2B
00CD4:  DATA 25,73
00CD6:  DATA 47,53
00CD8:  DATA 3A,2A
00CDA:  DATA 2B,42
00CDC:  DATA 54,3A
00CDE:  DATA 25,73
00CE0:  DATA 2B,44
00CE2:  DATA 54,3A
00CE4:  DATA 2A,0D
00CE6:  DATA 00,00
00CE8:  DATA 53,4D
00CEA:  DATA 53,20
00CEC:  DATA 74,6F
00CEE:  DATA 20,53
00CF0:  DATA 65,6E
00CF2:  DATA 74,3A
00CF4:  DATA 20,25
00CF6:  DATA 73,00
00CF8:  DATA 44,61
00CFA:  DATA 74,65
00CFC:  DATA 2D,54
00CFE:  DATA 69,6D
00D00:  DATA 65,3A
00D02:  DATA 20,25
00D04:  DATA 73,0A
00D06:  DATA 00,00
00D08:  DATA 53,4D
00D0A:  DATA 53,20
00D0C:  DATA 74,6F
00D0E:  DATA 20,53
00D10:  DATA 65,6E
00D12:  DATA 74,3A
00D14:  DATA 20,25
00D16:  DATA 73,00
00D18:  DATA 44,61
00D1A:  DATA 74,65
00D1C:  DATA 2D,54
00D1E:  DATA 69,6D
00D20:  DATA 65,3A
00D22:  DATA 20,25
00D24:  DATA 73,0A
00D26:  DATA 00,00
00D28:  DATA 53,4D
00D2A:  DATA 53,20
00D2C:  DATA 74,6F
00D2E:  DATA 20,53
00D30:  DATA 65,6E
00D32:  DATA 74,3A
00D34:  DATA 20,25
00D36:  DATA 73,00
00D38:  DATA 44,61
00D3A:  DATA 74,65
00D3C:  DATA 2D,54
00D3E:  DATA 69,6D
00D40:  DATA 65,3A
00D42:  DATA 20,25
00D44:  DATA 73,0A
00D46:  DATA 00,00
00D48:  DATA 53,4D
00D4A:  DATA 53,20
00D4C:  DATA 74,6F
00D4E:  DATA 20,53
00D50:  DATA 65,6E
00D52:  DATA 74,3A
00D54:  DATA 20,25
00D56:  DATA 73,00
00D58:  DATA 44,61
00D5A:  DATA 74,65
00D5C:  DATA 2D,54
00D5E:  DATA 69,6D
00D60:  DATA 65,3A
00D62:  DATA 20,25
00D64:  DATA 73,0A
00D66:  DATA 00,00
00D68:  DATA 53,4D
00D6A:  DATA 53,20
00D6C:  DATA 74,6F
00D6E:  DATA 20,53
00D70:  DATA 65,6E
00D72:  DATA 74,3A
00D74:  DATA 20,25
00D76:  DATA 73,00
00D78:  DATA 44,61
00D7A:  DATA 74,65
00D7C:  DATA 2D,54
00D7E:  DATA 69,6D
00D80:  DATA 65,3A
00D82:  DATA 20,25
00D84:  DATA 73,0A
00D86:  DATA 00,00
00D88:  DATA 53,4D
00D8A:  DATA 53,20
00D8C:  DATA 74,6F
00D8E:  DATA 20,53
00D90:  DATA 65,6E
00D92:  DATA 74,3A
00D94:  DATA 20,25
00D96:  DATA 73,00
00D98:  DATA 0A,41
00D9A:  DATA 52,51
00D9C:  DATA 20,41
00D9E:  DATA 63,63
00DA0:  DATA 65,70
00DA2:  DATA 74,73
00DA4:  DATA 20,52
00DA6:  DATA 65,71
00DA8:  DATA 75,65
00DAA:  DATA 73,74
00DAC:  DATA 0A,00
00DAE:  DATA 4D,65
00DB0:  DATA 73,73
00DB2:  DATA 61,67
00DB4:  DATA 65,20
00DB6:  DATA 4E,75
00DB8:  DATA 6D,62
00DBA:  DATA 65,72
00DBC:  DATA 20,3D
00DBE:  DATA 20,25
00DC0:  DATA 69,0A
00DC2:  DATA 00,00
00DC4:  DATA 0A,4D
00DC6:  DATA 65,73
00DC8:  DATA 73,61
00DCA:  DATA 67,65
00DCC:  DATA 20,4E
00DCE:  DATA 75,6D
00DD0:  DATA 62,65
00DD2:  DATA 72,20
00DD4:  DATA 3D,20
00DD6:  DATA 25,69
00DD8:  DATA 0A,00
00DDA:  DATA 0A,4D
00DDC:  DATA 65,73
00DDE:  DATA 73,61
00DE0:  DATA 67,65
00DE2:  DATA 20,4E
00DE4:  DATA 75,6D
00DE6:  DATA 62,65
00DE8:  DATA 72,20
00DEA:  DATA 3D,20
00DEC:  DATA 25,69
00DEE:  DATA 0A,00
00DF0:  DATA 4C,54
00DF2:  DATA 25,69
00DF4:  DATA 3A,25
00DF6:  DATA 30,2E
00DF8:  DATA 33,66
00DFA:  DATA 2B,4C
00DFC:  DATA 4E,25
00DFE:  DATA 69,3A
00E00:  DATA 25,30
00E02:  DATA 2E,33
00E04:  DATA 66,2B
00E06:  DATA 00,00
00E08:  DATA 4C,54
00E0A:  DATA 25,69
00E0C:  DATA 3A,25
00E0E:  DATA 73,2B
00E10:  DATA 4C,4E
00E12:  DATA 25,69
00E14:  DATA 3A,25
00E16:  DATA 73,2B
00E18:  DATA 00,00
00E1A:  DATA 30,30
00E1C:  DATA 2E,30
00E1E:  DATA 30,30
00E20:  DATA 00,00
00E22:  DATA 30,30
00E24:  DATA 30,2E
00E26:  DATA 30,30
00E28:  DATA 30,00
00E2A:  DATA 44,61
00E2C:  DATA 74,65
00E2E:  DATA 2D,54
00E30:  DATA 69,6D
00E32:  DATA 65,3A
00E34:  DATA 20,25
00E36:  DATA 73,0A
00E38:  DATA 00,00
00E3A:  DATA 57,61
00E3C:  DATA 72,6E
00E3E:  DATA 69,6E
00E40:  DATA 67,20
00E42:  DATA 2D,20
00E44:  DATA 46,6C
00E46:  DATA 61,73
00E48:  DATA 68,20
00E4A:  DATA 43,6F
00E4C:  DATA 75,6E
00E4E:  DATA 74,3A
00E50:  DATA 20,25
00E52:  DATA 58,20
00E54:  DATA 20,00
00E56:  DATA 4F,54
00E58:  DATA 48,45
00E5A:  DATA 52,20
00E5C:  DATA 52,45
00E5E:  DATA 53,45
00E60:  DATA 54,20
00E62:  DATA 43,41
00E64:  DATA 55,53
00E66:  DATA 45,20
00E68:  DATA 28,25
00E6A:  DATA 69,29
00E6C:  DATA 00,00
00E6E:  DATA 25,73
00E70:  DATA 20,2D
00E72:  DATA 20,25
00E74:  DATA 73,00
00E76:  DATA 0A,2A
00E78:  DATA 2A,2A
00E7A:  DATA 2A,2A
00E7C:  DATA 2A,2A
00E7E:  DATA 2A,2A
00E80:  DATA 2A,2A
00E82:  DATA 2A,2A
00E84:  DATA 2A,2A
00E86:  DATA 2A,2A
00E88:  DATA 2A,2A
00E8A:  DATA 2A,2A
00E8C:  DATA 2A,2A
00E8E:  DATA 2A,2A
00E90:  DATA 2A,2A
00E92:  DATA 2A,2A
00E94:  DATA 2A,2A
00E96:  DATA 2A,2A
00E98:  DATA 2A,2A
00E9A:  DATA 2A,2A
00E9C:  DATA 2A,2A
00E9E:  DATA 2A,2A
00EA0:  DATA 2A,2A
00EA2:  DATA 2A,2A
00EA4:  DATA 2A,2A
00EA6:  DATA 2A,2A
00EA8:  DATA 0A,00
00EAA:  DATA 55,4C
00EAC:  DATA 41,54
00EAE:  DATA 20,4C
00EB0:  DATA 69,67
00EB2:  DATA 68,74
00EB4:  DATA 6E,69
00EB6:  DATA 6E,67
00EB8:  DATA 20,4D
00EBA:  DATA 6F,6E
00EBC:  DATA 69,74
00EBE:  DATA 6F,72
00EC0:  DATA 69,6E
00EC2:  DATA 67,20
00EC4:  DATA 53,74
00EC6:  DATA 61,74
00EC8:  DATA 69,6F
00ECA:  DATA 6E,20
00ECC:  DATA 28,42
00ECE:  DATA 65,74
00ED0:  DATA 61,20
00ED2:  DATA 76,65
00ED4:  DATA 72,73
00ED6:  DATA 69,6F
00ED8:  DATA 6E,29
00EDA:  DATA 0A,00
00EDC:  DATA 0A,49
00EDE:  DATA 6E,69
00EE0:  DATA 74,69
00EE2:  DATA 61,6C
00EE4:  DATA 69,7A
00EE6:  DATA 69,6E
00EE8:  DATA 67,20
00EEA:  DATA 42,54
00EEC:  DATA 44,32
00EEE:  DATA 30,30
00EF0:  DATA 0A,00
00EF2:  DATA 44,45
00EF4:  DATA 42,55
00EF6:  DATA 47,20
00EF8:  DATA 4D,4F
00EFA:  DATA 44,45
00EFC:  DATA 00,00
00EFE:  DATA 52,65
00F00:  DATA 73,65
00F02:  DATA 74,20
00F04:  DATA 4D,43
00F06:  DATA 55,0A
00F08:  DATA 00,00
00F0A:  DATA 54,69
00F0C:  DATA 6D,65
00F0E:  DATA 20,53
00F10:  DATA 79,6E
00F12:  DATA 63,0A
00F14:  DATA 00,00
*
00F40:  TBLRD*+
00F42:  MOVF   FF5,F
00F44:  BZ    0F6C
00F46:  MOVFF  FF6,691
00F4A:  MOVFF  FF7,692
00F4E:  MOVFF  FF8,693
00F52:  MOVF   FF5,W
00F54:  BTFSS  FA4.4
00F56:  BRA    0F54
00F58:  MOVLB  F
00F5A:  MOVWF  x1C
00F5C:  MOVFF  691,FF6
00F60:  MOVFF  692,FF7
00F64:  MOVFF  693,FF8
00F68:  MOVLB  0
00F6A:  BRA    0F40
00F6C:  RETURN 0
*
00FC6:  MOVFF  490,FEA
00FCA:  MOVFF  48F,FE9
00FCE:  MOVLB  6
00FD0:  MOVFF  6BD,FEF
00FD4:  INCF   FE9,F
00FD6:  BTFSC  FD8.2
00FD8:  INCF   FEA,F
00FDA:  CLRF   FEF
00FDC:  MOVLB  4
00FDE:  INCF   x8F,F
00FE0:  BTFSC  FD8.2
00FE2:  INCF   x90,F
00FE4:  MOVLB  0
00FE6:  RETURN 0
00FE8:  MOVF   01,W
00FEA:  CLRF   1B
00FEC:  BTFSC  FF2.7
00FEE:  BSF    1B.7
00FF0:  BCF    FF2.7
00FF2:  MOVFF  649,6F5
00FF6:  MOVLW  64
00FF8:  MOVLB  6
00FFA:  MOVWF  xF6
00FFC:  MOVLB  0
00FFE:  CALL   0642
01002:  BTFSC  1B.7
01004:  BSF    FF2.7
01006:  MOVFF  00,649
0100A:  MOVF   01,W
0100C:  MOVLW  30
0100E:  BNZ   1020
01010:  MOVLB  6
01012:  BTFSS  x4A.1
01014:  BRA    1034
01016:  BTFSC  x4A.3
01018:  BRA    1034
0101A:  BTFSC  x4A.4
0101C:  MOVLW  20
0101E:  BRA    1028
01020:  MOVLB  6
01022:  BCF    x4A.3
01024:  BCF    x4A.4
01026:  BSF    x4A.0
01028:  ADDWF  01,F
0102A:  MOVFF  01,6BD
0102E:  MOVLB  0
01030:  RCALL  0FC6
01032:  MOVLB  6
01034:  CLRF   1B
01036:  BTFSC  FF2.7
01038:  BSF    1B.7
0103A:  BCF    FF2.7
0103C:  MOVFF  649,6F5
01040:  MOVLW  0A
01042:  MOVWF  xF6
01044:  MOVLB  0
01046:  CALL   0642
0104A:  BTFSC  1B.7
0104C:  BSF    FF2.7
0104E:  MOVFF  00,649
01052:  MOVF   01,W
01054:  MOVLW  30
01056:  BNZ   1068
01058:  MOVLB  6
0105A:  BTFSC  x4A.3
0105C:  BRA    1072
0105E:  BTFSS  x4A.0
01060:  BRA    1072
01062:  BTFSC  x4A.4
01064:  MOVLW  20
01066:  MOVLB  0
01068:  ADDWF  01,F
0106A:  MOVFF  01,6BD
0106E:  RCALL  0FC6
01070:  MOVLB  6
01072:  MOVLW  30
01074:  ADDWF  x49,F
01076:  MOVFF  649,6BD
0107A:  MOVLB  0
0107C:  RCALL  0FC6
0107E:  RETURN 0
01080:  TBLRD*+
01082:  MOVFF  FF6,692
01086:  MOVFF  FF7,693
0108A:  MOVFF  FF8,694
0108E:  MOVF   FF5,W
01090:  BTFSS  FA4.4
01092:  BRA    1090
01094:  MOVLB  F
01096:  MOVWF  x1C
01098:  MOVFF  692,FF6
0109C:  MOVFF  693,FF7
010A0:  MOVFF  694,FF8
010A4:  MOVLB  6
010A6:  DECFSZ x91,F
010A8:  BRA    10AC
010AA:  BRA    10B0
010AC:  MOVLB  0
010AE:  BRA    1080
010B0:  MOVLB  0
010B2:  RETURN 0
010B4:  MOVF   FEF,F
010B6:  BZ    10DC
010B8:  MOVFF  FEA,66C
010BC:  MOVFF  FE9,66B
010C0:  MOVF   FEF,W
010C2:  BTFSS  FA4.4
010C4:  BRA    10C2
010C6:  MOVLB  F
010C8:  MOVWF  x1C
010CA:  MOVFF  66C,FEA
010CE:  MOVFF  66B,FE9
010D2:  INCF   FE9,F
010D4:  BTFSC  FD8.2
010D6:  INCF   FEA,F
010D8:  MOVLB  0
010DA:  BRA    10B4
010DC:  RETURN 0
*
0146A:  CLRF   00
0146C:  CLRF   01
0146E:  MOVLB  6
01470:  MOVF   x47,W
01472:  BCF    FD8.0
01474:  BTFSC  x48.0
01476:  ADDWF  00,F
01478:  RRCF   00,F
0147A:  RRCF   01,F
0147C:  BTFSC  x48.1
0147E:  ADDWF  00,F
01480:  RRCF   00,F
01482:  RRCF   01,F
01484:  BTFSC  x48.2
01486:  ADDWF  00,F
01488:  RRCF   00,F
0148A:  RRCF   01,F
0148C:  BTFSC  x48.3
0148E:  ADDWF  00,F
01490:  RRCF   00,F
01492:  RRCF   01,F
01494:  BTFSC  x48.4
01496:  ADDWF  00,F
01498:  RRCF   00,F
0149A:  RRCF   01,F
0149C:  BTFSC  x48.5
0149E:  ADDWF  00,F
014A0:  RRCF   00,F
014A2:  RRCF   01,F
014A4:  BTFSC  x48.6
014A6:  ADDWF  00,F
014A8:  RRCF   00,F
014AA:  RRCF   01,F
014AC:  BTFSC  x48.7
014AE:  ADDWF  00,F
014B0:  RRCF   00,F
014B2:  RRCF   01,F
014B4:  MOVLB  0
014B6:  GOTO   158A (RETURN)
*
01860:  MOVLW  20
01862:  MOVLB  6
01864:  BTFSS  xB1.4
01866:  MOVLW  30
01868:  MOVWF  xB2
0186A:  MOVFF  6B0,00
0186E:  BTFSS  00.7
01870:  BRA    1882
01872:  COMF   00,F
01874:  INCF   00,F
01876:  MOVFF  00,6B0
0187A:  MOVLW  2D
0187C:  MOVWF  xB2
0187E:  BSF    xB1.7
01880:  BSF    xB1.0
01882:  MOVF   01,W
01884:  CLRF   1B
01886:  BTFSC  FF2.7
01888:  BSF    1B.7
0188A:  BCF    FF2.7
0188C:  MOVFF  6B0,6F5
01890:  MOVLW  64
01892:  MOVWF  xF6
01894:  MOVLB  0
01896:  CALL   0642
0189A:  BTFSC  1B.7
0189C:  BSF    FF2.7
0189E:  MOVFF  00,6B0
018A2:  MOVLW  30
018A4:  ADDWF  01,W
018A6:  MOVLB  6
018A8:  MOVWF  xB3
018AA:  CLRF   1B
018AC:  BTFSC  FF2.7
018AE:  BSF    1B.7
018B0:  BCF    FF2.7
018B2:  MOVFF  6B0,6F5
018B6:  MOVLW  0A
018B8:  MOVWF  xF6
018BA:  MOVLB  0
018BC:  CALL   0642
018C0:  BTFSC  1B.7
018C2:  BSF    FF2.7
018C4:  MOVLW  30
018C6:  ADDWF  00,W
018C8:  MOVLB  6
018CA:  MOVWF  xB5
018CC:  MOVLW  30
018CE:  ADDWF  01,W
018D0:  MOVWF  xB4
018D2:  MOVFF  6B2,00
018D6:  MOVLW  30
018D8:  SUBWF  xB3,W
018DA:  BZ    18E4
018DC:  BSF    xB1.1
018DE:  BTFSC  xB1.7
018E0:  BSF    xB1.2
018E2:  BRA    1908
018E4:  MOVFF  6B2,6B3
018E8:  MOVLW  20
018EA:  MOVWF  xB2
018EC:  MOVLW  30
018EE:  SUBWF  xB4,W
018F0:  BZ    18FA
018F2:  BSF    xB1.0
018F4:  BTFSC  xB1.7
018F6:  BSF    xB1.1
018F8:  BRA    1908
018FA:  BTFSS  FD8.2
018FC:  BSF    xB1.0
018FE:  BNZ   1908
01900:  MOVFF  6B3,6B4
01904:  MOVLW  20
01906:  MOVWF  xB3
01908:  BTFSC  xB1.2
0190A:  BRA    1916
0190C:  BTFSC  xB1.1
0190E:  BRA    1920
01910:  BTFSC  xB1.0
01912:  BRA    192A
01914:  BRA    1934
01916:  MOVFF  6B2,6BD
0191A:  MOVLB  0
0191C:  CALL   0FC6
01920:  MOVFF  6B3,6BD
01924:  MOVLB  0
01926:  CALL   0FC6
0192A:  MOVFF  6B4,6BD
0192E:  MOVLB  0
01930:  CALL   0FC6
01934:  MOVFF  6B5,6BD
01938:  MOVLB  0
0193A:  CALL   0FC6
0193E:  RETURN 0
*
01C10:  TBLRD*+
01C12:  MOVFF  FF6,6B1
01C16:  MOVFF  FF7,6B2
01C1A:  MOVFF  FF8,6B3
01C1E:  MOVFF  FF5,6BD
01C22:  CALL   0FC6
01C26:  MOVFF  6B1,FF6
01C2A:  MOVFF  6B2,FF7
01C2E:  MOVFF  6B3,FF8
01C32:  MOVLB  6
01C34:  DECFSZ xB0,F
01C36:  BRA    1C3A
01C38:  BRA    1C3E
01C3A:  MOVLB  0
01C3C:  BRA    1C10
01C3E:  MOVLB  0
01C40:  RETURN 0
01C42:  MOVF   FEF,F
01C44:  BZ    1C66
01C46:  MOVFF  FEA,66A
01C4A:  MOVFF  FE9,669
01C4E:  MOVFF  FEF,6BD
01C52:  CALL   0FC6
01C56:  MOVFF  66A,FEA
01C5A:  MOVFF  669,FE9
01C5E:  INCF   FE9,F
01C60:  BTFSC  FD8.2
01C62:  INCF   FEA,F
01C64:  BRA    1C42
01C66:  RETURN 0
*
01E18:  MOVLB  6
01E1A:  BTFSC  x64.7
01E1C:  BRA    1E42
01E1E:  MOVLW  0F
01E20:  MOVWF  00
01E22:  SWAPF  x63,W
01E24:  ANDWF  00,F
01E26:  MOVLW  0A
01E28:  SUBWF  00,W
01E2A:  BC    1E32
01E2C:  MOVLW  30
01E2E:  ADDWF  00,F
01E30:  BRA    1E36
01E32:  MOVF   x64,W
01E34:  ADDWF  00,F
01E36:  MOVF   00,W
01E38:  BTFSS  FA4.4
01E3A:  BRA    1E38
01E3C:  MOVLB  F
01E3E:  MOVWF  x1C
01E40:  MOVLB  6
01E42:  MOVLW  0F
01E44:  ANDWF  x63,F
01E46:  MOVLW  0A
01E48:  SUBWF  x63,W
01E4A:  BC    1E50
01E4C:  MOVLW  30
01E4E:  BRA    1E54
01E50:  BCF    x64.7
01E52:  MOVF   x64,W
01E54:  ADDWF  x63,F
01E56:  MOVF   x63,W
01E58:  BTFSS  FA4.4
01E5A:  BRA    1E58
01E5C:  MOVLB  F
01E5E:  MOVWF  x1C
01E60:  MOVLB  0
01E62:  RETURN 0
*
01EA0:  MOVF   FEF,F
01EA2:  BZ    1EC4
01EA4:  MOVFF  FEA,66C
01EA8:  MOVFF  FE9,66B
01EAC:  MOVF   FEF,W
01EAE:  BTFSS  F9E.4
01EB0:  BRA    1EAE
01EB2:  MOVWF  FAD
01EB4:  MOVFF  66C,FEA
01EB8:  MOVFF  66B,FE9
01EBC:  INCF   FE9,F
01EBE:  BTFSC  FD8.2
01EC0:  INCF   FEA,F
01EC2:  BRA    1EA0
01EC4:  GOTO   20D8 (RETURN)
*
023FA:  MOVLW  20
023FC:  MOVLB  6
023FE:  BTFSS  x92.4
02400:  MOVLW  30
02402:  MOVWF  x93
02404:  MOVFF  691,00
02408:  BTFSS  00.7
0240A:  BRA    241C
0240C:  COMF   00,F
0240E:  INCF   00,F
02410:  MOVFF  00,691
02414:  MOVLW  2D
02416:  MOVWF  x93
02418:  BSF    x92.7
0241A:  BSF    x92.0
0241C:  MOVF   01,W
0241E:  CLRF   1B
02420:  BTFSC  FF2.7
02422:  BSF    1B.7
02424:  BCF    FF2.7
02426:  MOVFF  691,6F5
0242A:  MOVLW  64
0242C:  MOVWF  xF6
0242E:  MOVLB  0
02430:  CALL   0642
02434:  BTFSC  1B.7
02436:  BSF    FF2.7
02438:  MOVFF  00,691
0243C:  MOVLW  30
0243E:  ADDWF  01,W
02440:  MOVLB  6
02442:  MOVWF  x94
02444:  CLRF   1B
02446:  BTFSC  FF2.7
02448:  BSF    1B.7
0244A:  BCF    FF2.7
0244C:  MOVFF  691,6F5
02450:  MOVLW  0A
02452:  MOVWF  xF6
02454:  MOVLB  0
02456:  CALL   0642
0245A:  BTFSC  1B.7
0245C:  BSF    FF2.7
0245E:  MOVLW  30
02460:  ADDWF  00,W
02462:  MOVLB  6
02464:  MOVWF  x96
02466:  MOVLW  30
02468:  ADDWF  01,W
0246A:  MOVWF  x95
0246C:  MOVFF  693,00
02470:  MOVLW  30
02472:  SUBWF  x94,W
02474:  BZ    247E
02476:  BSF    x92.1
02478:  BTFSC  x92.7
0247A:  BSF    x92.2
0247C:  BRA    24A2
0247E:  MOVFF  693,694
02482:  MOVLW  20
02484:  MOVWF  x93
02486:  MOVLW  30
02488:  SUBWF  x95,W
0248A:  BZ    2494
0248C:  BSF    x92.0
0248E:  BTFSC  x92.7
02490:  BSF    x92.1
02492:  BRA    24A2
02494:  BTFSS  FD8.2
02496:  BSF    x92.0
02498:  BNZ   24A2
0249A:  MOVFF  694,695
0249E:  MOVLW  20
024A0:  MOVWF  x94
024A2:  BTFSC  x92.2
024A4:  BRA    24B0
024A6:  BTFSC  x92.1
024A8:  BRA    24BC
024AA:  BTFSC  x92.0
024AC:  BRA    24C8
024AE:  BRA    24D4
024B0:  MOVF   x93,W
024B2:  BTFSS  FA4.4
024B4:  BRA    24B2
024B6:  MOVLB  F
024B8:  MOVWF  x1C
024BA:  MOVLB  6
024BC:  MOVF   x94,W
024BE:  BTFSS  FA4.4
024C0:  BRA    24BE
024C2:  MOVLB  F
024C4:  MOVWF  x1C
024C6:  MOVLB  6
024C8:  MOVF   x95,W
024CA:  BTFSS  FA4.4
024CC:  BRA    24CA
024CE:  MOVLB  F
024D0:  MOVWF  x1C
024D2:  MOVLB  6
024D4:  MOVF   x96,W
024D6:  BTFSS  FA4.4
024D8:  BRA    24D6
024DA:  MOVLB  F
024DC:  MOVWF  x1C
024DE:  MOVLB  0
024E0:  RETURN 0
024E2:  MOVLB  6
024E4:  CLRF   xB6
024E6:  CLRF   xB7
024E8:  MOVLW  01
024EA:  MOVWF  xB8
024EC:  CLRF   FDA
024EE:  CLRF   FD9
024F0:  MOVLW  06
024F2:  MOVWF  xBB
024F4:  MOVLW  AE
024F6:  MOVWF  xBA
024F8:  MOVLW  06
024FA:  MOVWF  FEA
024FC:  MOVLW  B2
024FE:  MOVWF  FE9
02500:  MOVFF  6BB,FE2
02504:  MOVFF  6BA,FE1
02508:  MOVFF  6B8,6B9
0250C:  BCF    FD8.0
0250E:  MOVF   FE5,W
02510:  MULWF  FEE
02512:  MOVF   FF3,W
02514:  ADDWFC xB6,F
02516:  MOVF   FF4,W
02518:  ADDWFC xB7,F
0251A:  DECFSZ xB9,F
0251C:  BRA    250C
0251E:  MOVFF  6B6,FDE
02522:  MOVFF  6B7,6B6
02526:  CLRF   xB7
02528:  BTFSC  FD8.0
0252A:  INCF   xB7,F
0252C:  INCF   xBA,F
0252E:  BTFSC  FD8.2
02530:  INCF   xBB,F
02532:  INCF   xB8,F
02534:  MOVF   xB8,W
02536:  SUBLW  05
02538:  BNZ   24F8
0253A:  MOVLB  0
0253C:  GOTO   265E (RETURN)
02540:  BTFSC  FD8.1
02542:  BRA    254C
02544:  MOVLW  06
02546:  MOVWF  FEA
02548:  MOVLW  BE
0254A:  MOVWF  FE9
0254C:  MOVLB  6
0254E:  MOVF   xB9,W
02550:  XORWF  xBD,W
02552:  ANDLW  80
02554:  MOVWF  xC3
02556:  BTFSS  xB9.7
02558:  BRA    2570
0255A:  COMF   xB6,F
0255C:  COMF   xB7,F
0255E:  COMF   xB8,F
02560:  COMF   xB9,F
02562:  INCF   xB6,F
02564:  BTFSC  FD8.2
02566:  INCF   xB7,F
02568:  BTFSC  FD8.2
0256A:  INCF   xB8,F
0256C:  BTFSC  FD8.2
0256E:  INCF   xB9,F
02570:  BTFSS  xBD.7
02572:  BRA    258A
02574:  COMF   xBA,F
02576:  COMF   xBB,F
02578:  COMF   xBC,F
0257A:  COMF   xBD,F
0257C:  INCF   xBA,F
0257E:  BTFSC  FD8.2
02580:  INCF   xBB,F
02582:  BTFSC  FD8.2
02584:  INCF   xBC,F
02586:  BTFSC  FD8.2
02588:  INCF   xBD,F
0258A:  CLRF   00
0258C:  CLRF   01
0258E:  CLRF   02
02590:  CLRF   03
02592:  CLRF   xBE
02594:  CLRF   xBF
02596:  CLRF   xC0
02598:  CLRF   xC1
0259A:  MOVF   xBD,W
0259C:  IORWF  xBC,W
0259E:  IORWF  xBB,W
025A0:  IORWF  xBA,W
025A2:  BZ    25FC
025A4:  MOVLW  20
025A6:  MOVWF  xC2
025A8:  BCF    FD8.0
025AA:  RLCF   xB6,F
025AC:  RLCF   xB7,F
025AE:  RLCF   xB8,F
025B0:  RLCF   xB9,F
025B2:  RLCF   xBE,F
025B4:  RLCF   xBF,F
025B6:  RLCF   xC0,F
025B8:  RLCF   xC1,F
025BA:  MOVF   xBD,W
025BC:  SUBWF  xC1,W
025BE:  BNZ   25D0
025C0:  MOVF   xBC,W
025C2:  SUBWF  xC0,W
025C4:  BNZ   25D0
025C6:  MOVF   xBB,W
025C8:  SUBWF  xBF,W
025CA:  BNZ   25D0
025CC:  MOVF   xBA,W
025CE:  SUBWF  xBE,W
025D0:  BNC   25F0
025D2:  MOVF   xBA,W
025D4:  SUBWF  xBE,F
025D6:  MOVF   xBB,W
025D8:  BTFSS  FD8.0
025DA:  INCFSZ xBB,W
025DC:  SUBWF  xBF,F
025DE:  MOVF   xBC,W
025E0:  BTFSS  FD8.0
025E2:  INCFSZ xBC,W
025E4:  SUBWF  xC0,F
025E6:  MOVF   xBD,W
025E8:  BTFSS  FD8.0
025EA:  INCFSZ xBD,W
025EC:  SUBWF  xC1,F
025EE:  BSF    FD8.0
025F0:  RLCF   00,F
025F2:  RLCF   01,F
025F4:  RLCF   02,F
025F6:  RLCF   03,F
025F8:  DECFSZ xC2,F
025FA:  BRA    25A8
025FC:  BTFSS  xC3.7
025FE:  BRA    2616
02600:  COMF   00,F
02602:  COMF   01,F
02604:  COMF   02,F
02606:  COMF   03,F
02608:  INCF   00,F
0260A:  BTFSC  FD8.2
0260C:  INCF   01,F
0260E:  BTFSC  FD8.2
02610:  INCF   02,F
02612:  BTFSC  FD8.2
02614:  INCF   03,F
02616:  MOVFF  6BE,FEF
0261A:  MOVFF  6BF,FEC
0261E:  MOVFF  6C0,FEC
02622:  MOVFF  6C1,FEC
02626:  MOVLB  0
02628:  RETURN 0
*
0326E:  MOVLW  8E
03270:  MOVWF  00
03272:  MOVFF  6E3,01
03276:  MOVFF  6E2,02
0327A:  CLRF   03
0327C:  MOVF   01,F
0327E:  BNZ   3292
03280:  MOVFF  02,01
03284:  CLRF   02
03286:  MOVLW  08
03288:  SUBWF  00,F
0328A:  MOVF   01,F
0328C:  BNZ   3292
0328E:  CLRF   00
03290:  BRA    32A2
03292:  BCF    FD8.0
03294:  BTFSC  01.7
03296:  BRA    32A0
03298:  RLCF   02,F
0329A:  RLCF   01,F
0329C:  DECF   00,F
0329E:  BRA    3292
032A0:  BCF    01.7
032A2:  RETURN 0
032A4:  MOVLB  6
032A6:  MOVF   xE2,W
032A8:  BTFSC  FD8.2
032AA:  BRA    338E
032AC:  MOVWF  00
032AE:  MOVF   xE6,W
032B0:  BTFSC  FD8.2
032B2:  BRA    338E
032B4:  ADDWF  00,F
032B6:  BNC   32C0
032B8:  MOVLW  81
032BA:  ADDWF  00,F
032BC:  BC    338E
032BE:  BRA    32C8
032C0:  MOVLW  7F
032C2:  SUBWF  00,F
032C4:  BNC   338E
032C6:  BZ    338E
032C8:  MOVFF  6E3,6EA
032CC:  MOVF   xE7,W
032CE:  XORWF  xEA,F
032D0:  BSF    xE3.7
032D2:  BSF    xE7.7
032D4:  MOVF   xE5,W
032D6:  MULWF  xE9
032D8:  MOVFF  FF4,6EC
032DC:  MOVF   xE4,W
032DE:  MULWF  xE8
032E0:  MOVFF  FF4,03
032E4:  MOVFF  FF3,6EB
032E8:  MULWF  xE9
032EA:  MOVF   FF3,W
032EC:  ADDWF  xEC,F
032EE:  MOVF   FF4,W
032F0:  ADDWFC xEB,F
032F2:  MOVLW  00
032F4:  ADDWFC 03,F
032F6:  MOVF   xE5,W
032F8:  MULWF  xE8
032FA:  MOVF   FF3,W
032FC:  ADDWF  xEC,F
032FE:  MOVF   FF4,W
03300:  ADDWFC xEB,F
03302:  MOVLW  00
03304:  CLRF   02
03306:  ADDWFC 03,F
03308:  ADDWFC 02,F
0330A:  MOVF   xE3,W
0330C:  MULWF  xE9
0330E:  MOVF   FF3,W
03310:  ADDWF  xEB,F
03312:  MOVF   FF4,W
03314:  ADDWFC 03,F
03316:  MOVLW  00
03318:  ADDWFC 02,F
0331A:  MOVF   xE3,W
0331C:  MULWF  xE8
0331E:  MOVF   FF3,W
03320:  ADDWF  03,F
03322:  MOVF   FF4,W
03324:  ADDWFC 02,F
03326:  MOVLW  00
03328:  CLRF   01
0332A:  ADDWFC 01,F
0332C:  MOVF   xE5,W
0332E:  MULWF  xE7
03330:  MOVF   FF3,W
03332:  ADDWF  xEB,F
03334:  MOVF   FF4,W
03336:  ADDWFC 03,F
03338:  MOVLW  00
0333A:  ADDWFC 02,F
0333C:  ADDWFC 01,F
0333E:  MOVF   xE4,W
03340:  MULWF  xE7
03342:  MOVF   FF3,W
03344:  ADDWF  03,F
03346:  MOVF   FF4,W
03348:  ADDWFC 02,F
0334A:  MOVLW  00
0334C:  ADDWFC 01,F
0334E:  MOVF   xE3,W
03350:  MULWF  xE7
03352:  MOVF   FF3,W
03354:  ADDWF  02,F
03356:  MOVF   FF4,W
03358:  ADDWFC 01,F
0335A:  INCF   00,F
0335C:  BTFSC  01.7
0335E:  BRA    336A
03360:  RLCF   xEB,F
03362:  RLCF   03,F
03364:  RLCF   02,F
03366:  RLCF   01,F
03368:  DECF   00,F
0336A:  MOVLW  00
0336C:  BTFSS  xEB.7
0336E:  BRA    3384
03370:  INCF   03,F
03372:  ADDWFC 02,F
03374:  ADDWFC 01,F
03376:  MOVF   01,W
03378:  BNZ   3384
0337A:  MOVF   02,W
0337C:  BNZ   3384
0337E:  MOVF   03,W
03380:  BNZ   3384
03382:  INCF   00,F
03384:  BTFSC  xEA.7
03386:  BSF    01.7
03388:  BTFSS  xEA.7
0338A:  BCF    01.7
0338C:  BRA    3396
0338E:  CLRF   00
03390:  CLRF   01
03392:  CLRF   02
03394:  CLRF   03
03396:  MOVLB  0
03398:  RETURN 0
0339A:  MOVLB  6
0339C:  MOVF   xBD,W
0339E:  SUBLW  B6
033A0:  MOVWF  xBD
033A2:  CLRF   03
033A4:  MOVFF  6BE,6C1
033A8:  BSF    xBE.7
033AA:  BCF    FD8.0
033AC:  RRCF   xBE,F
033AE:  RRCF   xBF,F
033B0:  RRCF   xC0,F
033B2:  RRCF   03,F
033B4:  RRCF   02,F
033B6:  RRCF   01,F
033B8:  RRCF   00,F
033BA:  DECFSZ xBD,F
033BC:  BRA    33AA
033BE:  BTFSS  xC1.7
033C0:  BRA    33D8
033C2:  COMF   00,F
033C4:  COMF   01,F
033C6:  COMF   02,F
033C8:  COMF   03,F
033CA:  INCF   00,F
033CC:  BTFSC  FD8.2
033CE:  INCF   01,F
033D0:  BTFSC  FD8.2
033D2:  INCF   02,F
033D4:  BTFSC  FD8.2
033D6:  INCF   03,F
033D8:  MOVLB  0
033DA:  GOTO   34C8 (RETURN)
033DE:  BTFSC  FD8.1
033E0:  BRA    33EA
033E2:  MOVLW  06
033E4:  MOVWF  FEA
033E6:  MOVLW  C5
033E8:  MOVWF  FE9
033EA:  CLRF   00
033EC:  CLRF   01
033EE:  CLRF   02
033F0:  CLRF   03
033F2:  MOVLB  6
033F4:  CLRF   xC5
033F6:  CLRF   xC6
033F8:  CLRF   xC7
033FA:  CLRF   xC8
033FC:  MOVF   xC4,W
033FE:  IORWF  xC3,W
03400:  IORWF  xC2,W
03402:  IORWF  xC1,W
03404:  BZ    345E
03406:  MOVLW  20
03408:  MOVWF  xC9
0340A:  BCF    FD8.0
0340C:  RLCF   xBD,F
0340E:  RLCF   xBE,F
03410:  RLCF   xBF,F
03412:  RLCF   xC0,F
03414:  RLCF   xC5,F
03416:  RLCF   xC6,F
03418:  RLCF   xC7,F
0341A:  RLCF   xC8,F
0341C:  MOVF   xC4,W
0341E:  SUBWF  xC8,W
03420:  BNZ   3432
03422:  MOVF   xC3,W
03424:  SUBWF  xC7,W
03426:  BNZ   3432
03428:  MOVF   xC2,W
0342A:  SUBWF  xC6,W
0342C:  BNZ   3432
0342E:  MOVF   xC1,W
03430:  SUBWF  xC5,W
03432:  BNC   3452
03434:  MOVF   xC1,W
03436:  SUBWF  xC5,F
03438:  MOVF   xC2,W
0343A:  BTFSS  FD8.0
0343C:  INCFSZ xC2,W
0343E:  SUBWF  xC6,F
03440:  MOVF   xC3,W
03442:  BTFSS  FD8.0
03444:  INCFSZ xC3,W
03446:  SUBWF  xC7,F
03448:  MOVF   xC4,W
0344A:  BTFSS  FD8.0
0344C:  INCFSZ xC4,W
0344E:  SUBWF  xC8,F
03450:  BSF    FD8.0
03452:  RLCF   00,F
03454:  RLCF   01,F
03456:  RLCF   02,F
03458:  RLCF   03,F
0345A:  DECFSZ xC9,F
0345C:  BRA    340A
0345E:  MOVFF  6C5,FEF
03462:  MOVFF  6C6,FEC
03466:  MOVFF  6C7,FEC
0346A:  MOVFF  6C8,FEC
0346E:  MOVLB  0
03470:  RETURN 0
03472:  MOVF   FE9,W
03474:  MOVLB  6
03476:  MOVWF  xB5
03478:  MOVF   xB4,W
0347A:  MOVWF  xB7
0347C:  BZ    34B4
0347E:  MOVFF  6B3,6E5
03482:  MOVFF  6B2,6E4
03486:  MOVFF  6B1,6E3
0348A:  MOVFF  6B0,6E2
0348E:  CLRF   xE9
03490:  CLRF   xE8
03492:  MOVLW  20
03494:  MOVWF  xE7
03496:  MOVLW  82
03498:  MOVWF  xE6
0349A:  MOVLB  0
0349C:  RCALL  32A4
0349E:  MOVFF  03,6B3
034A2:  MOVFF  02,6B2
034A6:  MOVFF  01,6B1
034AA:  MOVFF  00,6B0
034AE:  MOVLB  6
034B0:  DECFSZ xB7,F
034B2:  BRA    347E
034B4:  MOVFF  6B3,6C0
034B8:  MOVFF  6B2,6BF
034BC:  MOVFF  6B1,6BE
034C0:  MOVFF  6B0,6BD
034C4:  MOVLB  0
034C6:  BRA    339A
034C8:  MOVFF  03,6B3
034CC:  MOVFF  02,6B2
034D0:  MOVFF  01,6B1
034D4:  MOVFF  00,6B0
034D8:  MOVLB  6
034DA:  BTFSS  xB3.7
034DC:  BRA    34F8
034DE:  DECF   xB5,F
034E0:  BSF    xB5.5
034E2:  COMF   xB0,F
034E4:  COMF   xB1,F
034E6:  COMF   xB2,F
034E8:  COMF   xB3,F
034EA:  INCF   xB0,F
034EC:  BTFSC  FD8.2
034EE:  INCF   xB1,F
034F0:  BTFSC  FD8.2
034F2:  INCF   xB2,F
034F4:  BTFSC  FD8.2
034F6:  INCF   xB3,F
034F8:  MOVLW  3B
034FA:  MOVWF  xBC
034FC:  MOVLW  9A
034FE:  MOVWF  xBB
03500:  MOVLW  CA
03502:  MOVWF  xBA
03504:  CLRF   xB9
03506:  MOVLW  0A
03508:  MOVWF  xB7
0350A:  MOVF   xB4,W
0350C:  BTFSC  FD8.2
0350E:  INCF   xB5,F
03510:  BSF    FD8.1
03512:  MOVLW  06
03514:  MOVWF  FEA
03516:  MOVLW  B0
03518:  MOVWF  FE9
0351A:  MOVFF  6B3,6C0
0351E:  MOVFF  6B2,6BF
03522:  MOVFF  6B1,6BE
03526:  MOVFF  6B0,6BD
0352A:  MOVFF  6BC,6C4
0352E:  MOVFF  6BB,6C3
03532:  MOVFF  6BA,6C2
03536:  MOVFF  6B9,6C1
0353A:  MOVLB  0
0353C:  RCALL  33DE
0353E:  MOVF   01,W
03540:  MOVF   00,F
03542:  BNZ   356A
03544:  MOVLB  6
03546:  INCF   xB4,W
03548:  SUBWF  xB7,W
0354A:  BTFSS  FD8.2
0354C:  BRA    3552
0354E:  MOVLB  0
03550:  BRA    356A
03552:  MOVF   xB5,W
03554:  BZ    3570
03556:  ANDLW  0F
03558:  SUBWF  xB7,W
0355A:  BZ    355E
0355C:  BC    35E6
0355E:  BTFSC  xB5.7
03560:  BRA    35E6
03562:  BTFSC  xB5.6
03564:  BRA    3570
03566:  MOVLW  20
03568:  BRA    35D8
0356A:  MOVLW  20
0356C:  MOVLB  6
0356E:  ANDWF  xB5,F
03570:  BTFSS  xB5.5
03572:  BRA    3592
03574:  BCF    xB5.5
03576:  MOVF   xB4,W
03578:  BTFSS  FD8.2
0357A:  DECF   xB5,F
0357C:  MOVF   00,W
0357E:  MOVWF  xB5
03580:  MOVLW  2D
03582:  MOVWF  xBD
03584:  MOVLB  0
03586:  CALL   0FC6
0358A:  MOVLB  6
0358C:  MOVF   xB5,W
0358E:  MOVWF  00
03590:  CLRF   xB5
03592:  MOVF   xB4,W
03594:  SUBWF  xB7,W
03596:  BNZ   35B2
03598:  MOVF   00,W
0359A:  MOVWF  xB5
0359C:  MOVLW  2E
0359E:  MOVWF  xBD
035A0:  MOVLB  0
035A2:  CALL   0FC6
035A6:  MOVLB  6
035A8:  MOVF   xB5,W
035AA:  MOVWF  00
035AC:  MOVLW  20
035AE:  ANDWF  xB5,F
035B0:  MOVLW  00
035B2:  MOVLW  30
035B4:  BTFSS  xB5.5
035B6:  BRA    35D8
035B8:  BCF    xB5.5
035BA:  MOVF   xB4,W
035BC:  BTFSS  FD8.2
035BE:  DECF   xB5,F
035C0:  MOVF   00,W
035C2:  MOVWF  xB5
035C4:  MOVLW  2D
035C6:  MOVWF  xBD
035C8:  MOVLB  0
035CA:  CALL   0FC6
035CE:  MOVLB  6
035D0:  MOVF   xB5,W
035D2:  MOVWF  00
035D4:  CLRF   xB5
035D6:  MOVLW  30
035D8:  ADDWF  00,F
035DA:  MOVFF  00,6BD
035DE:  MOVLB  0
035E0:  CALL   0FC6
035E4:  MOVLB  6
035E6:  BCF    FD8.1
035E8:  MOVFF  6BC,6C0
035EC:  MOVFF  6BB,6BF
035F0:  MOVFF  6BA,6BE
035F4:  MOVFF  6B9,6BD
035F8:  CLRF   xC4
035FA:  CLRF   xC3
035FC:  CLRF   xC2
035FE:  MOVLW  0A
03600:  MOVWF  xC1
03602:  MOVLB  0
03604:  RCALL  33DE
03606:  MOVFF  03,6BC
0360A:  MOVFF  02,6BB
0360E:  MOVFF  01,6BA
03612:  MOVFF  00,6B9
03616:  MOVLB  6
03618:  DECFSZ xB7,F
0361A:  BRA    3510
0361C:  MOVLB  0
0361E:  RETURN 0
03620:  MOVFF  FEA,66A
03624:  MOVFF  FE9,669
03628:  MOVLB  6
0362A:  BTFSS  x63.7
0362C:  BRA    363E
0362E:  BSF    x69.7
03630:  BTFSS  x69.4
03632:  INCF   x69,F
03634:  COMF   x62,F
03636:  COMF   x63,F
03638:  INCF   x62,F
0363A:  BTFSC  FD8.2
0363C:  INCF   x63,F
0363E:  SWAPF  x63,W
03640:  IORLW  F0
03642:  MOVWF  x65
03644:  ADDWF  x65,F
03646:  ADDLW  E2
03648:  MOVWF  x66
0364A:  ADDLW  32
0364C:  MOVWF  x68
0364E:  MOVF   x63,W
03650:  ANDLW  0F
03652:  ADDWF  x66,F
03654:  ADDWF  x66,F
03656:  ADDWF  x68,F
03658:  ADDLW  E9
0365A:  MOVWF  x67
0365C:  ADDWF  x67,F
0365E:  ADDWF  x67,F
03660:  SWAPF  x62,W
03662:  ANDLW  0F
03664:  ADDWF  x67,F
03666:  ADDWF  x68,F
03668:  RLCF   x67,F
0366A:  RLCF   x68,F
0366C:  COMF   x68,F
0366E:  RLCF   x68,F
03670:  MOVF   x62,W
03672:  ANDLW  0F
03674:  ADDWF  x68,F
03676:  RLCF   x65,F
03678:  MOVLW  07
0367A:  MOVWF  x64
0367C:  MOVLW  0A
0367E:  DECF   x67,F
03680:  ADDWF  x68,F
03682:  BNC   367E
03684:  DECF   x66,F
03686:  ADDWF  x67,F
03688:  BNC   3684
0368A:  DECF   x65,F
0368C:  ADDWF  x66,F
0368E:  BNC   368A
03690:  DECF   x64,F
03692:  ADDWF  x65,F
03694:  BNC   3690
03696:  MOVLW  06
03698:  MOVWF  FEA
0369A:  MOVLW  64
0369C:  MOVWF  FE9
0369E:  MOVLW  07
036A0:  ANDWF  x69,W
036A2:  BCF    x69.6
036A4:  MOVF   FED,F
036A6:  ANDWF  x69,W
036A8:  BNZ   36B8
036AA:  BTFSC  x69.4
036AC:  MOVF   FEE,F
036AE:  BTFSC  x69.4
036B0:  BRA    36B8
036B2:  MOVLW  20
036B4:  MOVWF  00
036B6:  BRA    36FA
036B8:  ADDWF  FE9,F
036BA:  MOVLW  00
036BC:  ADDWFC FEA,F
036BE:  MOVF   FE9,W
036C0:  SUBLW  68
036C2:  BNZ   36CC
036C4:  MOVF   FEA,W
036C6:  SUBLW  06
036C8:  BNZ   36CC
036CA:  BSF    x69.6
036CC:  MOVF   FEF,W
036CE:  MOVWF  00
036D0:  BNZ   36E2
036D2:  BTFSC  x69.6
036D4:  BRA    36E2
036D6:  BTFSC  x69.4
036D8:  BRA    3716
036DA:  BTFSC  x69.3
036DC:  BRA    36E2
036DE:  MOVLW  20
036E0:  BRA    36F8
036E2:  BTFSS  x69.7
036E4:  BRA    36F2
036E6:  MOVLW  2D
036E8:  MOVWF  00
036EA:  MOVF   FED,W
036EC:  BCF    x69.6
036EE:  BCF    x69.7
036F0:  BRA    36FA
036F2:  BSF    x69.3
036F4:  BCF    x69.4
036F6:  MOVLW  30
036F8:  ADDWF  00,F
036FA:  MOVFF  FEA,663
036FE:  MOVFF  FE9,662
03702:  MOVFF  00,6BD
03706:  MOVLB  0
03708:  CALL   0FC6
0370C:  MOVFF  663,FEA
03710:  MOVFF  662,FE9
03714:  MOVLB  6
03716:  MOVF   FEE,W
03718:  BTFSS  x69.6
0371A:  BRA    36BE
0371C:  MOVLB  0
0371E:  GOTO   4F78 (RETURN)
*
0376C:  MOVLB  6
0376E:  MOVF   xDD,W
03770:  XORWF  xDF,W
03772:  ANDLW  80
03774:  MOVWF  xE1
03776:  BTFSS  xDD.7
03778:  BRA    3784
0377A:  COMF   xDC,F
0377C:  COMF   xDD,F
0377E:  INCF   xDC,F
03780:  BTFSC  FD8.2
03782:  INCF   xDD,F
03784:  BTFSS  xDF.7
03786:  BRA    3792
03788:  COMF   xDE,F
0378A:  COMF   xDF,F
0378C:  INCF   xDE,F
0378E:  BTFSC  FD8.2
03790:  INCF   xDF,F
03792:  MOVF   xDC,W
03794:  MULWF  xDE
03796:  MOVFF  FF3,01
0379A:  MOVFF  FF4,00
0379E:  MULWF  xDF
037A0:  MOVF   FF3,W
037A2:  ADDWF  00,F
037A4:  MOVF   xDD,W
037A6:  MULWF  xDE
037A8:  MOVF   FF3,W
037AA:  ADDWFC 00,W
037AC:  MOVWF  02
037AE:  BTFSS  xE1.7
037B0:  BRA    37BC
037B2:  COMF   01,F
037B4:  COMF   02,F
037B6:  INCF   01,F
037B8:  BTFSC  FD8.2
037BA:  INCF   02,F
037BC:  MOVLB  0
037BE:  GOTO   3A4C (RETURN)
*
03B18:  MOVLW  80
03B1A:  BTFSS  FD8.1
03B1C:  BRA    3B22
03B1E:  MOVLB  6
03B20:  XORWF  xE7,F
03B22:  MOVLB  6
03B24:  CLRF   xEC
03B26:  CLRF   xED
03B28:  MOVFF  6E3,6EB
03B2C:  MOVF   xE7,W
03B2E:  XORWF  xEB,F
03B30:  MOVF   xE2,W
03B32:  BTFSC  FD8.2
03B34:  BRA    3CF4
03B36:  MOVWF  xEA
03B38:  MOVWF  00
03B3A:  MOVF   xE6,W
03B3C:  BTFSC  FD8.2
03B3E:  BRA    3D06
03B40:  SUBWF  xEA,F
03B42:  BTFSC  FD8.2
03B44:  BRA    3C4C
03B46:  BNC   3BC4
03B48:  MOVFF  6E7,6F0
03B4C:  BSF    xF0.7
03B4E:  MOVFF  6E8,6EF
03B52:  MOVFF  6E9,6EE
03B56:  CLRF   xED
03B58:  BCF    FD8.0
03B5A:  RRCF   xF0,F
03B5C:  RRCF   xEF,F
03B5E:  RRCF   xEE,F
03B60:  RRCF   xED,F
03B62:  DECFSZ xEA,F
03B64:  BRA    3B56
03B66:  BTFSS  xEB.7
03B68:  BRA    3B70
03B6A:  BSF    xEC.0
03B6C:  BRA    3D2E
03B6E:  BCF    xEC.0
03B70:  BCF    xEA.0
03B72:  BSF    xEC.4
03B74:  MOVLW  06
03B76:  MOVWF  FEA
03B78:  MOVLW  E5
03B7A:  MOVWF  FE9
03B7C:  BRA    3D54
03B7E:  BCF    xEC.4
03B80:  BTFSC  xEB.7
03B82:  BRA    3B98
03B84:  BTFSS  xEA.0
03B86:  BRA    3BAE
03B88:  RRCF   xF0,F
03B8A:  RRCF   xEF,F
03B8C:  RRCF   xEE,F
03B8E:  RRCF   xED,F
03B90:  INCF   00,F
03B92:  BTFSC  FD8.2
03B94:  BRA    3D24
03B96:  BRA    3BAE
03B98:  BTFSC  xF0.7
03B9A:  BRA    3BB4
03B9C:  BCF    FD8.0
03B9E:  RLCF   xED,F
03BA0:  RLCF   xEE,F
03BA2:  RLCF   xEF,F
03BA4:  RLCF   xF0,F
03BA6:  DECF   00,F
03BA8:  BTFSC  FD8.2
03BAA:  BRA    3D24
03BAC:  BRA    3B98
03BAE:  BSF    xEC.6
03BB0:  BRA    3C8C
03BB2:  BCF    xEC.6
03BB4:  MOVFF  6E3,6EB
03BB8:  BTFSS  xE3.7
03BBA:  BRA    3BC0
03BBC:  BSF    xF0.7
03BBE:  BRA    3D16
03BC0:  BCF    xF0.7
03BC2:  BRA    3D16
03BC4:  MOVFF  6E6,6EA
03BC8:  MOVFF  6E6,00
03BCC:  MOVF   xE2,W
03BCE:  SUBWF  xEA,F
03BD0:  MOVFF  6E3,6F0
03BD4:  BSF    xF0.7
03BD6:  MOVFF  6E4,6EF
03BDA:  MOVFF  6E5,6EE
03BDE:  CLRF   xED
03BE0:  BCF    FD8.0
03BE2:  RRCF   xF0,F
03BE4:  RRCF   xEF,F
03BE6:  RRCF   xEE,F
03BE8:  RRCF   xED,F
03BEA:  DECFSZ xEA,F
03BEC:  BRA    3BDE
03BEE:  BTFSS  xEB.7
03BF0:  BRA    3BF8
03BF2:  BSF    xEC.1
03BF4:  BRA    3D2E
03BF6:  BCF    xEC.1
03BF8:  BCF    xEA.0
03BFA:  BSF    xEC.5
03BFC:  MOVLW  06
03BFE:  MOVWF  FEA
03C00:  MOVLW  E9
03C02:  MOVWF  FE9
03C04:  BRA    3D54
03C06:  BCF    xEC.5
03C08:  BTFSC  xEB.7
03C0A:  BRA    3C20
03C0C:  BTFSS  xEA.0
03C0E:  BRA    3C36
03C10:  RRCF   xF0,F
03C12:  RRCF   xEF,F
03C14:  RRCF   xEE,F
03C16:  RRCF   xED,F
03C18:  INCF   00,F
03C1A:  BTFSC  FD8.2
03C1C:  BRA    3D24
03C1E:  BRA    3C36
03C20:  BTFSC  xF0.7
03C22:  BRA    3C3C
03C24:  BCF    FD8.0
03C26:  RLCF   xED,F
03C28:  RLCF   xEE,F
03C2A:  RLCF   xEF,F
03C2C:  RLCF   xF0,F
03C2E:  DECF   00,F
03C30:  BTFSC  FD8.2
03C32:  BRA    3D24
03C34:  BRA    3C20
03C36:  BSF    xEC.7
03C38:  BRA    3C8C
03C3A:  BCF    xEC.7
03C3C:  MOVFF  6E7,6EB
03C40:  BTFSS  xE7.7
03C42:  BRA    3C48
03C44:  BSF    xF0.7
03C46:  BRA    3D16
03C48:  BCF    xF0.7
03C4A:  BRA    3D16
03C4C:  MOVFF  6E7,6F0
03C50:  BSF    xF0.7
03C52:  MOVFF  6E8,6EF
03C56:  MOVFF  6E9,6EE
03C5A:  BTFSS  xEB.7
03C5C:  BRA    3C66
03C5E:  BCF    xF0.7
03C60:  BSF    xEC.2
03C62:  BRA    3D2E
03C64:  BCF    xEC.2
03C66:  CLRF   xED
03C68:  BCF    xEA.0
03C6A:  MOVLW  06
03C6C:  MOVWF  FEA
03C6E:  MOVLW  E5
03C70:  MOVWF  FE9
03C72:  BRA    3D54
03C74:  BTFSC  xEB.7
03C76:  BRA    3CB0
03C78:  MOVFF  6E3,6EB
03C7C:  BTFSS  xEA.0
03C7E:  BRA    3C8C
03C80:  RRCF   xF0,F
03C82:  RRCF   xEF,F
03C84:  RRCF   xEE,F
03C86:  RRCF   xED,F
03C88:  INCF   00,F
03C8A:  BZ    3D24
03C8C:  BTFSS  xED.7
03C8E:  BRA    3CA6
03C90:  INCF   xEE,F
03C92:  BNZ   3CA6
03C94:  INCF   xEF,F
03C96:  BNZ   3CA6
03C98:  INCF   xF0,F
03C9A:  BNZ   3CA6
03C9C:  RRCF   xF0,F
03C9E:  RRCF   xEF,F
03CA0:  RRCF   xEE,F
03CA2:  INCF   00,F
03CA4:  BZ    3D24
03CA6:  BTFSC  xEC.6
03CA8:  BRA    3BB2
03CAA:  BTFSC  xEC.7
03CAC:  BRA    3C3A
03CAE:  BRA    3CE8
03CB0:  MOVLW  80
03CB2:  XORWF  xF0,F
03CB4:  BTFSS  xF0.7
03CB6:  BRA    3CC0
03CB8:  BRA    3D2E
03CBA:  MOVFF  6E7,6EB
03CBE:  BRA    3CD4
03CC0:  MOVFF  6E3,6EB
03CC4:  MOVF   xF0,F
03CC6:  BNZ   3CD4
03CC8:  MOVF   xEF,F
03CCA:  BNZ   3CD4
03CCC:  MOVF   xEE,F
03CCE:  BNZ   3CD4
03CD0:  CLRF   00
03CD2:  BRA    3D16
03CD4:  BTFSC  xF0.7
03CD6:  BRA    3CE8
03CD8:  BCF    FD8.0
03CDA:  RLCF   xED,F
03CDC:  RLCF   xEE,F
03CDE:  RLCF   xEF,F
03CE0:  RLCF   xF0,F
03CE2:  DECFSZ 00,F
03CE4:  BRA    3CD4
03CE6:  BRA    3D24
03CE8:  BTFSS  xEB.7
03CEA:  BRA    3CF0
03CEC:  BSF    xF0.7
03CEE:  BRA    3D16
03CF0:  BCF    xF0.7
03CF2:  BRA    3D16
03CF4:  MOVFF  6E6,00
03CF8:  MOVFF  6E7,6F0
03CFC:  MOVFF  6E8,6EF
03D00:  MOVFF  6E9,6EE
03D04:  BRA    3D16
03D06:  MOVFF  6E2,00
03D0A:  MOVFF  6E3,6F0
03D0E:  MOVFF  6E4,6EF
03D12:  MOVFF  6E5,6EE
03D16:  MOVFF  6F0,01
03D1A:  MOVFF  6EF,02
03D1E:  MOVFF  6EE,03
03D22:  BRA    3D8C
03D24:  CLRF   00
03D26:  CLRF   01
03D28:  CLRF   02
03D2A:  CLRF   03
03D2C:  BRA    3D8C
03D2E:  CLRF   xED
03D30:  COMF   xEE,F
03D32:  COMF   xEF,F
03D34:  COMF   xF0,F
03D36:  COMF   xED,F
03D38:  INCF   xED,F
03D3A:  BNZ   3D46
03D3C:  INCF   xEE,F
03D3E:  BNZ   3D46
03D40:  INCF   xEF,F
03D42:  BNZ   3D46
03D44:  INCF   xF0,F
03D46:  BTFSC  xEC.0
03D48:  BRA    3B6E
03D4A:  BTFSC  xEC.1
03D4C:  BRA    3BF6
03D4E:  BTFSC  xEC.2
03D50:  BRA    3C64
03D52:  BRA    3CBA
03D54:  MOVF   FEF,W
03D56:  ADDWF  xEE,F
03D58:  BNC   3D64
03D5A:  INCF   xEF,F
03D5C:  BNZ   3D64
03D5E:  INCF   xF0,F
03D60:  BTFSC  FD8.2
03D62:  BSF    xEA.0
03D64:  MOVF   FED,F
03D66:  MOVF   FEF,W
03D68:  ADDWF  xEF,F
03D6A:  BNC   3D72
03D6C:  INCF   xF0,F
03D6E:  BTFSC  FD8.2
03D70:  BSF    xEA.0
03D72:  MOVF   FED,F
03D74:  MOVF   FEF,W
03D76:  BTFSC  FEF.7
03D78:  BRA    3D7C
03D7A:  XORLW  80
03D7C:  ADDWF  xF0,F
03D7E:  BTFSC  FD8.0
03D80:  BSF    xEA.0
03D82:  BTFSC  xEC.4
03D84:  BRA    3B7E
03D86:  BTFSC  xEC.5
03D88:  BRA    3C06
03D8A:  BRA    3C74
03D8C:  MOVLB  0
03D8E:  RETURN 0
03D90:  MOVFF  6DF,6E6
03D94:  MOVLB  6
03D96:  MOVF   xE3,W
03D98:  XORWF  xE6,F
03D9A:  BTFSS  xE6.7
03D9C:  BRA    3DA8
03D9E:  BCF    FD8.2
03DA0:  BCF    FD8.0
03DA2:  BTFSC  xDF.7
03DA4:  BSF    FD8.0
03DA6:  BRA    3E06
03DA8:  MOVFF  6DF,6E6
03DAC:  MOVFF  6E2,6E7
03DB0:  MOVF   xDE,W
03DB2:  SUBWF  xE7,F
03DB4:  BZ    3DC2
03DB6:  BTFSS  xE6.7
03DB8:  BRA    3E06
03DBA:  MOVF   FD8,W
03DBC:  XORLW  01
03DBE:  MOVWF  FD8
03DC0:  BRA    3E06
03DC2:  MOVFF  6E3,6E7
03DC6:  MOVF   xDF,W
03DC8:  SUBWF  xE7,F
03DCA:  BZ    3DD8
03DCC:  BTFSS  xE6.7
03DCE:  BRA    3E06
03DD0:  MOVF   FD8,W
03DD2:  XORLW  01
03DD4:  MOVWF  FD8
03DD6:  BRA    3E06
03DD8:  MOVFF  6E4,6E7
03DDC:  MOVF   xE0,W
03DDE:  SUBWF  xE7,F
03DE0:  BZ    3DEE
03DE2:  BTFSS  xE6.7
03DE4:  BRA    3E06
03DE6:  MOVF   FD8,W
03DE8:  XORLW  01
03DEA:  MOVWF  FD8
03DEC:  BRA    3E06
03DEE:  MOVFF  6E5,6E7
03DF2:  MOVF   xE1,W
03DF4:  SUBWF  xE7,F
03DF6:  BZ    3E04
03DF8:  BTFSS  xE6.7
03DFA:  BRA    3E06
03DFC:  MOVF   FD8,W
03DFE:  XORLW  01
03E00:  MOVWF  FD8
03E02:  BRA    3E06
03E04:  BCF    FD8.0
03E06:  MOVLB  0
03E08:  RETURN 0
03E0A:  MOVLW  8E
03E0C:  MOVWF  00
03E0E:  MOVLB  6
03E10:  MOVF   xDE,W
03E12:  SUBWF  00,F
03E14:  MOVFF  6DF,02
03E18:  MOVFF  6E0,01
03E1C:  BSF    02.7
03E1E:  MOVF   00,F
03E20:  BZ    3E34
03E22:  BCF    FD8.0
03E24:  MOVF   02,F
03E26:  BNZ   3E2C
03E28:  MOVF   01,F
03E2A:  BZ    3E34
03E2C:  RRCF   02,F
03E2E:  RRCF   01,F
03E30:  DECFSZ 00,F
03E32:  BRA    3E22
03E34:  BTFSS  xDF.7
03E36:  BRA    3E42
03E38:  COMF   01,F
03E3A:  COMF   02,F
03E3C:  INCF   01,F
03E3E:  BTFSC  FD8.2
03E40:  INCF   02,F
03E42:  MOVLB  0
03E44:  GOTO   3F02 (RETURN)
*
041CC:  MOVLB  6
041CE:  MOVF   xAC,W
041D0:  BTFSC  FD8.2
041D2:  BRA    431E
041D4:  MOVWF  xB8
041D6:  MOVF   xB0,W
041D8:  BTFSC  FD8.2
041DA:  BRA    431E
041DC:  SUBWF  xB8,F
041DE:  BNC   41EA
041E0:  MOVLW  7F
041E2:  ADDWF  xB8,F
041E4:  BTFSC  FD8.0
041E6:  BRA    431E
041E8:  BRA    41F6
041EA:  MOVLW  81
041EC:  SUBWF  xB8,F
041EE:  BTFSS  FD8.0
041F0:  BRA    431E
041F2:  BTFSC  FD8.2
041F4:  BRA    431E
041F6:  MOVFF  6B8,00
041FA:  CLRF   01
041FC:  CLRF   02
041FE:  CLRF   03
04200:  CLRF   xB7
04202:  MOVFF  6AD,6B6
04206:  BSF    xB6.7
04208:  MOVFF  6AE,6B5
0420C:  MOVFF  6AF,6B4
04210:  MOVLW  19
04212:  MOVWF  xB8
04214:  MOVF   xB3,W
04216:  SUBWF  xB4,F
04218:  BC    4234
0421A:  MOVLW  01
0421C:  SUBWF  xB5,F
0421E:  BC    4234
04220:  SUBWF  xB6,F
04222:  BC    4234
04224:  SUBWF  xB7,F
04226:  BC    4234
04228:  INCF   xB7,F
0422A:  INCF   xB6,F
0422C:  INCF   xB5,F
0422E:  MOVF   xB3,W
04230:  ADDWF  xB4,F
04232:  BRA    4284
04234:  MOVF   xB2,W
04236:  SUBWF  xB5,F
04238:  BC    425E
0423A:  MOVLW  01
0423C:  SUBWF  xB6,F
0423E:  BC    425E
04240:  SUBWF  xB7,F
04242:  BC    425E
04244:  INCF   xB7,F
04246:  INCF   xB6,F
04248:  MOVF   xB2,W
0424A:  ADDWF  xB5,F
0424C:  MOVF   xB3,W
0424E:  ADDWF  xB4,F
04250:  BNC   4284
04252:  INCF   xB5,F
04254:  BNZ   4284
04256:  INCF   xB6,F
04258:  BNZ   4284
0425A:  INCF   xB7,F
0425C:  BRA    4284
0425E:  MOVF   xB1,W
04260:  IORLW  80
04262:  SUBWF  xB6,F
04264:  BC    4282
04266:  MOVLW  01
04268:  SUBWF  xB7,F
0426A:  BC    4282
0426C:  INCF   xB7,F
0426E:  MOVF   xB1,W
04270:  IORLW  80
04272:  ADDWF  xB6,F
04274:  MOVF   xB2,W
04276:  ADDWF  xB5,F
04278:  BNC   424C
0427A:  INCF   xB6,F
0427C:  BNZ   424C
0427E:  INCF   xB7,F
04280:  BRA    424C
04282:  BSF    03.0
04284:  DECFSZ xB8,F
04286:  BRA    428A
04288:  BRA    42A0
0428A:  BCF    FD8.0
0428C:  RLCF   xB4,F
0428E:  RLCF   xB5,F
04290:  RLCF   xB6,F
04292:  RLCF   xB7,F
04294:  BCF    FD8.0
04296:  RLCF   03,F
04298:  RLCF   02,F
0429A:  RLCF   01,F
0429C:  RLCF   xB9,F
0429E:  BRA    4214
042A0:  BTFSS  xB9.0
042A2:  BRA    42B0
042A4:  BCF    FD8.0
042A6:  RRCF   01,F
042A8:  RRCF   02,F
042AA:  RRCF   03,F
042AC:  RRCF   xB9,F
042AE:  BRA    42B4
042B0:  DECF   00,F
042B2:  BZ    431E
042B4:  BTFSC  xB9.7
042B6:  BRA    42F4
042B8:  BCF    FD8.0
042BA:  RLCF   xB4,F
042BC:  RLCF   xB5,F
042BE:  RLCF   xB6,F
042C0:  RLCF   xB7,F
042C2:  MOVF   xB3,W
042C4:  SUBWF  xB4,F
042C6:  BC    42D6
042C8:  MOVLW  01
042CA:  SUBWF  xB5,F
042CC:  BC    42D6
042CE:  SUBWF  xB6,F
042D0:  BC    42D6
042D2:  SUBWF  xB7,F
042D4:  BNC   430A
042D6:  MOVF   xB2,W
042D8:  SUBWF  xB5,F
042DA:  BC    42E6
042DC:  MOVLW  01
042DE:  SUBWF  xB6,F
042E0:  BC    42E6
042E2:  SUBWF  xB7,F
042E4:  BNC   430A
042E6:  MOVF   xB1,W
042E8:  IORLW  80
042EA:  SUBWF  xB6,F
042EC:  BC    42F4
042EE:  MOVLW  01
042F0:  SUBWF  xB7,F
042F2:  BNC   430A
042F4:  INCF   03,F
042F6:  BNZ   430A
042F8:  INCF   02,F
042FA:  BNZ   430A
042FC:  INCF   01,F
042FE:  BNZ   430A
04300:  INCF   00,F
04302:  BZ    431E
04304:  RRCF   01,F
04306:  RRCF   02,F
04308:  RRCF   03,F
0430A:  MOVFF  6AD,6B8
0430E:  MOVF   xB1,W
04310:  XORWF  xB8,F
04312:  BTFSS  xB8.7
04314:  BRA    431A
04316:  BSF    01.7
04318:  BRA    4326
0431A:  BCF    01.7
0431C:  BRA    4326
0431E:  CLRF   00
04320:  CLRF   01
04322:  CLRF   02
04324:  CLRF   03
04326:  MOVLB  0
04328:  RETURN 0
*
0437A:  TBLRD*+
0437C:  MOVF   FF5,F
0437E:  BZ    43A2
04380:  MOVFF  FF6,6A8
04384:  MOVFF  FF7,6A9
04388:  MOVFF  FF8,6AA
0438C:  MOVFF  FF5,6BD
04390:  CALL   0FC6
04394:  MOVFF  6A8,FF6
04398:  MOVFF  6A9,FF7
0439C:  MOVFF  6AA,FF8
043A0:  BRA    437A
043A2:  RETURN 0
*
0490A:  MOVLW  20
0490C:  MOVLB  6
0490E:  BTFSS  x63.4
04910:  MOVLW  30
04912:  MOVWF  x64
04914:  MOVFF  662,00
04918:  BTFSS  00.7
0491A:  BRA    492C
0491C:  COMF   00,F
0491E:  INCF   00,F
04920:  MOVFF  00,662
04924:  MOVLW  2D
04926:  MOVWF  x64
04928:  BSF    x63.7
0492A:  BSF    x63.0
0492C:  MOVF   01,W
0492E:  CLRF   1B
04930:  BTFSC  FF2.7
04932:  BSF    1B.7
04934:  BCF    FF2.7
04936:  MOVFF  662,6F5
0493A:  MOVLW  64
0493C:  MOVWF  xF6
0493E:  MOVLB  0
04940:  CALL   0642
04944:  BTFSC  1B.7
04946:  BSF    FF2.7
04948:  MOVFF  00,662
0494C:  MOVLW  30
0494E:  ADDWF  01,W
04950:  MOVLB  6
04952:  MOVWF  x65
04954:  CLRF   1B
04956:  BTFSC  FF2.7
04958:  BSF    1B.7
0495A:  BCF    FF2.7
0495C:  MOVFF  662,6F5
04960:  MOVLW  0A
04962:  MOVWF  xF6
04964:  MOVLB  0
04966:  CALL   0642
0496A:  BTFSC  1B.7
0496C:  BSF    FF2.7
0496E:  MOVLW  30
04970:  ADDWF  00,W
04972:  MOVLB  6
04974:  MOVWF  x67
04976:  MOVLW  30
04978:  ADDWF  01,W
0497A:  MOVWF  x66
0497C:  MOVFF  664,00
04980:  MOVLW  30
04982:  SUBWF  x65,W
04984:  BZ    498E
04986:  BSF    x63.1
04988:  BTFSC  x63.7
0498A:  BSF    x63.2
0498C:  BRA    49B2
0498E:  BTFSC  x63.2
04990:  BRA    49B2
04992:  MOVFF  664,665
04996:  BTFSC  x63.1
04998:  BRA    49A2
0499A:  MOVLW  30
0499C:  SUBWF  x66,W
0499E:  BZ    49A8
049A0:  BSF    x63.0
049A2:  BTFSC  x63.7
049A4:  BSF    x63.1
049A6:  BRA    49B2
049A8:  BTFSS  FD8.2
049AA:  BSF    x63.0
049AC:  BTFSC  FD8.2
049AE:  MOVFF  665,666
049B2:  BTFSC  x63.2
049B4:  BRA    49C0
049B6:  BTFSC  x63.1
049B8:  BRA    49CA
049BA:  BTFSC  x63.0
049BC:  BRA    49D4
049BE:  BRA    49DE
049C0:  MOVFF  664,6BD
049C4:  MOVLB  0
049C6:  CALL   0FC6
049CA:  MOVFF  665,6BD
049CE:  MOVLB  0
049D0:  CALL   0FC6
049D4:  MOVFF  666,6BD
049D8:  MOVLB  0
049DA:  CALL   0FC6
049DE:  MOVFF  667,6BD
049E2:  MOVLB  0
049E4:  CALL   0FC6
049E8:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device adc=12
.................... #FUSES WDT_SW, WDT32768, INTRC_IO, SOSC_HIGH, NOPROTECT, NOIESO, BROWNOUT, PUT, NOCPD, STVREN, NODEBUG, NOWRT, NOWRTD, NOEBTR, NOCPB, NOEBTRB, NOWRTC, NOWRTB, FCMEN, NOXINST, MCLR, RTCOSC_T1
.................... #use delay(clock=16000000)
*
00F16:  MOVLW  06
00F18:  MOVWF  FEA
00F1A:  MOVLW  6E
00F1C:  MOVWF  FE9
00F1E:  MOVF   FEF,W
00F20:  BZ    0F3E
00F22:  MOVLW  05
00F24:  MOVWF  01
00F26:  CLRF   00
00F28:  DECFSZ 00,F
00F2A:  BRA    0F28
00F2C:  DECFSZ 01,F
00F2E:  BRA    0F26
00F30:  MOVLW  2E
00F32:  MOVWF  00
00F34:  DECFSZ 00,F
00F36:  BRA    0F34
00F38:  BRA    0F3A
00F3A:  DECFSZ FEF,F
00F3C:  BRA    0F22
00F3E:  RETURN 0
.................... 
.................... #use spi(MASTER, FORCE_HW, SPI1, MODE=1, BITS=8)
.................... #use i2c(MASTER, sda=PIN_D5, scl=PIN_D6)
*
00F6E:  BCF    F67.7
00F70:  BCF    FA1.5
00F72:  MOVFF  649,F6A
00F76:  MOVLW  02
00F78:  BTFSC  F67.7
00F7A:  BRA    0F86
00F7C:  BTFSS  FA1.5
00F7E:  BRA    0F7C
00F80:  MOVLW  00
00F82:  BTFSC  F66.6
00F84:  MOVLW  01
00F86:  MOVWF  01
00F88:  RETURN 0
00F8A:  BCF    F67.6
00F8C:  BSF    F66.3
00F8E:  BTFSC  F66.3
00F90:  BRA    0F8E
00F92:  BTFSC  00.0
00F94:  BCF    F66.5
00F96:  BTFSS  00.0
00F98:  BSF    F66.5
00F9A:  BSF    F66.4
00F9C:  BTFSC  F66.4
00F9E:  BRA    0F9C
00FA0:  MOVFF  F6A,01
00FA4:  GOTO   116A (RETURN)
.................... 
.................... //#use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT2)
.................... #use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT1)
.................... 
.................... #use rs232(baud=57600, xmit=PIN_G4, rcv=PIN_G3, stream=RS232_BTD200)
*
01DCE:  BSF    F98.3
01DD0:  BTFSC  F86.3
01DD2:  BRA    1DD0
01DD4:  MOVLW  08
01DD6:  MOVWF  00
01DD8:  MOVLB  6
01DDA:  CLRF   x66
01DDC:  BSF    00.7
01DDE:  BRA    1DFC
01DE0:  BCF    00.7
01DE2:  BRA    1DFC
01DE4:  BCF    FD8.0
01DE6:  BTFSC  F86.3
01DE8:  BSF    FD8.0
01DEA:  RRCF   x66,F
01DEC:  BSF    00.6
01DEE:  BRA    1DFC
01DF0:  BCF    00.6
01DF2:  DECFSZ 00,F
01DF4:  BRA    1DE4
01DF6:  MOVFF  666,01
01DFA:  BRA    1E14
01DFC:  MOVLW  10
01DFE:  BTFSC  00.7
01E00:  MOVLW  04
01E02:  MOVWF  01
01E04:  DECFSZ 01,F
01E06:  BRA    1E04
01E08:  BRA    1E0A
01E0A:  BTFSC  00.7
01E0C:  BRA    1DE0
01E0E:  BTFSC  00.6
01E10:  BRA    1DF0
01E12:  BRA    1DE4
01E14:  MOVLB  0
01E16:  RETURN 0
*
023B4:  BCF    F98.4
023B6:  BCF    F8F.4
023B8:  MOVLW  08
023BA:  MOVWF  01
023BC:  BRA    23BE
023BE:  NOP   
023C0:  BSF    01.7
023C2:  BRA    23E4
023C4:  BCF    01.7
023C6:  MOVLB  6
023C8:  RRCF   x91,F
023CA:  MOVLB  0
023CC:  BTFSC  FD8.0
023CE:  BSF    F8F.4
023D0:  BTFSS  FD8.0
023D2:  BCF    F8F.4
023D4:  BSF    01.6
023D6:  BRA    23E4
023D8:  BCF    01.6
023DA:  DECFSZ 01,F
023DC:  BRA    23C6
023DE:  BRA    23E0
023E0:  NOP   
023E2:  BSF    F8F.4
023E4:  MOVLW  10
023E6:  MOVWF  FE9
023E8:  DECFSZ FE9,F
023EA:  BRA    23E8
023EC:  BRA    23EE
023EE:  NOP   
023F0:  BTFSC  01.7
023F2:  BRA    23C4
023F4:  BTFSC  01.6
023F6:  BRA    23D8
023F8:  RETURN 0
.................... #use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=GSM)
.................... //#use rs232(baud=57600, xmit=TX_B, rcv=RX_B, stream=RS232_BTD200)
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+3);
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
*
03E48:  MOVLB  6
03E4A:  CLRF   xC3
03E4C:  CLRF   xC2
03E4E:  CLRF   xC1
03E50:  MOVLW  7F
03E52:  MOVWF  xC0
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
03E54:  MOVLW  7E
03E56:  MOVWF  xCA
03E58:  MOVLW  80
03E5A:  MOVWF  xCB
03E5C:  CLRF   xCC
03E5E:  CLRF   xCD
03E60:  MOVLW  7A
03E62:  MOVWF  xCE
03E64:  MOVLW  2A
03E66:  MOVWF  xCF
03E68:  MOVLW  AA
03E6A:  MOVWF  xD0
03E6C:  MOVLW  A3
03E6E:  MOVWF  xD1
03E70:  MOVLW  75
03E72:  MOVWF  xD2
03E74:  MOVLW  B6
03E76:  MOVWF  xD3
03E78:  MOVLW  09
03E7A:  MOVWF  xD4
03E7C:  MOVLW  B4
03E7E:  MOVWF  xD5
03E80:  MOVLW  6F
03E82:  MOVWF  xD6
03E84:  MOVLW  4F
03E86:  MOVWF  xD7
03E88:  MOVLW  B6
03E8A:  MOVWF  xD8
03E8C:  MOVLW  AA
03E8E:  MOVWF  xD9
03E90:  MOVLW  69
03E92:  MOVWF  xDA
03E94:  MOVLW  8B
03E96:  MOVWF  xDB
03E98:  MOVLW  F6
03E9A:  MOVWF  xDC
03E9C:  MOVLW  E8
03E9E:  MOVWF  xDD
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
03EA0:  MOVFF  6B7,6E1
03EA4:  MOVFF  6B6,6E0
03EA8:  MOVFF  6B5,6DF
03EAC:  MOVFF  6B4,6DE
03EB0:  CLRF   xE5
03EB2:  CLRF   xE4
03EB4:  CLRF   xE3
03EB6:  CLRF   xE2
03EB8:  MOVLB  0
03EBA:  RCALL  3D90
03EBC:  BNC   3EC8
03EBE:  MOVLB  6
03EC0:  MOVF   xB5,W
03EC2:  XORLW  80
03EC4:  MOVWF  xB5
03EC6:  MOVLB  0
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
03EC8:  MOVFF  6B7,6E5
03ECC:  MOVFF  6B6,6E4
03ED0:  MOVFF  6B5,6E3
03ED4:  MOVFF  6B4,6E2
03ED8:  MOVLW  83
03EDA:  MOVLB  6
03EDC:  MOVWF  xE9
03EDE:  MOVLW  F9
03EE0:  MOVWF  xE8
03EE2:  MOVLW  22
03EE4:  MOVWF  xE7
03EE6:  MOVLW  7E
03EE8:  MOVWF  xE6
03EEA:  MOVLB  0
03EEC:  CALL   32A4
03EF0:  MOVFF  03,6E1
03EF4:  MOVFF  02,6E0
03EF8:  MOVFF  01,6DF
03EFC:  MOVFF  00,6DE
03F00:  BRA    3E0A
03F02:  MOVFF  01,6C4
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
03F06:  MOVFF  6B7,6E5
03F0A:  MOVFF  6B6,6E4
03F0E:  MOVFF  6B5,6E3
03F12:  MOVFF  6B4,6E2
03F16:  MOVLW  83
03F18:  MOVLB  6
03F1A:  MOVWF  xE9
03F1C:  MOVLW  F9
03F1E:  MOVWF  xE8
03F20:  MOVLW  22
03F22:  MOVWF  xE7
03F24:  MOVLW  7E
03F26:  MOVWF  xE6
03F28:  MOVLB  0
03F2A:  CALL   32A4
03F2E:  MOVFF  03,6E1
03F32:  MOVFF  02,6E0
03F36:  MOVFF  01,6DF
03F3A:  MOVFF  00,6DE
03F3E:  MOVLB  6
03F40:  CLRF   xE3
03F42:  MOVFF  6C4,6E2
03F46:  MOVLB  0
03F48:  CALL   326E
03F4C:  BSF    FD8.1
03F4E:  MOVFF  6E1,6E5
03F52:  MOVFF  6E0,6E4
03F56:  MOVFF  6DF,6E3
03F5A:  MOVFF  6DE,6E2
03F5E:  MOVFF  03,6E9
03F62:  MOVFF  02,6E8
03F66:  MOVFF  01,6E7
03F6A:  MOVFF  00,6E6
03F6E:  RCALL  3B18
03F70:  MOVFF  03,6C9
03F74:  MOVFF  02,6C8
03F78:  MOVFF  01,6C7
03F7C:  MOVFF  00,6C6
....................    quad = quad % 4;                    // quadrant (0 to 3)
03F80:  MOVLW  03
03F82:  MOVLB  6
03F84:  ANDWF  xC4,F
.................... 
....................    if (quad == 0 || quad == 2)
03F86:  MOVF   xC4,F
03F88:  BZ    3F90
03F8A:  MOVF   xC4,W
03F8C:  SUBLW  02
03F8E:  BNZ   3FCA
....................       t = frac * PI_DIV_BY_TWO;
03F90:  MOVFF  6C9,6E5
03F94:  MOVFF  6C8,6E4
03F98:  MOVFF  6C7,6E3
03F9C:  MOVFF  6C6,6E2
03FA0:  MOVLW  DB
03FA2:  MOVWF  xE9
03FA4:  MOVLW  0F
03FA6:  MOVWF  xE8
03FA8:  MOVLW  49
03FAA:  MOVWF  xE7
03FAC:  MOVLW  7F
03FAE:  MOVWF  xE6
03FB0:  MOVLB  0
03FB2:  CALL   32A4
03FB6:  MOVFF  03,6BF
03FBA:  MOVFF  02,6BE
03FBE:  MOVFF  01,6BD
03FC2:  MOVFF  00,6BC
03FC6:  BRA    40A2
03FC8:  MOVLB  6
....................    else if (quad == 1)
03FCA:  DECFSZ xC4,W
03FCC:  BRA    403A
....................       t = (1-frac) * PI_DIV_BY_TWO;
03FCE:  BSF    FD8.1
03FD0:  CLRF   xE5
03FD2:  CLRF   xE4
03FD4:  CLRF   xE3
03FD6:  MOVLW  7F
03FD8:  MOVWF  xE2
03FDA:  MOVFF  6C9,6E9
03FDE:  MOVFF  6C8,6E8
03FE2:  MOVFF  6C7,6E7
03FE6:  MOVFF  6C6,6E6
03FEA:  MOVLB  0
03FEC:  RCALL  3B18
03FEE:  MOVFF  03,6E1
03FF2:  MOVFF  02,6E0
03FF6:  MOVFF  01,6DF
03FFA:  MOVFF  00,6DE
03FFE:  MOVFF  03,6E5
04002:  MOVFF  02,6E4
04006:  MOVFF  01,6E3
0400A:  MOVFF  00,6E2
0400E:  MOVLW  DB
04010:  MOVLB  6
04012:  MOVWF  xE9
04014:  MOVLW  0F
04016:  MOVWF  xE8
04018:  MOVLW  49
0401A:  MOVWF  xE7
0401C:  MOVLW  7F
0401E:  MOVWF  xE6
04020:  MOVLB  0
04022:  CALL   32A4
04026:  MOVFF  03,6BF
0402A:  MOVFF  02,6BE
0402E:  MOVFF  01,6BD
04032:  MOVFF  00,6BC
04036:  BRA    40A2
04038:  MOVLB  6
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
0403A:  BSF    FD8.1
0403C:  MOVFF  6C9,6E5
04040:  MOVFF  6C8,6E4
04044:  MOVFF  6C7,6E3
04048:  MOVFF  6C6,6E2
0404C:  CLRF   xE9
0404E:  CLRF   xE8
04050:  CLRF   xE7
04052:  MOVLW  7F
04054:  MOVWF  xE6
04056:  MOVLB  0
04058:  RCALL  3B18
0405A:  MOVFF  03,6E1
0405E:  MOVFF  02,6E0
04062:  MOVFF  01,6DF
04066:  MOVFF  00,6DE
0406A:  MOVFF  03,6E5
0406E:  MOVFF  02,6E4
04072:  MOVFF  01,6E3
04076:  MOVFF  00,6E2
0407A:  MOVLW  DB
0407C:  MOVLB  6
0407E:  MOVWF  xE9
04080:  MOVLW  0F
04082:  MOVWF  xE8
04084:  MOVLW  49
04086:  MOVWF  xE7
04088:  MOVLW  7F
0408A:  MOVWF  xE6
0408C:  MOVLB  0
0408E:  CALL   32A4
04092:  MOVFF  03,6BF
04096:  MOVFF  02,6BE
0409A:  MOVFF  01,6BD
0409E:  MOVFF  00,6BC
.................... 
....................    y = 1.0;
040A2:  MOVLB  6
040A4:  CLRF   xBB
040A6:  CLRF   xBA
040A8:  CLRF   xB9
040AA:  MOVLW  7F
040AC:  MOVWF  xB8
....................    t = t * t;
040AE:  MOVFF  6BF,6E5
040B2:  MOVFF  6BE,6E4
040B6:  MOVFF  6BD,6E3
040BA:  MOVFF  6BC,6E2
040BE:  MOVFF  6BF,6E9
040C2:  MOVFF  6BE,6E8
040C6:  MOVFF  6BD,6E7
040CA:  MOVFF  6BC,6E6
040CE:  MOVLB  0
040D0:  CALL   32A4
040D4:  MOVFF  03,6BF
040D8:  MOVFF  02,6BE
040DC:  MOVFF  01,6BD
040E0:  MOVFF  00,6BC
....................    for (i = 0; i <= 4; i++)
040E4:  MOVLB  6
040E6:  CLRF   xC5
040E8:  MOVF   xC5,W
040EA:  SUBLW  04
040EC:  BNC   41A8
....................    {
....................       t2 = t2 * t;
040EE:  MOVFF  6C3,6E5
040F2:  MOVFF  6C2,6E4
040F6:  MOVFF  6C1,6E3
040FA:  MOVFF  6C0,6E2
040FE:  MOVFF  6BF,6E9
04102:  MOVFF  6BE,6E8
04106:  MOVFF  6BD,6E7
0410A:  MOVFF  6BC,6E6
0410E:  MOVLB  0
04110:  CALL   32A4
04114:  MOVFF  03,6C3
04118:  MOVFF  02,6C2
0411C:  MOVFF  01,6C1
04120:  MOVFF  00,6C0
....................       y = y + p[i] * t2;
04124:  MOVLB  6
04126:  MOVF   xC5,W
04128:  MULLW  04
0412A:  MOVF   FF3,W
0412C:  CLRF   03
0412E:  ADDLW  CA
04130:  MOVWF  FE9
04132:  MOVLW  06
04134:  ADDWFC 03,W
04136:  MOVWF  FEA
04138:  MOVFF  FEF,6E2
0413C:  MOVFF  FEC,6E3
04140:  MOVFF  FEC,6E4
04144:  MOVFF  FEC,6E5
04148:  MOVFF  6C3,6E9
0414C:  MOVFF  6C2,6E8
04150:  MOVFF  6C1,6E7
04154:  MOVFF  6C0,6E6
04158:  MOVLB  0
0415A:  CALL   32A4
0415E:  MOVFF  FEA,6DF
04162:  MOVFF  FE9,6DE
04166:  BCF    FD8.1
04168:  MOVFF  6BB,6E5
0416C:  MOVFF  6BA,6E4
04170:  MOVFF  6B9,6E3
04174:  MOVFF  6B8,6E2
04178:  MOVFF  03,6E9
0417C:  MOVFF  02,6E8
04180:  MOVFF  01,6E7
04184:  MOVFF  00,6E6
04188:  RCALL  3B18
0418A:  MOVFF  6DF,FEA
0418E:  MOVFF  6DE,FE9
04192:  MOVFF  03,6BB
04196:  MOVFF  02,6BA
0419A:  MOVFF  01,6B9
0419E:  MOVFF  00,6B8
041A2:  MOVLB  6
041A4:  INCF   xC5,F
041A6:  BRA    40E8
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
041A8:  MOVF   xC4,W
041AA:  SUBLW  02
041AC:  BZ    41B2
041AE:  DECFSZ xC4,W
041B0:  BRA    41B8
....................       y = -y;  // correct sign
041B2:  MOVF   xB9,W
041B4:  XORLW  80
041B6:  MOVWF  xB9
.................... 
....................    return (y);
041B8:  MOVFF  6B8,00
041BC:  MOVFF  6B9,01
041C0:  MOVFF  6BA,02
041C4:  MOVFF  6BB,03
041C8:  MOVLB  0
041CA:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
*
0432A:  BSF    FD8.1
0432C:  MOVFF  6AF,6E5
04330:  MOVFF  6AE,6E4
04334:  MOVFF  6AD,6E3
04338:  MOVFF  6AC,6E2
0433C:  MOVLW  DB
0433E:  MOVLB  6
04340:  MOVWF  xE9
04342:  MOVLW  0F
04344:  MOVWF  xE8
04346:  MOVLW  49
04348:  MOVWF  xE7
0434A:  MOVLW  7F
0434C:  MOVWF  xE6
0434E:  MOVLB  0
04350:  CALL   3B18
04354:  MOVFF  03,6B3
04358:  MOVFF  02,6B2
0435C:  MOVFF  01,6B1
04360:  MOVFF  00,6B0
04364:  MOVFF  03,6B7
04368:  MOVFF  02,6B6
0436C:  MOVFF  01,6B5
04370:  MOVFF  00,6B4
04374:  RCALL  3E48
04376:  GOTO   4668 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
0198E:  MOVFF  6A9,6AD
01992:  MOVFF  6A8,6AC
01996:  MOVFF  6AD,FEA
0199A:  MOVLB  6
0199C:  MOVFF  6AC,FE9
019A0:  MOVF   FEF,F
019A2:  BZ    19B0
019A4:  INCF   xAC,F
019A6:  BTFSC  FD8.2
019A8:  INCF   xAD,F
019AA:  MOVLB  0
019AC:  BRA    1996
019AE:  MOVLB  6
....................    while(*s2 != '\0')
019B0:  MOVFF  6AB,FEA
019B4:  MOVFF  6AA,FE9
019B8:  MOVF   FEF,F
019BA:  BZ    19E2
....................    {
....................       *s = *s2;
019BC:  MOVFF  6AB,FEA
019C0:  MOVFF  6AA,FE9
019C4:  MOVFF  FEF,6B0
019C8:  MOVFF  6AD,FEA
019CC:  MOVFF  6AC,FE9
019D0:  MOVFF  6B0,FEF
....................       ++s;
019D4:  INCF   xAC,F
019D6:  BTFSC  FD8.2
019D8:  INCF   xAD,F
....................       ++s2;
019DA:  INCF   xAA,F
019DC:  BTFSC  FD8.2
019DE:  INCF   xAB,F
019E0:  BRA    19B0
....................    }
.................... 
....................    *s = '\0';
019E2:  MOVFF  6AD,FEA
019E6:  MOVFF  6AC,FE9
019EA:  CLRF   FEF
....................    return(s1);
019EC:  MOVFF  6A8,01
019F0:  MOVFF  6A9,02
019F4:  MOVLB  0
019F6:  RETURN 0
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
019F8:  MOVFF  667,66D
019FC:  MOVFF  666,66C
01A00:  MOVFF  66D,FEA
01A04:  MOVLB  6
01A06:  MOVFF  66C,FE9
01A0A:  MOVF   FEF,F
01A0C:  BZ    1A1A
01A0E:  INCF   x6C,F
01A10:  BTFSC  FD8.2
01A12:  INCF   x6D,F
01A14:  MOVLB  0
01A16:  BRA    1A00
01A18:  MOVLB  6
....................    while(*s2 != '\0' && 0<n)
01A1A:  MOVFF  669,FEA
01A1E:  MOVFF  668,FE9
01A22:  MOVF   FEF,F
01A24:  BZ    1A5E
01A26:  MOVF   x6B,F
01A28:  BNZ   1A30
01A2A:  MOVF   x6A,W
01A2C:  SUBLW  00
01A2E:  BC    1A5E
....................    {
....................       *s = *s2;
01A30:  MOVFF  669,FEA
01A34:  MOVFF  668,FE9
01A38:  MOVFF  FEF,670
01A3C:  MOVFF  66D,FEA
01A40:  MOVFF  66C,FE9
01A44:  MOVFF  670,FEF
....................       ++s;
01A48:  INCF   x6C,F
01A4A:  BTFSC  FD8.2
01A4C:  INCF   x6D,F
....................       ++s2;
01A4E:  INCF   x68,F
01A50:  BTFSC  FD8.2
01A52:  INCF   x69,F
....................       --n;
01A54:  MOVF   x6A,W
01A56:  BTFSC  FD8.2
01A58:  DECF   x6B,F
01A5A:  DECF   x6A,F
01A5C:  BRA    1A1A
....................    }
.................... 
....................    *s = '\0';
01A5E:  MOVFF  66D,FEA
01A62:  MOVFF  66C,FE9
01A66:  CLRF   FEF
....................    return(s1);
01A68:  MOVFF  666,01
01A6C:  MOVFF  667,02
01A70:  MOVLB  0
01A72:  GOTO   1B0E (RETURN)
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
03722:  MOVFF  6DD,6E0
....................    for(su=s;0<n;++su,--n)
03726:  MOVFF  6DC,6E2
0372A:  MOVFF  6DB,6E1
0372E:  MOVLB  6
03730:  MOVF   xDF,F
03732:  BNZ   373A
03734:  MOVF   xDE,W
03736:  SUBLW  00
03738:  BC    3762
....................       if(*su==uc)
0373A:  MOVFF  6E2,FEA
0373E:  MOVFF  6E1,FE9
03742:  MOVF   xE0,W
03744:  SUBWF  FEF,W
03746:  BNZ   3752
....................       return su;
03748:  MOVFF  6E1,01
0374C:  MOVFF  6E2,02
03750:  BRA    3768
03752:  INCF   xE1,F
03754:  BTFSC  FD8.2
03756:  INCF   xE2,F
03758:  MOVF   xDE,W
0375A:  BTFSC  FD8.2
0375C:  DECF   xDF,F
0375E:  DECF   xDE,F
03760:  BRA    3730
....................    return NULL;
03762:  MOVLW  00
03764:  MOVWF  01
03766:  MOVWF  02
03768:  MOVLB  0
0376A:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
0130C:  MOVFF  6B1,6B5
01310:  MOVFF  6B0,6B4
01314:  MOVFF  6B5,FEA
01318:  MOVLB  6
0131A:  MOVFF  6B4,FE9
0131E:  MOVF   FEF,F
01320:  BZ    1372
....................       for (sc2 = s2; *sc2 != 0; sc2++)
01322:  MOVFF  6B3,6B7
01326:  MOVFF  6B2,6B6
0132A:  MOVFF  6B7,FEA
0132E:  MOVFF  6B6,FE9
01332:  MOVF   FEF,F
01334:  BZ    1366
....................          if (*sc1 == *sc2)
01336:  MOVFF  6B5,03
0133A:  MOVFF  6B4,FE9
0133E:  MOVFF  03,FEA
01342:  MOVFF  FEF,6B8
01346:  MOVFF  6B7,FEA
0134A:  MOVFF  6B6,FE9
0134E:  MOVF   FEF,W
01350:  SUBWF  xB8,W
01352:  BNZ   135E
....................             return(sc1);
01354:  MOVFF  6B4,01
01358:  MOVFF  6B5,02
0135C:  BRA    1378
0135E:  INCF   xB6,F
01360:  BTFSC  FD8.2
01362:  INCF   xB7,F
01364:  BRA    132A
01366:  INCF   xB4,F
01368:  BTFSC  FD8.2
0136A:  INCF   xB5,F
0136C:  MOVLB  0
0136E:  BRA    1314
01370:  MOVLB  6
....................    return(0);
01372:  MOVLW  00
01374:  MOVWF  01
01376:  MOVWF  02
01378:  MOVLB  0
0137A:  GOTO   1418 (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
01284:  MOVFF  6B1,6B5
01288:  MOVFF  6B0,6B4
0128C:  MOVFF  6B5,FEA
01290:  MOVLB  6
01292:  MOVFF  6B4,FE9
01296:  MOVF   FEF,F
01298:  BZ    12F4
....................       for (sc2 = s2; ; sc2++)
0129A:  MOVFF  6B3,6B7
0129E:  MOVFF  6B2,6B6
....................     if (*sc2 == '\0')
012A2:  MOVFF  6B7,FEA
012A6:  MOVFF  6B6,FE9
012AA:  MOVF   FEF,F
012AC:  BNZ   12C4
....................        return(sc1 - s1);
012AE:  MOVF   xB0,W
012B0:  SUBWF  xB4,W
012B2:  MOVWF  00
012B4:  MOVF   xB1,W
012B6:  SUBWFB xB5,W
012B8:  MOVWF  03
012BA:  MOVFF  00,01
012BE:  MOVWF  02
012C0:  BRA    1306
012C2:  BRA    12E0
....................          else if (*sc1 == *sc2)
012C4:  MOVFF  6B5,FEA
012C8:  MOVFF  6B4,FE9
012CC:  MOVFF  FEF,6B8
012D0:  MOVFF  6B7,FEA
012D4:  MOVFF  6B6,FE9
012D8:  MOVF   FEF,W
012DA:  SUBWF  xB8,W
012DC:  BNZ   12E0
....................             break;
012DE:  BRA    12E8
012E0:  INCF   xB6,F
012E2:  BTFSC  FD8.2
012E4:  INCF   xB7,F
012E6:  BRA    12A2
012E8:  INCF   xB4,F
012EA:  BTFSC  FD8.2
012EC:  INCF   xB5,F
012EE:  MOVLB  0
012F0:  BRA    128C
012F2:  MOVLB  6
....................    return(sc1 - s1);
012F4:  MOVF   xB0,W
012F6:  SUBWF  xB4,W
012F8:  MOVWF  00
012FA:  MOVF   xB1,W
012FC:  SUBWFB xB5,W
012FE:  MOVWF  03
01300:  MOVFF  00,01
01304:  MOVWF  02
01306:  MOVLB  0
01308:  GOTO   13E6 (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0137E:  MOVFF  6B1,6B3
01382:  MOVFF  6B0,6B2
01386:  MOVFF  6B3,FEA
0138A:  MOVLB  6
0138C:  MOVFF  6B2,FE9
01390:  MOVF   FEF,F
01392:  BZ    13A0
01394:  INCF   xB2,F
01396:  BTFSC  FD8.2
01398:  INCF   xB3,F
0139A:  MOVLB  0
0139C:  BRA    1386
0139E:  MOVLB  6
....................    return(sc - s);
013A0:  MOVF   xB0,W
013A2:  SUBWF  xB2,W
013A4:  MOVWF  00
013A6:  MOVF   xB1,W
013A8:  SUBWFB xB3,W
013AA:  MOVWF  03
013AC:  MOVFF  00,01
013B0:  MOVWF  02
013B2:  MOVLB  0
013B4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
013B6:  MOVLB  6
013B8:  MOVF   xA8,W
013BA:  IORWF  xA9,W
013BC:  BZ    13C6
013BE:  MOVFF  6A9,03
013C2:  MOVF   xA8,W
013C4:  BRA    13CC
013C6:  MOVFF  1D,03
013CA:  MOVF   1C,W
013CC:  MOVWF  xAC
013CE:  MOVFF  03,6AD
....................    beg += strspn(beg, s2);
013D2:  MOVFF  6AD,6B1
013D6:  MOVFF  6AC,6B0
013DA:  MOVFF  6AB,6B3
013DE:  MOVFF  6AA,6B2
013E2:  MOVLB  0
013E4:  BRA    1284
013E6:  MOVF   01,W
013E8:  MOVLB  6
013EA:  ADDWF  xAC,F
013EC:  MOVF   02,W
013EE:  ADDWFC xAD,F
....................    if (*beg == '\0')
013F0:  MOVFF  6AD,FEA
013F4:  MOVFF  6AC,FE9
013F8:  MOVF   FEF,F
013FA:  BNZ   1404
....................       return(0);
013FC:  MOVLW  00
013FE:  MOVWF  01
01400:  MOVWF  02
01402:  BRA    1466
....................       
....................    end = strpbrk(beg, s2);
01404:  MOVFF  6AD,6B1
01408:  MOVFF  6AC,6B0
0140C:  MOVFF  6AB,6B3
01410:  MOVFF  6AA,6B2
01414:  MOVLB  0
01416:  BRA    130C
01418:  MOVFF  02,6AF
0141C:  MOVFF  01,6AE
....................    if (end != '\0')
01420:  MOVLB  6
01422:  MOVF   xAE,F
01424:  BNZ   142A
01426:  MOVF   xAF,F
01428:  BZ    1444
....................    {
....................       *end = '\0';
0142A:  MOVFF  6AF,FEA
0142E:  MOVFF  6AE,FE9
01432:  CLRF   FEF
....................       end++;
01434:  INCF   xAE,F
01436:  BTFSC  FD8.2
01438:  INCF   xAF,F
....................       save = end;
0143A:  MOVFF  6AF,1D
0143E:  MOVFF  6AE,1C
....................    }
01442:  BRA    145E
....................    else
....................       save = beg + strlen(beg);
01444:  MOVFF  6AD,6B1
01448:  MOVFF  6AC,6B0
0144C:  MOVLB  0
0144E:  RCALL  137E
01450:  MOVF   01,W
01452:  MOVLB  6
01454:  ADDWF  xAC,W
01456:  MOVWF  1C
01458:  MOVF   02,W
0145A:  ADDWFC xAD,W
0145C:  MOVWF  1D
....................    
....................    return(beg);
0145E:  MOVFF  6AC,01
01462:  MOVFF  6AD,02
01466:  MOVLB  0
01468:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
*
050E2:  MOVFF  5A0,FEA
050E6:  MOVLB  5
050E8:  MOVFF  59F,FE9
050EC:  MOVFF  FEF,5A3
050F0:  MOVFF  5A2,FEA
050F4:  MOVFF  5A1,FE9
050F8:  MOVF   FEF,W
050FA:  SUBWF  xA3,W
050FC:  BZ    517E
050FE:  MOVFF  5A0,FEA
05102:  MOVFF  59F,FE9
05106:  MOVFF  FEF,5A3
0510A:  MOVF   xA3,W
0510C:  SUBLW  40
0510E:  BC    5116
05110:  MOVF   xA3,W
05112:  SUBLW  5A
05114:  BC    5122
05116:  MOVF   xA3,W
05118:  SUBLW  60
0511A:  BC    51A8
0511C:  MOVF   xA3,W
0511E:  SUBLW  7A
05120:  BNC   51A8
05122:  MOVFF  5A2,FEA
05126:  MOVFF  5A1,FE9
0512A:  MOVFF  FEF,5A3
0512E:  MOVF   xA3,W
05130:  SUBLW  40
05132:  BC    513A
05134:  MOVF   xA3,W
05136:  SUBLW  5A
05138:  BC    5146
0513A:  MOVF   xA3,W
0513C:  SUBLW  60
0513E:  BC    51A8
05140:  MOVF   xA3,W
05142:  SUBLW  7A
05144:  BNC   51A8
05146:  MOVFF  5A0,FEA
0514A:  MOVFF  59F,FE9
0514E:  MOVFF  FEF,5A3
05152:  MOVFF  5A2,FEA
05156:  MOVFF  5A1,FE9
0515A:  MOVLW  20
0515C:  ADDWF  FEF,W
0515E:  SUBWF  xA3,W
05160:  BZ    517E
05162:  MOVFF  5A2,FEA
05166:  MOVFF  5A1,FE9
0516A:  MOVFF  FEF,5A3
0516E:  MOVFF  5A0,FEA
05172:  MOVFF  59F,FE9
05176:  MOVLW  20
05178:  ADDWF  FEF,W
0517A:  SUBWF  xA3,W
0517C:  BNZ   51A8
....................     s1++, s2++)
....................     if (*s1 == '\0')
0517E:  MOVFF  5A0,FEA
05182:  MOVFF  59F,FE9
05186:  MOVF   FEF,F
05188:  BNZ   5190
....................        return(0);
0518A:  MOVLW  00
0518C:  MOVWF  01
0518E:  BRA    51D2
05190:  MOVFF  5A0,03
05194:  MOVF   x9F,W
05196:  INCF   x9F,F
05198:  BTFSC  FD8.2
0519A:  INCF   xA0,F
0519C:  INCF   xA1,F
0519E:  BTFSC  FD8.2
051A0:  INCF   xA2,F
051A2:  MOVLB  0
051A4:  BRA    50E2
051A6:  MOVLB  5
....................  return((*s1 < *s2) ? -1: 1);
051A8:  MOVFF  5A0,03
051AC:  MOVFF  59F,FE9
051B0:  MOVFF  03,FEA
051B4:  MOVFF  FEF,5A3
051B8:  MOVFF  5A2,03
051BC:  MOVFF  5A1,FE9
051C0:  MOVFF  03,FEA
051C4:  MOVF   FEF,W
051C6:  SUBWF  xA3,W
051C8:  BC    51CE
051CA:  MOVLW  FF
051CC:  BRA    51D0
051CE:  MOVLW  01
051D0:  MOVWF  01
051D2:  MOVLB  0
051D4:  RETURN 0
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
014BA:  MOVLB  6
014BC:  CLRF   x45
....................    sign = 0;
014BE:  CLRF   x43
....................    base = 10;
014C0:  MOVLW  0A
014C2:  MOVWF  x44
....................    result = 0;
014C4:  CLRF   x42
.................... 
....................    if (!s)
014C6:  MOVF   x40,W
014C8:  IORWF  x41,W
014CA:  BNZ   14D2
....................       return 0;
014CC:  MOVLW  00
014CE:  MOVWF  01
014D0:  BRA    1648
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
014D2:  MOVF   x45,W
014D4:  INCF   x45,F
014D6:  ADDWF  x40,W
014D8:  MOVWF  FE9
014DA:  MOVLW  00
014DC:  ADDWFC x41,W
014DE:  MOVWF  FEA
014E0:  MOVFF  FEF,646
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
014E4:  MOVF   x46,W
014E6:  SUBLW  2D
014E8:  BNZ   1502
....................    {
....................       sign = 1;         // Set the sign to negative
014EA:  MOVLW  01
014EC:  MOVWF  x43
....................       c = s[index++];
014EE:  MOVF   x45,W
014F0:  INCF   x45,F
014F2:  ADDWF  x40,W
014F4:  MOVWF  FE9
014F6:  MOVLW  00
014F8:  ADDWFC x41,W
014FA:  MOVWF  FEA
014FC:  MOVFF  FEF,646
....................    }
01500:  BRA    151A
....................    else if (c == '+')
01502:  MOVF   x46,W
01504:  SUBLW  2B
01506:  BNZ   151A
....................    {
....................       c = s[index++];
01508:  MOVF   x45,W
0150A:  INCF   x45,F
0150C:  ADDWF  x40,W
0150E:  MOVWF  FE9
01510:  MOVLW  00
01512:  ADDWFC x41,W
01514:  MOVWF  FEA
01516:  MOVFF  FEF,646
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
0151A:  MOVF   x46,W
0151C:  SUBLW  2F
0151E:  BTFSC  FD8.0
01520:  BRA    1638
01522:  MOVF   x46,W
01524:  SUBLW  39
01526:  BTFSS  FD8.0
01528:  BRA    1638
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
0152A:  MOVF   x46,W
0152C:  SUBLW  30
0152E:  BNZ   156C
01530:  MOVF   x45,W
01532:  ADDWF  x40,W
01534:  MOVWF  FE9
01536:  MOVLW  00
01538:  ADDWFC x41,W
0153A:  MOVWF  FEA
0153C:  MOVF   FEF,W
0153E:  SUBLW  78
01540:  BZ    1554
01542:  MOVF   x45,W
01544:  ADDWF  x40,W
01546:  MOVWF  FE9
01548:  MOVLW  00
0154A:  ADDWFC x41,W
0154C:  MOVWF  FEA
0154E:  MOVF   FEF,W
01550:  SUBLW  58
01552:  BNZ   156C
....................       {
....................          base = 16;
01554:  MOVLW  10
01556:  MOVWF  x44
....................          index++;
01558:  INCF   x45,F
....................          c = s[index++];
0155A:  MOVF   x45,W
0155C:  INCF   x45,F
0155E:  ADDWF  x40,W
01560:  MOVWF  FE9
01562:  MOVLW  00
01564:  ADDWFC x41,W
01566:  MOVWF  FEA
01568:  MOVFF  FEF,646
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
0156C:  MOVF   x44,W
0156E:  SUBLW  0A
01570:  BNZ   15AA
....................       {
....................          while (c >= '0' && c <= '9')
01572:  MOVF   x46,W
01574:  SUBLW  2F
01576:  BC    15A8
01578:  MOVF   x46,W
0157A:  SUBLW  39
0157C:  BNC   15A8
....................          {
....................             result = 10*result + (c - '0');
0157E:  MOVLW  0A
01580:  MOVWF  x47
01582:  MOVFF  642,648
01586:  MOVLB  0
01588:  BRA    146A
0158A:  MOVLW  30
0158C:  MOVLB  6
0158E:  SUBWF  x46,W
01590:  ADDWF  01,W
01592:  MOVWF  x42
....................             c = s[index++];
01594:  MOVF   x45,W
01596:  INCF   x45,F
01598:  ADDWF  x40,W
0159A:  MOVWF  FE9
0159C:  MOVLW  00
0159E:  ADDWFC x41,W
015A0:  MOVWF  FEA
015A2:  MOVFF  FEF,646
015A6:  BRA    1572
....................          }
....................       }
015A8:  BRA    1638
....................       else if (base == 16)    // The number is a hexa number
015AA:  MOVF   x44,W
015AC:  SUBLW  10
015AE:  BNZ   1638
....................       {
....................          c = toupper(c);
015B0:  MOVF   x46,W
015B2:  SUBLW  60
015B4:  BC    15C2
015B6:  MOVF   x46,W
015B8:  SUBLW  7A
015BA:  BNC   15C2
015BC:  MOVF   x46,W
015BE:  ANDLW  DF
015C0:  BRA    15C4
015C2:  MOVF   x46,W
015C4:  MOVWF  x46
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
015C6:  MOVF   x46,W
015C8:  SUBLW  2F
015CA:  BC    15D2
015CC:  MOVF   x46,W
015CE:  SUBLW  39
015D0:  BC    15DE
015D2:  MOVF   x46,W
015D4:  SUBLW  40
015D6:  BC    1638
015D8:  MOVF   x46,W
015DA:  SUBLW  46
015DC:  BNC   1638
....................          {
....................             if (c >= '0' && c <= '9')
015DE:  MOVF   x46,W
015E0:  SUBLW  2F
015E2:  BC    15FC
015E4:  MOVF   x46,W
015E6:  SUBLW  39
015E8:  BNC   15FC
....................                result = (result << 4) + (c - '0');
015EA:  SWAPF  x42,W
015EC:  MOVWF  x47
015EE:  MOVLW  F0
015F0:  ANDWF  x47,F
015F2:  MOVLW  30
015F4:  SUBWF  x46,W
015F6:  ADDWF  x47,W
015F8:  MOVWF  x42
015FA:  BRA    160E
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
015FC:  SWAPF  x42,W
015FE:  MOVWF  x47
01600:  MOVLW  F0
01602:  ANDWF  x47,F
01604:  MOVLW  41
01606:  SUBWF  x46,W
01608:  ADDLW  0A
0160A:  ADDWF  x47,W
0160C:  MOVWF  x42
.................... 
....................             c = s[index++];
0160E:  MOVF   x45,W
01610:  INCF   x45,F
01612:  ADDWF  x40,W
01614:  MOVWF  FE9
01616:  MOVLW  00
01618:  ADDWFC x41,W
0161A:  MOVWF  FEA
0161C:  MOVFF  FEF,646
....................             c = toupper(c);
01620:  MOVF   x46,W
01622:  SUBLW  60
01624:  BC    1632
01626:  MOVF   x46,W
01628:  SUBLW  7A
0162A:  BNC   1632
0162C:  MOVF   x46,W
0162E:  ANDLW  DF
01630:  BRA    1634
01632:  MOVF   x46,W
01634:  MOVWF  x46
01636:  BRA    15C6
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
01638:  DECFSZ x43,W
0163A:  BRA    1644
0163C:  MOVF   x44,W
0163E:  SUBLW  0A
01640:  BNZ   1644
....................        result = -result;
01642:  NEGF   x42
.................... 
....................    return(result);
01644:  MOVFF  642,01
01648:  MOVLB  0
0164A:  RETURN 0
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
*
0262A:  MOVLB  6
0262C:  CLRF   xA9
0262E:  CLRF   xA8
02630:  CLRF   xA7
02632:  MOVLW  01
02634:  MOVWF  xA6
02636:  CLRF   xAB
02638:  CLRF   xAC
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
0263A:  BTFSS  xA2.7
0263C:  BRA    2670
....................          sign=1;        // Check for negative number
0263E:  MOVLW  01
02640:  MOVWF  xAB
....................          num*=-1;
02642:  MOVFF  6A2,6B1
02646:  MOVFF  6A1,6B0
0264A:  MOVFF  6A0,6AF
0264E:  MOVFF  69F,6AE
02652:  SETF   xB5
02654:  SETF   xB4
02656:  SETF   xB3
02658:  SETF   xB2
0265A:  MOVLB  0
0265C:  BRA    24E2
0265E:  MOVFF  03,6A2
02662:  MOVFF  02,6A1
02666:  MOVFF  01,6A0
0266A:  MOVFF  00,69F
0266E:  MOVLB  6
....................      }
.................... 
....................      while(temp>0) {
02670:  MOVF   xA6,F
02672:  BNZ   2680
02674:  MOVF   xA7,F
02676:  BNZ   2680
02678:  MOVF   xA8,F
0267A:  BNZ   2680
0267C:  MOVF   xA9,F
0267E:  BZ    2754
....................          temp=(num/base);
02680:  BCF    FD8.1
02682:  MOVFF  6A2,6B9
02686:  MOVFF  6A1,6B8
0268A:  MOVFF  6A0,6B7
0268E:  MOVFF  69F,6B6
02692:  CLRF   xBD
02694:  CLRF   xBC
02696:  CLRF   xBB
02698:  MOVFF  6A3,6BA
0269C:  MOVLB  0
0269E:  RCALL  2540
026A0:  MOVFF  03,6A9
026A4:  MOVFF  02,6A8
026A8:  MOVFF  01,6A7
026AC:  MOVFF  00,6A6
....................          s[cnt]=(num%base)+'0';    // Conversion
026B0:  MOVLB  6
026B2:  MOVF   xAC,W
026B4:  ADDWF  xA4,W
026B6:  MOVWF  01
026B8:  MOVLW  00
026BA:  ADDWFC xA5,W
026BC:  MOVWF  03
026BE:  MOVFF  01,6AE
026C2:  MOVWF  xAF
026C4:  MOVFF  FEA,6B1
026C8:  MOVFF  FE9,6B0
026CC:  BSF    FD8.1
026CE:  MOVLW  06
026D0:  MOVWF  FEA
026D2:  MOVLW  B2
026D4:  MOVWF  FE9
026D6:  MOVFF  6A2,6B9
026DA:  MOVFF  6A1,6B8
026DE:  MOVFF  6A0,6B7
026E2:  MOVFF  69F,6B6
026E6:  CLRF   xBD
026E8:  CLRF   xBC
026EA:  CLRF   xBB
026EC:  MOVFF  6A3,6BA
026F0:  MOVLB  0
026F2:  RCALL  2540
026F4:  MOVFF  6B1,FEA
026F8:  MOVFF  6B0,FE9
026FC:  MOVLW  30
026FE:  MOVLB  6
02700:  ADDWF  xB2,W
02702:  MOVWF  00
02704:  MOVLW  00
02706:  ADDWFC xB3,W
02708:  MOVLW  00
0270A:  ADDWFC xB4,W
0270C:  MOVLW  00
0270E:  ADDWFC xB5,W
02710:  MOVFF  6AF,FEA
02714:  MOVFF  6AE,FE9
02718:  MOVFF  00,FEF
.................... 
....................          if(s[cnt]>0x39)
0271C:  MOVF   xAC,W
0271E:  ADDWF  xA4,W
02720:  MOVWF  FE9
02722:  MOVLW  00
02724:  ADDWFC xA5,W
02726:  MOVWF  FEA
02728:  MOVF   FEF,W
0272A:  SUBLW  39
0272C:  BC    2740
....................             s[cnt]+=0x7;
0272E:  MOVF   xAC,W
02730:  ADDWF  xA4,W
02732:  MOVWF  FE9
02734:  MOVLW  00
02736:  ADDWFC xA5,W
02738:  MOVWF  FEA
0273A:  MOVLW  07
0273C:  ADDWF  FEF,W
0273E:  MOVWF  FEF
.................... 
....................          cnt++;
02740:  INCF   xAC,F
....................          num=temp;
02742:  MOVFF  6A9,6A2
02746:  MOVFF  6A8,6A1
0274A:  MOVFF  6A7,6A0
0274E:  MOVFF  6A6,69F
02752:  BRA    2670
....................      }
.................... 
....................      if(sign==1) {
02754:  DECFSZ xAB,W
02756:  BRA    276A
....................          s[cnt]=0x2D;      // Negative sign
02758:  MOVF   xAC,W
0275A:  ADDWF  xA4,W
0275C:  MOVWF  FE9
0275E:  MOVLW  00
02760:  ADDWFC xA5,W
02762:  MOVWF  FEA
02764:  MOVLW  2D
02766:  MOVWF  FEF
....................          cnt++;
02768:  INCF   xAC,F
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
0276A:  CLRF   xAA
0276C:  BCF    FD8.0
0276E:  RRCF   xAC,W
02770:  SUBWF  xAA,W
02772:  BC    27C8
.................... 
....................          c=s[i];
02774:  MOVF   xAA,W
02776:  ADDWF  xA4,W
02778:  MOVWF  FE9
0277A:  MOVLW  00
0277C:  ADDWFC xA5,W
0277E:  MOVWF  FEA
02780:  MOVFF  FEF,6AD
....................          s[i]=s[cnt-i-1];        // Reverse the number
02784:  MOVF   xAA,W
02786:  ADDWF  xA4,W
02788:  MOVWF  01
0278A:  MOVLW  00
0278C:  ADDWFC xA5,W
0278E:  MOVWF  03
02790:  MOVF   xAA,W
02792:  SUBWF  xAC,W
02794:  ADDLW  FF
02796:  ADDWF  xA4,W
02798:  MOVWF  FE9
0279A:  MOVLW  00
0279C:  ADDWFC xA5,W
0279E:  MOVWF  FEA
027A0:  MOVFF  FEF,6B0
027A4:  MOVFF  03,FEA
027A8:  MOVFF  01,FE9
027AC:  MOVFF  6B0,FEF
....................          s[cnt-i-1]=c;
027B0:  MOVF   xAA,W
027B2:  SUBWF  xAC,W
027B4:  ADDLW  FF
027B6:  ADDWF  xA4,W
027B8:  MOVWF  FE9
027BA:  MOVLW  00
027BC:  ADDWFC xA5,W
027BE:  MOVWF  FEA
027C0:  MOVFF  6AD,FEF
027C4:  INCF   xAA,F
027C6:  BRA    276C
....................      }
....................      s[cnt]='\0';     // End the string
027C8:  MOVF   xAC,W
027CA:  ADDWF  xA4,W
027CC:  MOVWF  FE9
027CE:  MOVLW  00
027D0:  ADDWFC xA5,W
027D2:  MOVWF  FEA
027D4:  CLRF   FEF
....................      return s;
027D6:  MOVFF  6A4,01
027DA:  MOVFF  6A5,02
027DE:  MOVLB  0
027E0:  GOTO   2896 (RETURN)
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
*
037C2:  MOVLB  6
037C4:  CLRF   xB4
037C6:  CLRF   xB3
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
037C8:  MOVLW  30
037CA:  MOVWF  xB6
037CC:  MOVLW  31
037CE:  MOVWF  xB7
037D0:  MOVLW  32
037D2:  MOVWF  xB8
037D4:  MOVLW  33
037D6:  MOVWF  xB9
037D8:  MOVLW  34
037DA:  MOVWF  xBA
037DC:  MOVLW  35
037DE:  MOVWF  xBB
037E0:  MOVLW  36
037E2:  MOVWF  xBC
037E4:  MOVLW  37
037E6:  MOVWF  xBD
037E8:  MOVLW  38
037EA:  MOVWF  xBE
037EC:  MOVLW  39
037EE:  MOVWF  xBF
037F0:  MOVLW  61
037F2:  MOVWF  xC0
037F4:  MOVLW  62
037F6:  MOVWF  xC1
037F8:  MOVLW  63
037FA:  MOVWF  xC2
037FC:  MOVLW  64
037FE:  MOVWF  xC3
03800:  MOVLW  65
03802:  MOVWF  xC4
03804:  MOVLW  66
03806:  MOVWF  xC5
03808:  MOVLW  67
0380A:  MOVWF  xC6
0380C:  MOVLW  68
0380E:  MOVWF  xC7
03810:  MOVLW  69
03812:  MOVWF  xC8
03814:  MOVLW  6A
03816:  MOVWF  xC9
03818:  MOVLW  6B
0381A:  MOVWF  xCA
0381C:  MOVLW  6C
0381E:  MOVWF  xCB
03820:  MOVLW  6D
03822:  MOVWF  xCC
03824:  MOVLW  6E
03826:  MOVWF  xCD
03828:  MOVLW  6F
0382A:  MOVWF  xCE
0382C:  MOVLW  70
0382E:  MOVWF  xCF
03830:  MOVLW  71
03832:  MOVWF  xD0
03834:  MOVLW  73
03836:  MOVWF  xD1
03838:  MOVLW  74
0383A:  MOVWF  xD2
0383C:  MOVLW  75
0383E:  MOVWF  xD3
03840:  MOVLW  76
03842:  MOVWF  xD4
03844:  MOVLW  77
03846:  MOVWF  xD5
03848:  MOVLW  78
0384A:  MOVWF  xD6
0384C:  MOVLW  79
0384E:  MOVWF  xD7
03850:  MOVLW  7A
03852:  MOVWF  xD8
03854:  CLRF   xD9
....................    for(sc=s;isspace(*sc);++sc);
03856:  MOVFF  6A9,6AE
0385A:  MOVFF  6A8,6AD
0385E:  MOVFF  6AE,FEA
03862:  MOVFF  6AD,FE9
03866:  MOVF   FEF,W
03868:  SUBLW  20
0386A:  BNZ   3874
0386C:  INCF   xAD,F
0386E:  BTFSC  FD8.2
03870:  INCF   xAE,F
03872:  BRA    385E
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
03874:  MOVFF  6AE,03
03878:  MOVFF  6AD,FE9
0387C:  MOVFF  03,FEA
03880:  MOVF   FEF,W
03882:  SUBLW  2D
03884:  BZ    3894
03886:  MOVFF  6AE,FEA
0388A:  MOVFF  6AD,FE9
0388E:  MOVF   FEF,W
03890:  SUBLW  2B
03892:  BNZ   38A6
03894:  MOVFF  6AE,FEA
03898:  MOVF   xAD,W
0389A:  INCF   xAD,F
0389C:  BTFSC  FD8.2
0389E:  INCF   xAE,F
038A0:  MOVWF  FE9
038A2:  MOVF   FEF,W
038A4:  BRA    38A8
038A6:  MOVLW  2B
038A8:  MOVWF  xB5
....................    if (base <0 || base ==1|| base >36) // invalid base
038AA:  BTFSC  xAC.7
038AC:  BRA    38BE
038AE:  DECFSZ xAC,W
038B0:  BRA    38B4
038B2:  BRA    38BE
038B4:  BTFSC  xAC.7
038B6:  BRA    38C2
038B8:  MOVF   xAC,W
038BA:  SUBLW  24
038BC:  BC    38C2
....................    goto StrtolGO;
038BE:  BRA    3AC0
038C0:  BRA    39BA
....................    else if (base)
038C2:  MOVF   xAC,F
038C4:  BZ    3952
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
038C6:  MOVF   xAC,W
038C8:  SUBLW  10
038CA:  BNZ   3906
038CC:  MOVFF  6AE,FEA
038D0:  MOVFF  6AD,FE9
038D4:  MOVF   FEF,W
038D6:  SUBLW  30
038D8:  BNZ   3906
038DA:  MOVLW  01
038DC:  ADDWF  xAD,W
038DE:  MOVWF  FE9
038E0:  MOVLW  00
038E2:  ADDWFC xAE,W
038E4:  MOVWF  FEA
038E6:  MOVF   FEF,W
038E8:  SUBLW  78
038EA:  BZ    38FE
038EC:  MOVLW  01
038EE:  ADDWF  xAD,W
038F0:  MOVWF  FE9
038F2:  MOVLW  00
038F4:  ADDWFC xAE,W
038F6:  MOVWF  FEA
038F8:  MOVF   FEF,W
038FA:  SUBLW  58
038FC:  BNZ   3906
....................          sc+=2;
038FE:  MOVLW  02
03900:  ADDWF  xAD,F
03902:  MOVLW  00
03904:  ADDWFC xAE,F
....................       if(base==8 && *sc =='0')
03906:  MOVF   xAC,W
03908:  SUBLW  08
0390A:  BNZ   3922
0390C:  MOVFF  6AE,FEA
03910:  MOVFF  6AD,FE9
03914:  MOVF   FEF,W
03916:  SUBLW  30
03918:  BNZ   3922
....................          sc+=1;
0391A:  MOVLW  01
0391C:  ADDWF  xAD,F
0391E:  MOVLW  00
03920:  ADDWFC xAE,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
03922:  MOVF   xAC,W
03924:  SUBLW  02
03926:  BNZ   3950
03928:  MOVFF  6AE,FEA
0392C:  MOVFF  6AD,FE9
03930:  MOVF   FEF,W
03932:  SUBLW  30
03934:  BNZ   3950
03936:  MOVLW  01
03938:  ADDWF  xAD,W
0393A:  MOVWF  FE9
0393C:  MOVLW  00
0393E:  ADDWFC xAE,W
03940:  MOVWF  FEA
03942:  MOVF   FEF,W
03944:  SUBLW  62
03946:  BNZ   3950
....................          sc+=2;
03948:  MOVLW  02
0394A:  ADDWF  xAD,F
0394C:  MOVLW  00
0394E:  ADDWFC xAE,F
.................... 
....................    }
03950:  BRA    39BA
....................    else if(*sc!='0') // base is 0, find base
03952:  MOVFF  6AE,FEA
03956:  MOVFF  6AD,FE9
0395A:  MOVF   FEF,W
0395C:  SUBLW  30
0395E:  BZ    3966
....................       base=10;
03960:  MOVLW  0A
03962:  MOVWF  xAC
03964:  BRA    39BA
....................    else if (sc[1]=='x' || sc[1]=='X')
03966:  MOVLW  01
03968:  ADDWF  xAD,W
0396A:  MOVWF  FE9
0396C:  MOVLW  00
0396E:  ADDWFC xAE,W
03970:  MOVWF  FEA
03972:  MOVF   FEF,W
03974:  SUBLW  78
03976:  BZ    398A
03978:  MOVLW  01
0397A:  ADDWF  xAD,W
0397C:  MOVWF  FE9
0397E:  MOVLW  00
03980:  ADDWFC xAE,W
03982:  MOVWF  FEA
03984:  MOVF   FEF,W
03986:  SUBLW  58
03988:  BNZ   3998
....................       base =16,sc+=2;
0398A:  MOVLW  10
0398C:  MOVWF  xAC
0398E:  MOVLW  02
03990:  ADDWF  xAD,F
03992:  MOVLW  00
03994:  ADDWFC xAE,F
03996:  BRA    39BA
....................    else if(sc[1]=='b')
03998:  MOVLW  01
0399A:  ADDWF  xAD,W
0399C:  MOVWF  FE9
0399E:  MOVLW  00
039A0:  ADDWFC xAE,W
039A2:  MOVWF  FEA
039A4:  MOVF   FEF,W
039A6:  SUBLW  62
039A8:  BNZ   39B6
....................       base=2,sc+=2;
039AA:  MOVLW  02
039AC:  MOVWF  xAC
039AE:  ADDWF  xAD,F
039B0:  MOVLW  00
039B2:  ADDWFC xAE,F
039B4:  BRA    39BA
....................    else
....................       base=8;
039B6:  MOVLW  08
039B8:  MOVWF  xAC
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
039BA:  MOVFF  6AE,6B0
039BE:  MOVFF  6AD,6AF
039C2:  MOVFF  6AE,FEA
039C6:  MOVFF  6AD,FE9
039CA:  MOVF   FEF,W
039CC:  SUBLW  30
039CE:  BNZ   39D8
039D0:  INCF   xAD,F
039D2:  BTFSC  FD8.2
039D4:  INCF   xAE,F
039D6:  BRA    39C2
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
039D8:  MOVFF  6AE,03
039DC:  MOVFF  6AD,FE9
039E0:  MOVFF  03,FEA
039E4:  MOVFF  FEF,6DA
039E8:  MOVF   xDA,W
039EA:  SUBLW  40
039EC:  BC    39FA
039EE:  MOVF   xDA,W
039F0:  SUBLW  5A
039F2:  BNC   39FA
039F4:  MOVF   xDA,W
039F6:  IORLW  20
039F8:  BRA    39FC
039FA:  MOVF   xDA,W
039FC:  MOVWF  xDA
039FE:  MOVLW  06
03A00:  MOVWF  xDC
03A02:  MOVLW  B6
03A04:  MOVWF  xDB
03A06:  MOVFF  6DA,6DD
03A0A:  CLRF   xDF
03A0C:  MOVFF  6AC,6DE
03A10:  BTFSC  xDE.7
03A12:  DECF   xDF,F
03A14:  MOVLB  0
03A16:  RCALL  3722
03A18:  MOVFF  02,6B2
03A1C:  MOVFF  01,6B1
....................    for(;sd!=0;)
03A20:  MOVLB  6
03A22:  MOVF   xB1,F
03A24:  BNZ   3A2A
03A26:  MOVF   xB2,F
03A28:  BZ    3AB4
....................    {
....................       x=x*base+(int16)(sd-digits);
03A2A:  CLRF   03
03A2C:  MOVF   xAC,W
03A2E:  MOVWF  00
03A30:  BTFSC  FE8.7
03A32:  DECF   03,F
03A34:  MOVWF  xDA
03A36:  MOVFF  03,6DB
03A3A:  MOVFF  6B4,6DD
03A3E:  MOVFF  6B3,6DC
03A42:  MOVFF  03,6DF
03A46:  MOVWF  xDE
03A48:  MOVLB  0
03A4A:  BRA    376C
03A4C:  MOVLW  B6
03A4E:  MOVLB  6
03A50:  SUBWF  xB1,W
03A52:  MOVWF  00
03A54:  MOVLW  06
03A56:  SUBWFB xB2,W
03A58:  MOVWF  03
03A5A:  MOVF   00,W
03A5C:  ADDWF  01,W
03A5E:  MOVWF  xB3
03A60:  MOVF   03,W
03A62:  ADDWFC 02,W
03A64:  MOVWF  xB4
....................       ++sc;
03A66:  INCF   xAD,F
03A68:  BTFSC  FD8.2
03A6A:  INCF   xAE,F
....................       sd=memchr(digits,tolower(*sc),base);
03A6C:  MOVFF  6AE,FEA
03A70:  MOVFF  6AD,FE9
03A74:  MOVFF  FEF,6DA
03A78:  MOVF   xDA,W
03A7A:  SUBLW  40
03A7C:  BC    3A8A
03A7E:  MOVF   xDA,W
03A80:  SUBLW  5A
03A82:  BNC   3A8A
03A84:  MOVF   xDA,W
03A86:  IORLW  20
03A88:  BRA    3A8C
03A8A:  MOVF   xDA,W
03A8C:  MOVWF  xDA
03A8E:  MOVLW  06
03A90:  MOVWF  xDC
03A92:  MOVLW  B6
03A94:  MOVWF  xDB
03A96:  MOVFF  6DA,6DD
03A9A:  CLRF   xDF
03A9C:  MOVFF  6AC,6DE
03AA0:  BTFSC  xDE.7
03AA2:  DECF   xDF,F
03AA4:  MOVLB  0
03AA6:  RCALL  3722
03AA8:  MOVFF  02,6B2
03AAC:  MOVFF  01,6B1
03AB0:  BRA    3A20
03AB2:  MOVLB  6
....................    }
....................    if(s1==sc)
03AB4:  MOVF   xAD,W
03AB6:  SUBWF  xAF,W
03AB8:  BNZ   3AE2
03ABA:  MOVF   xAE,W
03ABC:  SUBWF  xB0,W
03ABE:  BNZ   3AE2
....................    {
....................    StrtolGO:
....................       if (endptr)
03AC0:  MOVLB  6
03AC2:  MOVF   xAA,W
03AC4:  IORWF  xAB,W
03AC6:  BZ    3ADA
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
03AC8:  MOVFF  6AB,FEA
03ACC:  MOVFF  6AA,FE9
03AD0:  MOVFF  6A9,FEC
03AD4:  MOVF   FED,F
03AD6:  MOVFF  6A8,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
03ADA:  MOVLW  00
03ADC:  MOVWF  01
03ADE:  MOVWF  02
03AE0:  BRA    3B12
....................    }
....................    if(sign=='-')
03AE2:  MOVF   xB5,W
03AE4:  SUBLW  2D
03AE6:  BNZ   3AF2
....................       x  =-x;
03AE8:  COMF   xB3,F
03AEA:  COMF   xB4,F
03AEC:  INCF   xB3,F
03AEE:  BTFSC  FD8.2
03AF0:  INCF   xB4,F
....................    if (endptr)
03AF2:  MOVF   xAA,W
03AF4:  IORWF  xAB,W
03AF6:  BZ    3B0A
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
03AF8:  MOVFF  6AB,FEA
03AFC:  MOVFF  6AA,FE9
03B00:  MOVFF  6AE,FEC
03B04:  MOVF   FED,F
03B06:  MOVFF  6AD,FEF
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
03B0A:  MOVFF  6B3,01
03B0E:  MOVFF  6B4,02
03B12:  MOVLB  0
03B14:  GOTO   445A (RETURN)
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... /// TODO
.................... 
.................... /// intmax_t uintmax_t
.................... 
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX
.................... 
.................... /// INTMAX_C(value) UINTMAX_C(value)
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <arQ1010/globalVariables.h>
.................... #define BUFFER_SIZE      255
.................... 
.................... //reusable variables
.................... //int timeOut=0;
.................... //int try=0;
.................... char TOKEN[10]={};
.................... 
.................... //char funcReturnVar[BUFFER_SIZE]={}; //Global string variable used for functions returning string values 
.................... 
.................... //Variables for BTD200
.................... //Variables for USB Serial Interrupt RDA2
.................... char INTERRUPTUSB_Rxd[20]={};
.................... int1 InterruptUSB_Flag=0;
.................... int InterruptUSB_Counter=0;
.................... 
.................... //Variables for USB Serial Interrupt RDA2
.................... char InterruptGSM_Rxd[BUFFER_SIZE]={};
.................... int1 InterruptGSM_Flag=0;
.................... int InterruptGSM_Counter=0;
.................... int READ_CNTR = 0;
.................... 
.................... //Variables for gsm.c
.................... int NETWORK=0; //Registered GSM Network
.................... char SERVERNUMBER[15]={};
.................... char MYNUMBER1[15]={};
.................... char MYNUMBER2[15]={};
.................... char SMS_RCV[BUFFER_SIZE] = {};
.................... //char SMS_TOBE_SENT[BUFFER_SIZE]={};
.................... int1 EXT_FLAG=0;
.................... char GSM_RESPONSE[BUFFER_SIZE]={};
.................... char DESIRED_RESPONSE[17]={};
.................... //char BTDmessage[255] = {};
.................... 
.................... 
.................... 
.................... 
.................... //char cx[90] = {0xff, 0xff, 0x57, 0x00, 0x20, 0x00, 0x04, 0x26, 0x01, 0x04, 0x28, 0x0f, 0x01, 0x04, 0x16, 0x84, 0x00, 0x81, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x0c, 0xaf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0xde, 0x4d, 0x89, 0x3c}; 
.................... //char cx[90] = {0xff, 0xff, 0x57, 0x00, 0x20, 0x00, 0x04, 0x26, 0x01, 0x04, 0x28, 0x0f, 0x01, 0x04, 0x16, 0x84, 0x00, 0x81, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0xfe, 0x00, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0x4d, 0x01, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0x68, 0x01, 0x02, 0x28, 0x0f, 0x01, 0x04, 0x16, 0xaf, 0x00, 0xed, 0x08, 0xdd, 0x00, 0x01, 0x01, 0x00, 0xde, 0x4d, 0x89, 0x3c};
.................... //char cx[90] = {};
.................... 
.................... int SEC=0;
.................... int MIN=0;
.................... int HOUR=0;
.................... int DAY=0;
.................... int MONTH=0;
.................... int YEAR=0;
.................... int YEAR_PREV=0;
.................... //char globalDT[20]={};
.................... 
.................... //char cx[100] = {};
.................... char strDateTime[20]={};
.................... char biralBT[20]={};
.................... char BTDLaLo[150]={};
.................... char distDir[10] = {};
.................... //char DTindex[5] = {};
.................... Char flashCount[10] = {};
.................... char strBTD_con [10] = {};
.................... char strBTD_info [20] = {};
.................... char btdCode[20] = {};
.................... //int BTDhealth[2] = {};
.................... 
.................... //long int reCounter = 0;
.................... //char btdRestart[2] = {};
.................... 
.................... 
.................... //char message[255]={};
.................... int powerGSMready = 0;
.................... 
.................... int SENDING_TIME=15;
.................... int1 SAMPLINGFLAG=FALSE;
.................... int1 CHECKMINUTE=0;
.................... int HOUROLD=0;
.................... int1 RESETCPU=0;
.................... 
.................... int1 TESTFLAG=0;
.................... int1 SYNCFLAG=0;
.................... int1 RESETFLAG=0;
.................... //!
.................... //!//int const CONNECT = 0xE0;
.................... //!int const DATETIME = 0xE1;
.................... //!int const SENSORTEST = 0xE2;
.................... //!int const FIRMWAREMODE = 0xE3;
.................... //!int const EXITCONFIG = 0xE4;
.................... //!int const FIRMWARECHAR = 0xE5;
.................... //!int const GOOD_DATA = 0xE6;
.................... //!int const BAD_DATA = 0xE7;
.................... //!int const SENSORINI = 0xE8;
.................... //!int const CONFIGSET = 0xEA;
.................... //!int const REDOWNLOADFIRMWARE = 0xEB;
.................... //!int const FIRMWAREFLASHDOWNLOAD = 0xEC;
.................... //!int const GSMTEST = 0xED;
.................... //!int const SATELLITE_TEST = 0xEE;
.................... 
.................... 
.................... 
.................... #include <arQ1010/pinDefinitions.c>
.................... 
.................... //**** RS485 *****//
.................... #define  TX2_RS485        PIN_E4
.................... #define  RX2_RS485        PIN_E7
.................... #define  EN_DE_RS485        PIN_E5
.................... #define  EN_RE_RS485        PIN_E6
.................... 
.................... //**** EXPOSED PIN FOR RS232
.................... #define  EN_UART        PIN_D1
.................... 
.................... //**** I2C PINS 
.................... #define  EN_I2C   PIN_D4
.................... #define  SDA_I2C  PIN_D5
.................... #define  SCL_I2C  PIN_D6
.................... 
.................... //**** SWITCH TO SELECT WHAT BATTERY TO USE
.................... #define  ENBA     PIN_J2
.................... #define  ENBB     PIN_J3
.................... 
.................... //**** GSM
.................... #define  RING_OUT    PIN_B1
.................... #define  RTS      PIN_A6
.................... #define  pin_CTS      PIN_A7
.................... #define  IGT      PIN_C2
.................... 
.................... //**** HARDWARE UART
.................... #define  RX_INT      PIN_C6
.................... #define  TX_INT      PIN_C5
.................... 
.................... #define  RX_USB       PIN_G2
.................... #define  TX_USB       PIN_G1
.................... 
.................... //**** RS232
.................... #define  TX_B        PIN_G4
.................... #define  RX_B        PIN_G3
.................... 
.................... //**** DIGITAL OUT
.................... #define  pin_OUT1        PIN_A3
.................... #define  OUT2        PIN_A2
.................... #define  OUT3        PIN_A1
.................... 
.................... //**** DIGITAL INPUTS
.................... #define  INTRUP4     PIN_D7
.................... #define  INTRUP1     PIN_B0
.................... #define  INTRUP2     PIN_B2
.................... #define  INTRUP3     PIN_B3
.................... 
.................... //**** SPI
.................... #define  SDO1        PIN_C5
.................... #define  SDA1        PIN_C4
.................... #define  SCK1        PIN_C3
.................... #define  EN1         PIN_F4
.................... #define  CS1         PIN_F5
.................... 
.................... //#define THUNDER_CS PIN_F4
.................... //#define SCP_CSB PIN_F4
.................... 
.................... //**** FLASH CHIP ENABLE
.................... #define  CS          PIN_E0
.................... 
.................... //**** USB PIN CHECK
.................... #define  pin_USB_STAT    PIN_G0
.................... 
.................... //**** DUAL COLOR LED
.................... #define  LED_STAT_A     PIN_E1
.................... #define  LED_STAT_B     PIN_H3
.................... 
.................... //**** SHT11
.................... #define  SHT_DATA_PIN       PIN_H2
.................... #define  SHT_CLK_PIN         PIN_B4
.................... 
.................... 
.................... //**** RESET
.................... #define  MCLR        PIN_G5
.................... 
.................... //**** ADC
.................... #define  VBAT_ADC       PIN_F7  //channel 5 3.3V MONITORING
.................... #define  IBOOST_ADC     PIN_H4  //channel 12 BOOST MONITORING
.................... #define  VBOOST_ADC     PIN_H5  //channel 13 BOOST MONITORING
.................... #define  IBOOST2_ADC    PIN_H7  //channel 15 BOOST MONITORING
.................... #define  VBOOST2_ADC    PIN_H6  //channel 14 BOOST MONITORING
.................... #define  VEXT1_ADC      PIN_F3  //channel 8 EXTERNAL ADC1
.................... #define  VEXT2_ADC      PIN_F2  //channel 7 EXTERNAL ADC2
.................... #define  INA_ADC        PIN_A5  //channel 4 INPUT VOLTAGE MONITORING 1
.................... #define  INB_ADC        PIN_A0  //channel 0 INPUT VOLTAGE MONITORING 2
.................... 
.................... #define  channel_VBAT_ADC       5  //channel 5 3.3V MONITORING
.................... #define  channel_IBOOST_ADC     12 //channel 12 BOOST MONITORING
.................... #define  channel_VBOOST_ADC     13  //channel 13 BOOST MONITORING
.................... #define  channel_IBOOST2_ADC    15  //channel 15 BOOST MONITORING
.................... #define  channel_VBOOST2_ADC    14  //channel 14 BOOST MONITORING
.................... #define  channel_VEXT1_ADC      8  //channel 8 EXTERNAL ADC1
.................... #define  channel_VEXT2_ADC      7  //channel 7 EXTERNAL ADC2
.................... #define  channel_INA_ADC        4  //channel 4 INPUT VOLTAGE MONITORING 1
.................... #define  channel_INB_ADC        0  //channel 0 INPUT VOLTAGE MONITORING 2
.................... 
.................... 
.................... //**** POWER BOARD PINS
.................... #define  pin_BOOST1          PIN_D0  //BOOST SWITCH
.................... #define  pin_BOOST2          PIN_F1  //BOOST SWITCH
.................... #define  pin_CHRG_STAT1     PIN_J7
.................... #define  pin_FAULT_STAT1    PIN_J6
.................... #define  pin_CHRG_STAT2     PIN_J4
.................... #define  pin_FAULT_STAT2    PIN_J5
.................... 
.................... 
.................... 
.................... #include <arQ1010/interruptSerial2_USB.c>
.................... #use rs232(baud=57600, xmit=TX_USB, rcv=RX_USB, stream=USB)
.................... 
.................... #int_rda2 //RS232 receive data available in buffer 2
.................... 
.................... void rda2_isr(void){
....................    InterruptUSB_Flag = 1;
*
002C4:  BSF    40.0
....................    InterruptUSB_Rxd[InterruptUSB_Counter++]=fgetc(USB);
002C6:  MOVF   41,W
002C8:  INCF   41,F
002CA:  CLRF   03
002CC:  ADDLW  2C
002CE:  MOVWF  FE9
002D0:  MOVLW  00
002D2:  ADDWFC 03,W
002D4:  MOVWF  FEA
002D6:  BTFSS  FA4.5
002D8:  BRA    02D6
002DA:  MOVLB  F
002DC:  MOVFF  F1D,FEF
....................    InterruptUSB_Rxd[InterruptUSB_Counter]=0x00; //'\0' or 'NULL' terminating character 
002E0:  CLRF   03
002E2:  MOVF   41,W
002E4:  ADDLW  2C
002E6:  MOVWF  FE9
002E8:  MOVLW  00
002EA:  ADDWFC 03,W
002EC:  MOVWF  FEA
002EE:  CLRF   FEF
002F0:  BCF    FA4.5
002F2:  MOVLB  0
002F4:  GOTO   0098
.................... }
.................... 
.................... void clear_InterruptUSB(){  
....................    //InterruptUSB_Rxd[0]='\0';
....................    strcpy(InterruptUSB_Rxd,"");
*
01BF2:  CLRF   FEA
01BF4:  MOVLW  2C
01BF6:  MOVWF  FE9
01BF8:  MOVLW  00
01BFA:  CALL   00EE
01BFE:  TBLRD*-
01C00:  TBLRD*+
01C02:  MOVF   FF5,W
01C04:  MOVWF  FEE
01C06:  IORLW  00
01C08:  BNZ   1C00
....................    InterruptUSB_Flag=0;
01C0A:  BCF    40.0
....................    InterruptUSB_Counter=0;
01C0C:  CLRF   41
01C0E:  RETURN 0
.................... }
.................... 
.................... 
.................... void getDataFromUSB(){
....................    clear_InterruptUSB();
*
051D6:  CALL   1BF2
....................    while(!InterruptUSB_Flag);
051DA:  BTFSS  40.0
051DC:  BRA    51DA
....................    delay_ms(50); //needed to stabilize USB input
051DE:  MOVLW  32
051E0:  MOVLB  6
051E2:  MOVWF  x6E
051E4:  MOVLB  0
051E6:  CALL   0F16
051EA:  RETURN 0
.................... }
.................... 
.................... 
.................... #include <arQ1010/InterruptSerial1_GSM.c>
.................... //#use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=GSM)
.................... 
.................... #int_rda
.................... void rda_isr(void)
.................... {
....................    InterruptGSM_Flag = 1;
*
002F8:  BSF    40.1
....................    InterruptGSM_Rxd[InterruptGSM_Counter++]=fgetc(GSM);
002FA:  MOVLB  1
002FC:  MOVF   x41,W
002FE:  INCF   x41,F
00300:  CLRF   03
00302:  ADDLW  42
00304:  MOVWF  FE9
00306:  MOVLW  00
00308:  ADDWFC 03,W
0030A:  MOVWF  FEA
0030C:  BTFSS  F9E.5
0030E:  BRA    030C
00310:  MOVFF  FAE,FEF
....................    //InterruptGSM_Rxd[InterruptGSM_Counter]=0x00;
00314:  BCF    F9E.5
00316:  MOVLB  0
00318:  GOTO   0098
.................... }
.................... 
.................... void clear_InterruptGSM()
*
01E64:  MOVLB  6
01E66:  CLRF   x6B
.................... {
....................    int i=0;
....................    
....................    for (i=0;i<BUFFER_SIZE;i++)
01E68:  CLRF   x6B
01E6A:  INCFSZ x6B,W
01E6C:  BRA    1E70
01E6E:  BRA    1E94
....................    {
....................       InterruptGSM_Rxd[i]=NULL;
01E70:  CLRF   03
01E72:  MOVF   x6B,W
01E74:  ADDLW  42
01E76:  MOVWF  FE9
01E78:  MOVLW  00
01E7A:  ADDWFC 03,W
01E7C:  MOVWF  FEA
01E7E:  CLRF   FEF
....................       GSM_RESPONSE[i]=NULL;
01E80:  CLRF   03
01E82:  MOVF   x6B,W
01E84:  ADDLW  70
01E86:  MOVWF  FE9
01E88:  MOVLW  02
01E8A:  ADDWFC 03,W
01E8C:  MOVWF  FEA
01E8E:  CLRF   FEF
01E90:  INCF   x6B,F
01E92:  BRA    1E6A
....................    }
.................... 
....................    InterruptGSM_Counter=0;
01E94:  MOVLB  1
01E96:  CLRF   x41
....................    READ_CNTR=0;
01E98:  CLRF   x42
....................    InterruptGSM_Flag=0;
01E9A:  BCF    40.1
01E9C:  MOVLB  0
01E9E:  RETURN 0
.................... }
.................... 
.................... void getDataFromGSM()
.................... {
....................    clear_InterruptGSM();
....................    while(!InterruptGSM_Flag);
....................    delay_ms(50); //needed to stabilize USB input
.................... }
.................... 
.................... //!void clear_InterruptGSM()
.................... //!{  
.................... //!   strcpy(InterruptGSM_Rxd,"");
.................... //!   InterruptGSM_Flag=0;
.................... //!   InterruptGSM_Counter=0;
.................... //!   READ_CNTR=0;
.................... //!
.................... //!}
.................... 
.................... 
.................... char *GetResponse(void)
*
01EC8:  MOVLB  6
01ECA:  CLRF   x6B
01ECC:  CLRF   x6C
01ECE:  CLRF   x6D
.................... {
....................    int tempCntr = 0;
....................    int i=0, len=0;
....................    
....................    len = strlen(DESIRED_RESPONSE);
01ED0:  MOVLW  03
01ED2:  MOVWF  xB1
01ED4:  MOVLW  6F
01ED6:  MOVWF  xB0
01ED8:  MOVLB  0
01EDA:  CALL   137E
01EDE:  MOVFF  01,66D
....................    while(((InterruptGSM_Counter - READ_CNTR) < len) && ++tempCntr < 30) delay_ms(100);
01EE2:  MOVLB  1
01EE4:  MOVF   x42,W
01EE6:  SUBWF  x41,W
01EE8:  MOVLB  6
01EEA:  SUBWF  x6D,W
01EEC:  BZ    1F06
01EEE:  BNC   1F06
01EF0:  INCF   x6B,F
01EF2:  MOVF   x6B,W
01EF4:  SUBLW  1D
01EF6:  BNC   1F06
01EF8:  MOVLW  64
01EFA:  MOVWF  x6E
01EFC:  MOVLB  0
01EFE:  CALL   0F16
01F02:  BRA    1EE2
01F04:  MOVLB  6
.................... 
....................    len = READ_CNTR;
01F06:  MOVFF  142,66D
....................    if(tempCntr < 30)
01F0A:  MOVF   x6B,W
01F0C:  SUBLW  1D
01F0E:  BTFSS  FD8.0
01F10:  BRA    2096
....................    {
....................       tempCntr = 0;
01F12:  CLRF   x6B
....................       do
....................       {
....................          do
....................          {                                                                                      
....................             for(; (READ_CNTR != InterruptGSM_Counter) && (InterruptGSM_Rxd[READ_CNTR] != DESIRED_RESPONSE[0]); READ_CNTR=(READ_CNTR+1) % BUFFER_SIZE);
01F14:  MOVLB  1
01F16:  MOVF   x41,W
01F18:  SUBWF  x42,W
01F1A:  BZ    1F62
01F1C:  CLRF   03
01F1E:  MOVF   x42,W
01F20:  ADDLW  42
01F22:  MOVWF  FE9
01F24:  MOVLW  00
01F26:  ADDWFC 03,W
01F28:  MOVWF  FEA
01F2A:  MOVLB  3
01F2C:  MOVF   x6F,W
01F2E:  SUBWF  FEF,W
01F30:  BTFSS  FD8.2
01F32:  BRA    1F38
01F34:  MOVLB  1
01F36:  BRA    1F62
01F38:  MOVLW  01
01F3A:  MOVLB  1
01F3C:  ADDWF  x42,W
01F3E:  MOVLB  6
01F40:  MOVWF  x6F
01F42:  CLRF   1B
01F44:  BTFSC  FF2.7
01F46:  BSF    1B.7
01F48:  BCF    FF2.7
01F4A:  MOVWF  xF5
01F4C:  SETF   xF6
01F4E:  MOVLB  0
01F50:  CALL   0642
01F54:  BTFSC  1B.7
01F56:  BSF    FF2.7
01F58:  MOVFF  00,142
01F5C:  MOVLB  6
01F5E:  BRA    1F14
01F60:  MOVLB  1
....................             for(i = 0; (READ_CNTR != InterruptGSM_Counter) && (InterruptGSM_Rxd[READ_CNTR] == DESIRED_RESPONSE[i]) && (DESIRED_RESPONSE[i] != 0); i++, READ_CNTR=(READ_CNTR+1) % BUFFER_SIZE);
01F62:  MOVLB  6
01F64:  CLRF   x6C
01F66:  MOVLB  1
01F68:  MOVF   x41,W
01F6A:  SUBWF  x42,W
01F6C:  BZ    1FE2
01F6E:  CLRF   03
01F70:  MOVF   x42,W
01F72:  ADDLW  42
01F74:  MOVWF  FE9
01F76:  MOVLW  00
01F78:  ADDWFC 03,W
01F7A:  MOVWF  FEA
01F7C:  MOVFF  FEF,66E
01F80:  CLRF   03
01F82:  MOVLB  6
01F84:  MOVF   x6C,W
01F86:  ADDLW  6F
01F88:  MOVWF  FE9
01F8A:  MOVLW  03
01F8C:  ADDWFC 03,W
01F8E:  MOVWF  FEA
01F90:  MOVF   FEF,W
01F92:  SUBWF  x6E,W
01F94:  BTFSC  FD8.2
01F96:  BRA    1F9C
01F98:  MOVLB  1
01F9A:  BRA    1FE2
01F9C:  CLRF   03
01F9E:  MOVF   x6C,W
01FA0:  ADDLW  6F
01FA2:  MOVWF  FE9
01FA4:  MOVLW  03
01FA6:  ADDWFC 03,W
01FA8:  MOVWF  FEA
01FAA:  MOVF   FEF,F
01FAC:  BTFSS  FD8.2
01FAE:  BRA    1FB4
01FB0:  MOVLB  1
01FB2:  BRA    1FE2
01FB4:  MOVF   x6C,W
01FB6:  INCF   x6C,F
01FB8:  MOVLW  01
01FBA:  MOVLB  1
01FBC:  ADDWF  x42,W
01FBE:  MOVLB  6
01FC0:  MOVWF  x6F
01FC2:  CLRF   1B
01FC4:  BTFSC  FF2.7
01FC6:  BSF    1B.7
01FC8:  BCF    FF2.7
01FCA:  MOVWF  xF5
01FCC:  SETF   xF6
01FCE:  MOVLB  0
01FD0:  CALL   0642
01FD4:  BTFSC  1B.7
01FD6:  BSF    FF2.7
01FD8:  MOVFF  00,142
01FDC:  MOVLB  6
01FDE:  BRA    1F66
01FE0:  MOVLB  1
....................             if(DESIRED_RESPONSE[i] == 0)
01FE2:  CLRF   03
01FE4:  MOVLB  6
01FE6:  MOVF   x6C,W
01FE8:  ADDLW  6F
01FEA:  MOVWF  FE9
01FEC:  MOVLW  03
01FEE:  ADDWFC 03,W
01FF0:  MOVWF  FEA
01FF2:  MOVF   FEF,F
01FF4:  BNZ   205E
....................             {
....................                // TODO: insert delay if necessary
....................                InterruptGSM_Rxd[InterruptGSM_Counter] = 0; // terminate string
01FF6:  CLRF   03
01FF8:  MOVLB  1
01FFA:  MOVF   x41,W
01FFC:  ADDLW  42
01FFE:  MOVWF  FE9
02000:  MOVLW  00
02002:  ADDWFC 03,W
02004:  MOVWF  FEA
02006:  CLRF   FEF
....................                len = (InterruptGSM_Counter - READ_CNTR);
02008:  MOVF   x42,W
0200A:  SUBWF  x41,W
0200C:  MOVLB  6
0200E:  MOVWF  x6D
....................                for(i = 0; i <= len; i++)
02010:  CLRF   x6C
02012:  MOVF   x6C,W
02014:  SUBWF  x6D,W
02016:  BNC   2050
....................                {
....................                   GSM_RESPONSE[i] = InterruptGSM_Rxd[READ_CNTR + i];
02018:  CLRF   03
0201A:  MOVF   x6C,W
0201C:  ADDLW  70
0201E:  MOVWF  01
02020:  MOVLW  02
02022:  ADDWFC 03,F
02024:  MOVFF  03,66F
02028:  MOVF   x6C,W
0202A:  MOVLB  1
0202C:  ADDWF  x42,W
0202E:  CLRF   03
02030:  ADDLW  42
02032:  MOVWF  FE9
02034:  MOVLW  00
02036:  ADDWFC 03,W
02038:  MOVWF  FEA
0203A:  MOVFF  FEF,670
0203E:  MOVLB  6
02040:  MOVFF  66F,FEA
02044:  MOVFF  01,FE9
02048:  MOVFF  670,FEF
0204C:  INCF   x6C,F
0204E:  BRA    2012
....................                   //fprintf(USB,"%c",GSM_RESPONSE[i]);
....................                }
....................                READ_CNTR = InterruptGSM_Counter;
02050:  MOVFF  141,142
....................                return &GSM_RESPONSE[0];
02054:  MOVLW  70
02056:  MOVWF  01
02058:  MOVLW  02
0205A:  MOVWF  02
0205C:  BRA    20A0
....................                
....................             }
....................          } while((DESIRED_RESPONSE[i] != 0) && (READ_CNTR != InterruptGSM_Counter));
0205E:  CLRF   03
02060:  MOVF   x6C,W
02062:  ADDLW  6F
02064:  MOVWF  FE9
02066:  MOVLW  03
02068:  ADDWFC 03,W
0206A:  MOVWF  FEA
0206C:  MOVF   FEF,F
0206E:  BZ    207C
02070:  MOVLB  1
02072:  MOVF   x41,W
02074:  SUBWF  x42,W
02076:  BTFSS  FD8.2
02078:  BRA    1F16
0207A:  MOVLB  6
....................          delay_ms(100);
0207C:  MOVLW  64
0207E:  MOVWF  x6E
02080:  MOVLB  0
02082:  CALL   0F16
....................          READ_CNTR = len;
02086:  MOVFF  66D,142
....................       } while(++tempCntr < 10);
0208A:  MOVLB  6
0208C:  INCF   x6B,F
0208E:  MOVF   x6B,W
02090:  SUBLW  09
02092:  BTFSC  FD8.0
02094:  BRA    1F14
....................    }
.................... 
....................    READ_CNTR = InterruptGSM_Counter;
02096:  MOVFF  141,142
.................... 
.................... //    TODO: for debugging purposes, to be removed
.................... //   fprintf(PC, "\r\nMessage Received:");
.................... //   for(; len != InterruptGSM_Cunter; len++)
.................... //   {
.................... //      fprintf(PC, "%c", RXD_DATA[len]);
.................... //   }
.................... //   fprintf(PC, "READ_CNTR=%i\n", read_cntr);
.................... //   fprintf(PC, "InterruptGSM_Counter=%i\n", write_cntr);
....................    return NULL; // no match found
0209A:  MOVLW  00
0209C:  MOVWF  01
0209E:  MOVWF  02
020A0:  MOVLB  0
020A2:  GOTO   20DA (RETURN)
....................  }
.................... 
.................... 
.................... #include <arQ1010/interruptExt1_GSM.c>
.................... 
.................... #int_ext1
.................... void ext_isr1(void)
.................... {
....................    EXT_FLAG=1;
*
0031C:  BSF    40.2
....................    strcpy(SMS_RCV,InterruptGSM_Rxd);
0031E:  MOVLW  01
00320:  MOVWF  FEA
00322:  MOVLW  71
00324:  MOVWF  FE9
00326:  CLRF   FE2
00328:  MOVLW  42
0032A:  MOVWF  FE1
0032C:  MOVF   FE7,F
0032E:  MOVFF  FE6,FEE
00332:  BNZ   032C
.................... }
.................... 
00334:  BCF    FF0.0
00336:  GOTO   0098
.................... #include <arQ1010/interruptExt2_IN2.c>
.................... int1 InterruptInput2_Flag = 0;
.................... 
.................... #int_ext2 //when interrupt is enables on the main code the code is redirected on this include file
.................... void ext_isr2(void)
.................... {//if (input(PIN_B0))
.................... //fprintf(USB, "INTEEERRRRRUPPTTT"); 
....................    {
....................      InterruptInput2_Flag=1;
0033A:  MOVLB  4
0033C:  BSF    x8E.1
....................      //fprintf(USB, "Interrupt!\n");
....................    }
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/dualColorLED.c>
.................... #define LED_OFF 0
.................... #define LED_GREEN 1
0033E:  BCF    FF0.1
00340:  MOVLB  0
00342:  GOTO   0098
.................... #define LED_RED 2
.................... 
.................... void ledConfig(int mode)
.................... {
....................    switch (mode) {
*
050B4:  MOVLB  5
050B6:  MOVF   xA0,W
050B8:  XORLW  02
050BA:  MOVLB  0
050BC:  BZ    50C4
050BE:  XORLW  03
050C0:  BZ    50CE
050C2:  BRA    50D8
....................       case LED_RED:
....................          output_high(LED_STAT_A);
050C4:  BCF    F96.1
050C6:  BSF    F8D.1
....................          output_low(LED_STAT_B);
050C8:  BCF    F99.3
050CA:  BCF    F90.3
....................          break;
050CC:  BRA    50E0
....................       case LED_GREEN:
....................          output_low(LED_STAT_A);
050CE:  BCF    F96.1
050D0:  BCF    F8D.1
....................          output_high(LED_STAT_B);
050D2:  BCF    F99.3
050D4:  BSF    F90.3
....................          //output_low(LED_STAT_B);
....................          break;
050D6:  BRA    50E0
....................       default:
....................          output_low(LED_STAT_A);
050D8:  BCF    F96.1
050DA:  BCF    F8D.1
....................          output_low(LED_STAT_B);
050DC:  BCF    F99.3
050DE:  BCF    F90.3
....................          break;
....................    }
050E0:  RETURN 0
.................... }
.................... 
.................... void ledToggle(int1 color)
.................... {
....................    static int1 toggle=0;
....................    if (toggle==0)
*
0568C:  MOVLB  4
0568E:  BTFSC  x8E.2
05690:  BRA    56BA
....................    {
....................       if (color == LED_GREEN)
05692:  MOVLB  5
05694:  DECFSZ x9F,W
05696:  BRA    56A4
....................          ledConfig(LED_GREEN);
05698:  MOVLW  01
0569A:  MOVWF  xA0
0569C:  MOVLB  0
0569E:  RCALL  50B4
056A0:  BRA    56B2
056A2:  MOVLB  5
....................       else if (color == LED_RED)
056A4:  MOVF   x9F,W
056A6:  SUBLW  02
056A8:  BNZ   56B4
....................          ledConfig(LED_RED);
056AA:  MOVLW  02
056AC:  MOVWF  xA0
056AE:  MOVLB  0
056B0:  RCALL  50B4
056B2:  MOVLB  5
....................       toggle=1;
056B4:  MOVLB  4
056B6:  BSF    x8E.2
....................    }
056B8:  BRA    56C6
....................    else
....................    {
....................       ledConfig(LED_OFF);
056BA:  MOVLB  5
056BC:  CLRF   xA0
056BE:  MOVLB  0
056C0:  RCALL  50B4
....................       toggle=0;
056C2:  MOVLB  4
056C4:  BCF    x8E.2
....................    }
056C6:  MOVLB  0
056C8:  GOTO   5A24 (RETURN)
.................... }
.................... 
.................... #include <arQ1010/gsm.c>
.................... 
.................... char *getNetworkOperator(){
....................    char *temp=NULL;
....................    char SMART = "SMART";
....................    char TalkNText = "TalkNText";
....................    char GLOBE = "Globe Telecom-PH";
....................    
....................    clear_InterruptGSM();
....................    strcpy(DESIRED_RESPONSE, "+COPS:");
....................    strcpy(TOKEN,"\"");
....................    fprintf(GSM,"AT+COPS?\r");
....................    strtok(GetResponse(),TOKEN);
....................    temp=strtok(0,TOKEN);
....................    //fprintf(USB,"cops = %s\n",temp);
....................    if ((strcmp(temp,SMART)==0) || (strcmp(temp,TalkNText)==0)){
....................       NETWORK=0;
....................       //fprintf(USB, "SMART Network\n");
....................    }
....................    else if(strcmp(temp,GLOBE)==0){
....................       NETWORK=1;
....................       //fprintf(USB, "GLOBE Network\n");
....................    }
....................    
....................    else{  
....................       NETWORK=2;
....................       //fprintf(USB,"%s\n",temp);
....................    }
....................    
....................    //fprintf(USB,"Network: %s\n", temp);
....................    return temp;
.................... }
....................    
....................    
.................... 
.................... 
.................... int checkNetworkRegistration(void){//serves to verify the network registration status
....................    //int counter = 0;
....................    //int1 status=FALSE;
....................    char *temp=NULL;
....................    
....................    clear_InterruptGSM();
....................    strcpy(DESIRED_RESPONSE, "+CREG: ");
....................    strcpy(TOKEN, "\r\n");
....................    fprintf(GSM, "AT+CREG?\r");
....................    delay_ms(100);
....................    //fprintf(USB, "RXD: %s\n",InterruptGSM_Rxd);
....................    temp = strtok(GetResponse(), TOKEN);
....................    //fprintf(USB, "Network: %s\n",temp);
....................    
....................    if (temp[2] == '1'){
....................       //fprintf(USB, "Network Registration Successful\n");
....................       return TRUE;
....................    }
....................    
....................    else{   
....................       //fprintf(USB, "Network Registration Failed\n");
....................       return FALSE;
....................    }
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 testGSM(void){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM, "AT\r");
....................    
....................    if(GetResponse()){
....................       //fprintf(USB,"Active %s\n",FIRMWARE_desc);
....................       fprintf(USB,"GSM module active\n");
....................       return TRUE;
....................    }
....................    else{
....................       fprintf(USB,"GSM module no response\n");
....................       return FALSE;
....................    }
.................... }
.................... 
.................... void igniteGSM(){
....................    //int cnt = 0;
....................    
....................    fprintf(USB,"Ignite GSM module\n");
....................    output_low(IGT);
....................    delay_ms(10);
....................    output_high(IGT);
....................    delay_ms(110);
....................    output_low(IGT);
....................    delay_ms(1000);
....................    
....................    
....................    //{fprintf(USB,"GSM Ignite Try: %i\n",cnt+1);
....................       //delay_ms(100);
....................       //cnt++;
....................    //} while(!testGSM() && (cnt < 5));
.................... }
.................... 
.................... void ShutDownGSM(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"AT^SMSO\r");
....................    if(GetResponse())
....................       fprintf(USB,"GSM Module Shutdown\n");
.................... }
.................... 
.................... void InitGSM(void){
....................    int timeOut=0;
....................    //char *temp=NULL;
....................    
....................    clear_InterruptGSM();
....................    fprintf(USB,"Initialize GSM Module\n");
.................... 
....................    retry:
....................    timeOut=0;
....................       
....................    igniteGSM();
....................    delay_ms(2000);
....................       
....................    if (testGSM()){
....................       fprintf(USB,"Checking network registration, please wait\n");
....................       while(timeOut<20){
....................          if (checkNetworkRegistration()){   
....................             fprintf(USB,"Registered to network: %s\n",getNetworkOperator()); // register ME to network           
....................             break;
....................          }
....................               
....................          else{
....................             delay_ms(1000);
....................             timeOut++;
....................          }
....................       }
....................                
....................       if (timeOut==20){
....................          fprintf(USB,"Network registration failed\n");
....................          fprintf(USB,"Performing GSM module reboot\n");
....................          shutDownGSM();
....................          delay_ms(2000);
....................          goto retry;
....................       }
....................           
....................    }
.................... 
....................    else{
....................       goto retry;
....................    }
.................... 
....................    strcpy(DESIRED_RESPONSE, "OK");  
....................    port_b_pullups(00000010);
....................    //fprintf(USB,"Pull up on PORT B\n");
....................    //fprintf(GSM,"AT+CFUN=1,1\r");
....................    //if (GetResponse())
....................    //fprintf(USB,"ME reset\n");
....................    fprintf(GSM, "AT&F0\r"); // set to factory settings
....................    if(GetResponse())
....................       //fprintf(USB,"Factory settings\n");
....................       
....................       fprintf(GSM, "ATE0\r"); // set echo to off
....................       if(GetResponse())
....................          //fprintf(USB,"Echo off\n");
....................          
....................       fprintf(GSM, "AT^SSYNC=1\r");      // activate LED
....................       if(GetResponse())
....................          //fprintf(USB,"LED active\n");
....................        
....................       fprintf(GSM, "AT+CNMI=1,1,0,0,1\r"); // sms indications set
....................       if(GetResponse())
....................          //fprintf(USB,"SMS indications set\n");
....................       
....................       fprintf(GSM, "AT+CMGF=1\r"); // set to text mode
....................       if(GetResponse())
....................          //fprintf(USB,"Set text mode\n");
....................       
....................       fprintf(GSM, "AT+CSMS=0\r");
....................       if(GetResponse())
....................          //fprintf(USB,"Msg service selected\n");
....................       
....................       fprintf(GSM, "AT+CLIP=1\r"); // display number of calling party
....................       if(GetResponse())
....................          //fprintf(USB,"CLIP enabled\n");
....................       
....................       fprintf(GSM, "AT+CPBS=ON\r"); // select GSM memory as storage phonebook
....................       if(GetResponse())
....................          //fprintf(USB,"PhonebookReady\n");
....................       
....................       fprintf(GSM, "AT+CPMS=MT,MT,MT\r");
....................       if (GetResponse())
....................          //fprintf(USB,"StorageReady\n");
....................         
....................       //fprintf(GSM, "AT+CNMI=2,2,0,0,0\r"); //command to received live message
....................       //if (GetResponse())
....................      
....................    fprintf(USB,"GSM ready\n");
.................... }
.................... 
.................... //----Delete all messages inside Inbox
.................... void clear_inputs(){
....................    int ii=0;
....................    //fprintf(USB, "Kahit ano\n");
....................    for(ii=0;ii<40;ii++){
....................       fprintf(GSM, "AT+CMGD=%i\r", ii);
....................       delay_ms(100);
....................    }   
.................... }
.................... 
.................... int1 SendSMS(char *msg, char *number){
....................    char dq = 0x22; // 0x22 is double quote (") character
....................    //int1 status = FALSE;
....................    //int1 statx=FALSE;
....................    int counter = 0;
....................    //int loopCount=0;
....................     
....................    strcpy(DESIRED_RESPONSE, "> ");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................    fprintf(GSM, "AT+CMGS=%c%s%c,129\r", dq,number,dq);
....................     
....................    //fprintf(USB, "AT+CMGS=%c%s%c,129\r\n", dq,Phone_Number,dq);
....................     
....................    do{
....................       if (InterruptGSM_Flag){ //checks if there is new data in the GSM serial line
....................          //fprintf(USB, "RXD1: %s\n",InterruptGSM_Rxd);
....................     
....................          if (GetResponse()){ //check if "> " is received in the GSM serial line
....................             counter = 0;
....................             clear_InterruptGSM();
....................             //delay_ms(100);
....................             strcpy(DESIRED_RESPONSE, "OK");
....................             fprintf(GSM, "%s\r", msg);
....................             //fprintf(USB, "%s\n", SMS_TOBE_SENT);
....................             fputc(0x1A, GSM); // 0x0A is ctrl-z to terminate message and start sending
....................                
....................             do{
....................                //fprintf(USB, "Counter: %i\n",counter);
....................                if (InterruptGSM_Flag){
....................                //fprintf(USB, "RXD2: %s\n",InterruptGSM_Rxd);
....................                   if (GetResponse()){
....................                      fprintf(USB, "Message sent to: %s\n",number);
....................                      powerGSMready = 1;
....................                      return 1;
....................                         
....................                      //break;
....................                   }
....................                   
....................                   else{
....................                      fprintf(USB, "GSM error 2: Message NOT sent.\n"); //Returns ERROR -> No / low GSM signal causes SMS sending failure
....................                      InterruptGSM_Flag=0;
....................                      powerGSMready = 0;
....................                      return 0;
....................                   }
....................                }
....................                   
....................                else{  
....................                   //fprintf(USB, "Waiting for GSM response %i.\n",counter);
....................                }  
....................                
....................                delay_ms(100);
....................             } while(counter++ < 200);
....................                
....................             fprintf(USB, "GSM Timeout 2: Message NOT sent.\n");
....................             return 0;
....................                
....................          }
....................          else{      
....................             //InterruptGSM_Flag=0; //resetting the flag to 0
....................             fprintf(USB, "GSM error 1:  Message NOT sent.\n");
....................             return 0;
....................          }
....................          }
.................... //!      else
.................... //!         {
.................... //!         fprintf(USB, "Waiting for GSM response %i.\n",counter);
.................... //!         }
....................        
....................         
....................        delay_ms(100);
....................    } while(counter++ < 50); //total waiting time of 5 seconds
....................    
....................    fprintf(USB, "GSM Timeout 1: Message NOT sent.\n");
....................    return 0;
.................... }// end SendSMS()
.................... 
.................... /*
.................... int1 SendSMS(char *Phone_Number){
....................    char dq = 0x22; // 0x22 is double quote (") character  
....................    //int1 status = FALSE;
....................    //int1 statx=FALSE;
....................    int counter = 0;
....................    //int loopCount=0;
.................... 
....................    strcpy(DESIRED_RESPONSE, "> ");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM, "AT+CMGS=%c%s%c,129\r", dq,Phone_Number,dq);
....................    //fprintf(USB, "AT+CMGS=%c%s%c,129\r\n", dq,Phone_Number,dq);
....................     
....................    do{
....................       if (InterruptGSM_Flag){ //checks if there is new data in the GSM serial line
....................          //fprintf(USB, "RXD1: %s\n",InterruptGSM_Rxd);  
....................          if (GetResponse()){ //check if "> " is received in the GSM serial line
....................             counter = 0;
....................             clear_InterruptGSM();
....................             delay_ms(100);
....................             strcpy(DESIRED_RESPONSE, "OK");
....................             fprintf(GSM, "%s\r", SMS_TOBE_SENT);
....................             //fprintf(USB, "%s\n", SMS_TOBE_SENT);
....................             fputc(0x1A, GSM); // 0x0A is ctrl-z to terminate message and start sending
....................                
....................             do{
....................                //fprintf(USB, "Counter: %i\n",counter);
....................                if (InterruptGSM_Flag){
....................                   //fprintf(USB, "RXD2: %s\n",InterruptGSM_Rxd);
....................                   if (GetResponse()){      
....................                      fprintf(USB, "Message sent to: %s\n",SERVERNUMBER);
....................                      return 1;
....................                      //break;
....................                   }
....................                   
....................                   else{
....................                      fprintf(USB, "GSM error 2: Message NOT sent.\n"); //Returns ERROR -> No / low GSM signal causes SMS sending failure
....................                      InterruptGSM_Flag=0;
....................                      return 0;
....................                   }
....................                }
....................                   
....................                //else{    
....................                   //fprintf(USB, "Waiting for GSM response %i.\n",counter);
....................                //}  
....................                delay_ms(1000);  
....................                
....................             } while(counter++ < 20);
....................                
....................             fprintf(USB, "GSM Timeout 2: Message NOT sent.\n");
....................             return 0;
....................                
....................          }
....................             
....................          else{
....................             //InterruptGSM_Flag=0; //resetting the flag to 0
....................             fprintf(USB, "GSM error 1:  Message NOT sent.\n");
....................             return 0;
....................          }
....................       }
.................... 
....................       //else{
....................          //fprintf(USB, "Waiting for GSM response %i.\n",counter);
....................       //}
....................        
....................         
....................       delay_ms(500);
....................    } while(counter++ < 10); //total waiting time of 2 seconds
....................    
....................    fprintf(USB, "GSM Timeout 1: Message NOT sent.\n");
....................    return 0;
.................... }// end SendSMS()
.................... */
.................... 
.................... char *getGSM_Strength(){
....................    char *statx=NULL;
....................    char *statcat=NULL;
....................    
....................    strcpy(DESIRED_RESPONSE, "+CSQ: ");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................    fprintf(GSM,"AT+CSQ\r");
....................    statx = GetResponse();
....................    strcpy(TOKEN,",");
....................    statcat = strtok(statx,TOKEN);
....................    //strcpy(funcReturnVar,statcat);
....................    
....................    //fprintf(USB,"GSM signal: %s\n",statcat);
....................    
....................    return statcat;
.................... }
.................... 
.................... 
.................... void AttemptToSend(char *msg, char *num){ // attempt to send three times
....................    int try = 1;
....................    fprintf(USB,"SMS: %s\n", msg);
....................    
....................    while (try<=5){
....................       //restart_wdt();
....................       getGSM_Strength();
....................       fprintf(USB, "Try to send %i -> ",try);
....................       
....................       if (SendSMS(msg, num)){   
....................          break;
....................       }
....................       
....................       else{
....................          try++;
....................       }
....................    }
....................    delay_ms(100);
.................... }
.................... 
.................... //!void AttemptToSend() // attempt to send three times
.................... //!{
.................... //!
.................... //!   int try = 1;
.................... //!   
.................... //!   fprintf(USB,"SMS: %s\n", SMS_TOBE_SENT);
.................... //!   
.................... //!   while (try<=5)
.................... //!   {//restart_wdt();
.................... //!   
.................... //!   getGSM_Strength();
.................... //!   fprintf(USB, "Try to send %i -> ",try);
.................... //!   
.................... //!   if (SendSMS(SERVERNUMBER))
.................... //!      {
.................... //!       break;
.................... //!      }
.................... //!   else
.................... //!      {
.................... //!       
.................... //!       try++;
.................... //!      }
.................... //!   }
.................... //!   
.................... //!
.................... //!}
.................... 
.................... void SetGSMTime(char *clockSetting){ // this function sets the GSM time
....................    char *ptrx=NULL;
....................    char clockx[30] = {};
....................    
....................    strcpy(clockx,clockSetting);
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    //delay_ms(100);
....................    
....................    //clear_InterruptGSM();
....................    //fprintf(GSM, "AT+CCLK=?\r");
....................    //delay_ms(100);
....................    //fprintf(USB, "RXD1: %s\n", InterruptGSM_Rxd);
....................    
....................    clear_InterruptGSM();
....................    //fprintf(USB, "AT+CCLK=\"%s\"\r\n",clockx);
....................    fprintf(GSM, "AT+CCLK=\"%s\"\r",clockx);
....................    delay_ms(100);
....................    
....................    if (GetResponse())
....................       fprintf(USB,"GSM clock set\n");
....................       
....................    else
....................       fprintf(USB,"GSM clock NOT set\n");
....................       
....................    strcpy(DESIRED_RESPONSE, "+CCLK: ");
....................    clear_InterruptGSM();
.................... 
....................    fprintf(GSM,"AT+CCLK?\r");
....................    delay_ms(50);
....................    ptrx = strtok(GetResponse(),TOKEN);
....................    
....................    //fprintf(USB,"GSM date and time: %s\n",ptrx); 
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/LTE.c>
.................... void initLTE(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"init\r");
....................    delay_ms(1000);
....................    if(GetResponse())
....................       fprintf(USB,"LTE Initialized\n");
.................... }
.................... 
.................... char *signalLTE(){
....................    char *signal=NULL;
....................    //strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    //delay_ms(200);
....................     delay_ms(200);
....................    fprintf(GSM,"signal\r");
....................    delay_ms(200);
....................    signal = GetResponse();
....................    //fprintf(USB, signal);
....................    return signal;
.................... }
.................... 
.................... void sendToLTE(char *msg){
....................    strcpy(DESIRED_RESPONSE, "OK");
*
020A6:  MOVLW  03
020A8:  MOVWF  FEA
020AA:  MOVLW  6F
020AC:  MOVWF  FE9
020AE:  MOVLW  00
020B0:  CALL   0104
020B4:  TBLRD*-
020B6:  TBLRD*+
020B8:  MOVF   FF5,W
020BA:  MOVWF  FEE
020BC:  IORLW  00
020BE:  BNZ   20B6
....................    clear_InterruptGSM();
020C0:  RCALL  1E64
....................    delay_ms(200);
020C2:  MOVLW  C8
020C4:  MOVLB  6
020C6:  MOVWF  x6E
020C8:  MOVLB  0
020CA:  CALL   0F16
....................    fprintf(GSM, msg);
020CE:  MOVFF  66A,FEA
020D2:  MOVFF  669,FE9
020D6:  BRA    1EA0
....................    if(GetResponse())
020D8:  BRA    1EC8
020DA:  MOVF   01,W
020DC:  IORWF  02,W
020DE:  BZ    2110
....................       fprintf(USB,"\nSMS Sent: %s\n", msg);
020E0:  MOVLW  14
020E2:  MOVWF  FF6
020E4:  MOVLW  06
020E6:  MOVWF  FF7
020E8:  MOVLW  00
020EA:  MOVWF  FF8
020EC:  MOVLW  0B
020EE:  MOVLB  6
020F0:  MOVWF  x91
020F2:  MOVLB  0
020F4:  CALL   1080
020F8:  MOVFF  66A,FEA
020FC:  MOVFF  669,FE9
02100:  CALL   10B4
02104:  MOVLW  0A
02106:  BTFSS  FA4.4
02108:  BRA    2106
0210A:  MOVLB  F
0210C:  MOVWF  x1C
0210E:  MOVLB  0
02110:  RETURN 0
.................... }  
....................  
....................  void relayOFF(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"OFF\r");
....................    delay_ms(200);
.................... }
.................... 
....................  void relayON(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"ON\r");
....................    delay_ms(200);
.................... }
.................... 
.................... 
....................  void igtLTE(){
....................    strcpy(DESIRED_RESPONSE, "OK");
....................    clear_InterruptGSM();
....................    delay_ms(200);
....................    fprintf(GSM,"igt\r");
....................    delay_ms(2000);
....................    if(GetResponse())
....................       fprintf(USB,"LTE Ignited\n");   
.................... }
.................... 
.................... #include <arQ1010/interruptTimer1.c>
.................... #Byte TMR1H = 0xFCF   // TIMER1 HIGH BYTE LOOK DATASHEET
.................... #Byte T1CON = 0xFCD  //TIMER1 CONFIG REGISTER LOOK DATASHEET 
.................... 
.................... 
.................... 
.................... //#define IS_LEAP(year) (year%4 == 0)
.................... unsigned int INTERRUPTCHECKER=0;
.................... 
.................... int1 IS_LEAP(year)
*
006B6:  MOVLB  6
006B8:  CLRF   xF4
006BA:  CLRF   xF3
.................... {
....................    int16 year_ = 0;
....................    
....................    year_ = year + 2000;
006BC:  MOVLW  D0
006BE:  ADDWF  xF2,W
006C0:  MOVWF  xF3
006C2:  MOVLW  07
006C4:  MOVWF  xF4
006C6:  BTFSC  FD8.0
006C8:  INCF   xF4,F
....................    if (((year_ % 4 == 0) && (year % 100 != 0)) || (year % 400 ==0))
006CA:  MOVF   xF3,W
006CC:  ANDLW  03
006CE:  MOVWF  xF5
006D0:  CLRF   xF6
006D2:  MOVF   xF5,F
006D4:  BNZ   06EC
006D6:  MOVF   xF6,F
006D8:  BNZ   06EC
006DA:  MOVFF  6F2,6F5
006DE:  MOVLW  64
006E0:  MOVWF  xF6
006E2:  MOVLB  0
006E4:  RCALL  0642
006E6:  MOVF   00,F
006E8:  BNZ   0712
006EA:  MOVLB  6
006EC:  CLRF   xF6
006EE:  MOVFF  6F2,6F5
006F2:  MOVLW  01
006F4:  MOVWF  xF8
006F6:  MOVLW  90
006F8:  MOVWF  xF7
006FA:  MOVLB  0
006FC:  BRA    066E
006FE:  MOVFF  00,6F5
00702:  MOVLB  6
00704:  MOVFF  03,6F6
00708:  MOVF   xF5,F
0070A:  BNZ   071C
0070C:  MOVF   xF6,F
0070E:  BNZ   071C
00710:  MOVLB  0
....................       return 1;
00712:  MOVLW  01
00714:  MOVWF  01
00716:  BRA    0722
00718:  BRA    0722
0071A:  MOVLB  6
....................    else
....................       return 0;
0071C:  MOVLW  00
0071E:  MOVWF  01
00720:  MOVLB  0
00722:  GOTO   0768 (RETURN)
.................... }
.................... 
.................... 
.................... #int_TIMER1 
.................... void TIMER1_isr()    
.................... { 
....................    bit_clear(T1CON,1);
00726:  BCF    FCD.1
....................    bit_set(TMR1H,7);
00728:  BSF    FCF.7
....................    bit_set(T1CON,1);
0072A:  BSF    FCD.1
....................    
....................    INTERRUPTCHECKER=0; 
0072C:  MOVLB  4
0072E:  CLRF   x91
....................    if (++SEC>59){
00730:  MOVLB  3
00732:  INCF   x80,F
00734:  MOVF   x80,W
00736:  SUBLW  3B
00738:  BC    07D2
....................       SEC=0;
0073A:  CLRF   x80
....................       TESTFLAG=TRUE;
0073C:  BSF    40.6
....................       if(++MIN>59){
0073E:  INCF   x81,F
00740:  MOVF   x81,W
00742:  SUBLW  3B
00744:  BC    07D2
....................          MIN=0;
00746:  CLRF   x81
....................          if(++HOUR>23){
00748:  INCF   x82,F
0074A:  MOVF   x82,W
0074C:  SUBLW  17
0074E:  BC    07D2
....................             HOUR=0;
00750:  CLRF   x82
....................             ++DAY;
00752:  INCF   x83,F
....................             if ((DAY == 29 && MONTH== 2 && !IS_LEAP(YEAR))
....................                || (DAY == 30 && MONTH==2)
....................                || (DAY == 31 && (MONTH==4 || MONTH==6 || MONTH==9 || MONTH==11))
....................                || (DAY == 32)
00754:  MOVF   x83,W
00756:  SUBLW  1D
00758:  BNZ   076E
0075A:  MOVF   x84,W
0075C:  SUBLW  02
0075E:  BNZ   076E
00760:  MOVFF  385,6F2
00764:  MOVLB  0
00766:  BRA    06B6
00768:  MOVF   01,F
0076A:  BZ    07BC
0076C:  MOVLB  3
0076E:  MOVF   x83,W
00770:  SUBLW  1E
00772:  BNZ   0780
00774:  MOVF   x84,W
00776:  SUBLW  02
00778:  BTFSS  FD8.2
0077A:  BRA    0780
0077C:  MOVLB  0
0077E:  BRA    07BC
00780:  MOVF   x83,W
00782:  SUBLW  1F
00784:  BNZ   07B6
00786:  MOVF   x84,W
00788:  SUBLW  04
0078A:  BTFSS  FD8.2
0078C:  BRA    0792
0078E:  MOVLB  0
00790:  BRA    07BC
00792:  MOVF   x84,W
00794:  SUBLW  06
00796:  BTFSS  FD8.2
00798:  BRA    079E
0079A:  MOVLB  0
0079C:  BRA    07BC
0079E:  MOVF   x84,W
007A0:  SUBLW  09
007A2:  BTFSS  FD8.2
007A4:  BRA    07AA
007A6:  MOVLB  0
007A8:  BRA    07BC
007AA:  MOVF   x84,W
007AC:  SUBLW  0B
007AE:  BTFSS  FD8.2
007B0:  BRA    07B6
007B2:  MOVLB  0
007B4:  BRA    07BC
007B6:  MOVF   x83,W
007B8:  SUBLW  20
007BA:  BNZ   07C4
....................                ){MONTH++;DAY=1;}
007BC:  MOVLB  3
007BE:  INCF   x84,F
007C0:  MOVLW  01
007C2:  MOVWF  x83
....................             if(MONTH == 13) {YEAR++; MONTH=1;}
007C4:  MOVF   x84,W
007C6:  SUBLW  0D
007C8:  BNZ   07D0
007CA:  INCF   x85,F
007CC:  MOVLW  01
007CE:  MOVWF  x84
....................             RESETCPU=1;
007D0:  BSF    40.5
....................          }
.................... //!         if (HOUR == 8)
.................... //!            RESETFLAG=TRUE;
....................       }
....................    }
....................    
....................    if ((HOUR == 23) && (MIN == 58)  && (SEC == 0))
007D2:  MOVF   x82,W
007D4:  SUBLW  17
007D6:  BNZ   07E4
007D8:  MOVF   x81,W
007DA:  SUBLW  3A
007DC:  BNZ   07E4
007DE:  MOVF   x80,F
007E0:  BNZ   07E4
....................        { 
.................... 
....................         SYNCFLAG=TRUE;
007E2:  BSF    40.7
....................        }  
....................    
....................    if ((HOUROLD != HOUR) && (MIN == 58))
007E4:  MOVF   x82,W
007E6:  MOVLB  4
007E8:  SUBWF  x8D,W
007EA:  BZ    0802
007EC:  MOVLB  3
007EE:  MOVF   x81,W
007F0:  SUBLW  3A
007F2:  BTFSC  FD8.2
007F4:  BRA    07FA
007F6:  MOVLB  4
007F8:  BRA    0802
....................    {  
....................       RESETFLAG=TRUE;
007FA:  MOVLB  4
007FC:  BSF    x8E.0
....................       HOUROLD=HOUR;
007FE:  MOVFF  382,48D
....................    }
....................    
....................    if ((MIN%SENDING_TIME) == 0)
00802:  MOVFF  381,6F5
00806:  MOVFF  48C,6F6
0080A:  MOVLB  0
0080C:  RCALL  0642
0080E:  MOVF   00,F
00810:  BNZ   081C
....................    {
....................       if (CHECKMINUTE == FALSE)
00812:  BTFSC  40.4
00814:  BRA    081A
....................       {
....................          CHECKMINUTE = TRUE;
00816:  BSF    40.4
....................          SAMPLINGFLAG = TRUE;
00818:  BSF    40.3
....................       }
....................    }
0081A:  BRA    081E
....................    else
....................       CHECKMINUTE = FALSE;
0081C:  BCF    40.4
....................      
.................... }
.................... 
.................... 
.................... 
.................... #include <arQ1010/rtc.c>
.................... #define RTC_I2C_ADDR_2129     81
.................... #define RTC_I2C_ADDR_8523     104
.................... #define RTC_CONTROL1_REG      0x00
.................... #define RTC_CONTROL2_REG      0x01
.................... #define RTC_CONTROL3_REG      0x02
.................... 
.................... #define RTC_SEC_REG           0x03
.................... #define RTC_MIN_REG           0x04
.................... #define RTC_HOUR_REG          0x05
.................... #define RTC_DATE_REG          0x06
.................... #define RTC_WEEKDAY_REG       0x07
.................... #define RTC_MONTH_REG         0x08
0081E:  BCF    F9E.0
00820:  GOTO   0098
.................... #define RTC_YEAR_REG          0x09
.................... 
.................... 
.................... int8 get_ack_status(int8 address)
.................... {
....................    int8 status; 
....................    
....................    i2c_start(); 
....................    status = i2c_write(address);  // Status = 0 if got an ACK 
....................    i2c_stop(); 
....................    
....................    if(status == 0) 
....................       return(TRUE); 
....................    else 
....................       return(FALSE); 
.................... }
.................... 
.................... int32 rtcGetEpochDate(int32 year, int month, int day)
.................... {
....................     if (year >= 1900)
....................       {
....................         year -= 1900;
....................     }
....................     
....................     /* month must be cast to uint8_t or this fails on some platforms */
....................     int8 m = (int8)(month & 0xFF);
....................     return (1461 * (year + 6700 + (m - 14) / 12)) / 4 + (367 *
....................         (m - 2 - 12 * ((m - 14) / 12))) / 12 -
....................         (3 * ((year + 6800 + (m - 14) / 12) / 100)) / 4 +
....................         day - 2472663;
.................... }
.................... 
.................... int rtcAssignWeekday(int32 years, int months, int days)
.................... {
....................     int32 NrOfDay=0;
....................     int8 weekday=0;
....................     NrOfDay = rtcGetEpochDate(years, months, days);
....................     weekday = (NrOfDay + 3) % 7;
....................     //fprintf(PC,"NrOfDay=%lu\n",NrOfDay);
....................     //fprintf(PC,"weekday=%u\n",weekday);
....................     return weekday;
.................... }
.................... 
.................... int8 rtcBCDToDec(int8 val)
.................... {
....................     return (val >> 4) * 10 + (val & 0x0F);
*
00FA8:  MOVLB  6
00FAA:  SWAPF  x4A,W
00FAC:  MOVWF  00
00FAE:  MOVLW  0F
00FB0:  ANDWF  00,F
00FB2:  MOVF   00,W
00FB4:  MULLW  0A
00FB6:  MOVFF  FF3,64B
00FBA:  MOVF   x4A,W
00FBC:  ANDLW  0F
00FBE:  ADDWF  x4B,W
00FC0:  MOVWF  01
00FC2:  MOVLB  0
00FC4:  RETURN 0
.................... }   
.................... 
.................... int8 rtcDecToBCD(int8 val)
*
051EC:  CLRF   1B
051EE:  BTFSC  FF2.7
051F0:  BSF    1B.7
051F2:  BCF    FF2.7
.................... {
....................     return ((val / 10) << 4) | (val % 10);
051F4:  MOVFF  631,6F5
051F8:  MOVLW  0A
051FA:  MOVLB  6
051FC:  MOVWF  xF6
051FE:  MOVLB  0
05200:  CALL   0642
05204:  BTFSC  1B.7
05206:  BSF    FF2.7
05208:  SWAPF  01,W
0520A:  MOVLB  6
0520C:  MOVWF  x32
0520E:  MOVLW  F0
05210:  ANDWF  x32,F
05212:  CLRF   1B
05214:  BTFSC  FF2.7
05216:  BSF    1B.7
05218:  BCF    FF2.7
0521A:  MOVFF  631,6F5
0521E:  MOVLW  0A
05220:  MOVWF  xF6
05222:  MOVLB  0
05224:  CALL   0642
05228:  BTFSC  1B.7
0522A:  BSF    FF2.7
0522C:  MOVF   00,W
0522E:  MOVLB  6
05230:  IORWF  x32,W
05232:  MOVWF  01
05234:  MOVLB  0
05236:  RETURN 0
.................... }
.................... /*
.................... void GetDateTime()
.................... {
....................    
....................    int ii=0;
....................    int xx=0;
....................    char forTime[5]={};
....................    char strDateTime[20] ={};
....................    
....................    strcpy(funcReturnVar,"");
....................    for (xx=0;xx<=5;xx++) 
....................    {
....................       switch(xx) {
....................          case 0:
....................             itoa(years,10,forTime);
....................             break;
....................          case 1:
....................             itoa(months,10,forTime);
....................             break;
....................          case 2:
....................             itoa(days,10,forTime);
....................             break;
....................          case 3:
....................             itoa(hours,10,forTime);
....................             break;
....................          case 4:
....................             itoa(minutes,10,forTime);
....................             break;
....................          case 5:
....................             itoa(seconds,10,forTime);
....................             break;
....................       }
....................       if (strlen(forTime)==4) {
....................          strDateTime[ii++] = forTime[2];
....................          strDateTime[ii++] = forTime[3];
....................          strDateTime[ii++] = ':';
....................          }
....................       else if (strlen(forTime)<2) {
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = forTime[0];
....................          strDateTime[ii++] = ':';
....................          }
....................       else if (strlen(forTime)==2)  {
....................          strDateTime[ii++] = forTime[0];
....................          strDateTime[ii++] = forTime[1];
....................          strDateTime[ii++] = ':';
....................          }
....................       else {
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = '0';
....................          strDateTime[ii++] = ':';
....................          }
....................    }
....................    ii--;
....................    strDateTime[ii] = '\0';
....................   fprintf(PC,"strDateTime=%s\n",strDateTime);
....................    //strcpy(funcReturnVar,strDateTime);
.................... }
.................... */
.................... 
.................... // if storeToVariables = 1 then store rtc configs to date and time variables
.................... // used to read configs from rtc chip 
.................... char *readRtc() //int1 storeToVariables
*
010DE:  MOVLB  6
010E0:  CLRF   x25
010E2:  CLRF   x26
010E4:  CLRF   x27
010E6:  CLRF   x28
010E8:  CLRF   x29
010EA:  CLRF   x2A
*
01114:  CLRF   x3F
01116:  CLRF   x48
.................... {
....................    int seconds=0;
....................    int minutes=0;
....................    int hours=0;
....................    int days=0;
....................    int months=0;
....................    int years=0;
....................     
....................    char strDateTime[20]={};
*
010EC:  CLRF   x2B
010EE:  CLRF   x2C
010F0:  CLRF   x2D
010F2:  CLRF   x2E
010F4:  CLRF   x2F
010F6:  CLRF   x30
010F8:  CLRF   x31
010FA:  CLRF   x32
010FC:  CLRF   x33
010FE:  CLRF   x34
01100:  CLRF   x35
01102:  CLRF   x36
01104:  CLRF   x37
01106:  CLRF   x38
01108:  CLRF   x39
0110A:  CLRF   x3A
0110C:  CLRF   x3B
0110E:  CLRF   x3C
01110:  CLRF   x3D
01112:  CLRF   x3E
....................    int status=0;
....................    int data[8];
....................    int i=0;
....................    
....................    //char *ptr=NULL;
....................    
....................    i2c_start();
*
01118:  BSF    F66.0
0111A:  BTFSC  F66.0
0111C:  BRA    111A
....................    i2c_write(0xA2);  
0111E:  MOVLW  A2
01120:  MOVWF  x49
01122:  MOVLB  0
01124:  RCALL  0F6E
....................    i2c_write(RTC_SEC_REG);
01126:  MOVLW  03
01128:  MOVLB  6
0112A:  MOVWF  x49
0112C:  MOVLB  0
0112E:  RCALL  0F6E
....................    i2c_stop(); 
01130:  BSF    F66.2
01132:  BTFSC  F66.2
01134:  BRA    1132
....................    
....................    i2c_start();
01136:  BSF    F66.0
01138:  BTFSC  F66.0
0113A:  BRA    1138
....................    status = i2c_write(0xA2|0x01);
0113C:  MOVLW  A3
0113E:  MOVLB  6
01140:  MOVWF  x49
01142:  MOVLB  0
01144:  RCALL  0F6E
01146:  MOVFF  01,63F
....................    //fprintf(PC,"for reading=%x\n",status);
....................    
....................    for (i=0;i<7;i++)
0114A:  MOVLB  6
0114C:  CLRF   x48
0114E:  MOVF   x48,W
01150:  SUBLW  06
01152:  BNC   1174
....................       data[i] = i2c_read();
01154:  CLRF   03
01156:  MOVF   x48,W
01158:  ADDLW  40
0115A:  MOVWF  FE9
0115C:  MOVLW  06
0115E:  ADDWFC 03,W
01160:  MOVWF  FEA
01162:  MOVLW  01
01164:  MOVWF  00
01166:  MOVLB  0
01168:  BRA    0F8A
0116A:  MOVFF  01,FEF
0116E:  MOVLB  6
01170:  INCF   x48,F
01172:  BRA    114E
....................    i2c_stop(); 
01174:  BSF    F66.2
01176:  BTFSC  F66.2
01178:  BRA    1176
....................    
....................    seconds  = rtcBCDToDec(data[0] & 0x7F);
0117A:  MOVF   x40,W
0117C:  ANDLW  7F
0117E:  MOVWF  x49
01180:  MOVWF  x4A
01182:  MOVLB  0
01184:  RCALL  0FA8
01186:  MOVFF  01,625
....................    minutes  = rtcBCDToDec(data[1]);
0118A:  MOVFF  641,64A
0118E:  RCALL  0FA8
01190:  MOVFF  01,626
....................    hours  = rtcBCDToDec(data[2]);
01194:  MOVFF  642,64A
01198:  RCALL  0FA8
0119A:  MOVFF  01,627
....................    days  = rtcBCDToDec(data[3]);
0119E:  MOVFF  643,64A
011A2:  RCALL  0FA8
011A4:  MOVFF  01,628
....................    months  = rtcBCDToDec(data[5]);
011A8:  MOVFF  645,64A
011AC:  RCALL  0FA8
011AE:  MOVFF  01,629
....................    years  = rtcBCDToDec(data[6]);
011B2:  MOVFF  646,64A
011B6:  RCALL  0FA8
011B8:  MOVFF  01,62A
....................    //timezone = rtcBCDToDec(data[7]);
....................    
.................... /*   
....................    fprintf(PC,"sec=%u\n",seconds);
....................    fprintf(PC,"minutes=%u\n",minutes);
....................    fprintf(PC,"hours=%u\n",hours);
....................    fprintf(PC,"days=%u\n",days);
....................    fprintf(PC,"months=%u\n",months);
....................    fprintf(PC,"years=%u\n",years);
.................... */  
.................... 
....................    
.................... //!   if (storeToVariables==TRUE) // should be outside this function...
.................... //!   {
.................... //!      SEC = seconds;
.................... //!      MIN = minutes;
.................... //!      HOUR = hours;
.................... //!      DAY = days;
.................... //!      MONTH = months;
.................... //!      YEAR = years;
.................... //!      fprintf(USB,"MCU clock set\n");
.................... //!   }
....................       
....................       sprintf(strDateTime,"%u/%u/%u,%u:%u:%u",years,months,days,hours,minutes,seconds);
011BC:  MOVLW  06
011BE:  MOVLB  4
011C0:  MOVWF  x90
011C2:  MOVLW  2B
011C4:  MOVWF  x8F
011C6:  MOVFF  62A,649
011CA:  MOVLW  1B
011CC:  MOVLB  6
011CE:  MOVWF  x4A
011D0:  MOVLB  0
011D2:  RCALL  0FE8
011D4:  MOVLW  2F
011D6:  MOVLB  6
011D8:  MOVWF  xBD
011DA:  MOVLB  0
011DC:  RCALL  0FC6
011DE:  MOVFF  629,649
011E2:  MOVLW  1B
011E4:  MOVLB  6
011E6:  MOVWF  x4A
011E8:  MOVLB  0
011EA:  RCALL  0FE8
011EC:  MOVLW  2F
011EE:  MOVLB  6
011F0:  MOVWF  xBD
011F2:  MOVLB  0
011F4:  RCALL  0FC6
011F6:  MOVFF  628,649
011FA:  MOVLW  1B
011FC:  MOVLB  6
011FE:  MOVWF  x4A
01200:  MOVLB  0
01202:  RCALL  0FE8
01204:  MOVLW  2C
01206:  MOVLB  6
01208:  MOVWF  xBD
0120A:  MOVLB  0
0120C:  RCALL  0FC6
0120E:  MOVFF  627,649
01212:  MOVLW  1B
01214:  MOVLB  6
01216:  MOVWF  x4A
01218:  MOVLB  0
0121A:  RCALL  0FE8
0121C:  MOVLW  3A
0121E:  MOVLB  6
01220:  MOVWF  xBD
01222:  MOVLB  0
01224:  RCALL  0FC6
01226:  MOVFF  626,649
0122A:  MOVLW  1B
0122C:  MOVLB  6
0122E:  MOVWF  x4A
01230:  MOVLB  0
01232:  RCALL  0FE8
01234:  MOVLW  3A
01236:  MOVLB  6
01238:  MOVWF  xBD
0123A:  MOVLB  0
0123C:  RCALL  0FC6
0123E:  MOVFF  625,649
01242:  MOVLW  1B
01244:  MOVLB  6
01246:  MOVWF  x4A
01248:  MOVLB  0
0124A:  RCALL  0FE8
....................       fprintf(USB,"RTC date and time: %s\n",strDateTime);
0124C:  MOVLW  24
0124E:  MOVWF  FF6
01250:  MOVLW  08
01252:  MOVWF  FF7
01254:  MOVLW  00
01256:  MOVWF  FF8
01258:  MOVLW  13
0125A:  MOVLB  6
0125C:  MOVWF  x91
0125E:  MOVLB  0
01260:  RCALL  1080
01262:  MOVLW  06
01264:  MOVWF  FEA
01266:  MOVLW  2B
01268:  MOVWF  FE9
0126A:  RCALL  10B4
0126C:  MOVLW  0A
0126E:  BTFSS  FA4.4
01270:  BRA    126E
01272:  MOVLB  F
01274:  MOVWF  x1C
....................        
....................    return strDateTime;
01276:  MOVLW  2B
01278:  MOVWF  01
0127A:  MOVLW  06
0127C:  MOVWF  02
0127E:  MOVLB  0
01280:  GOTO   1B88 (RETURN)
....................    
.................... }
.................... 
.................... 
.................... void configI2C(int param1, int param2)
.................... {
....................    i2c_start(); 
*
05238:  BSF    F66.0
0523A:  BTFSC  F66.0
0523C:  BRA    523A
....................    i2c_write(0xA2);  // Status = 0 if got an ACK 
0523E:  MOVLW  A2
05240:  MOVLB  6
05242:  MOVWF  x49
05244:  MOVLB  0
05246:  CALL   0F6E
....................    i2c_write(param1);
0524A:  MOVFF  630,649
0524E:  CALL   0F6E
....................    i2c_write(param2);
05252:  MOVFF  631,649
05256:  CALL   0F6E
....................    i2c_stop();
0525A:  BSF    F66.2
0525C:  BTFSC  F66.2
0525E:  BRA    525C
05260:  RETURN 0
.................... }
.................... 
.................... void setRtc(char *input)
05262:  MOVLB  6
05264:  CLRF   x11
05266:  CLRF   x12
05268:  CLRF   x13
0526A:  CLRF   x14
0526C:  CLRF   x15
0526E:  CLRF   x16
.................... {
....................     int seconds=0;
....................     int minutes=0;
....................     int hours=0;
....................     int days=0;
....................     int months=0;
....................     int years=0;
....................     
....................     char temp[20]={};
05270:  CLRF   x17
05272:  CLRF   x18
05274:  CLRF   x19
05276:  CLRF   x1A
05278:  CLRF   x1B
0527A:  CLRF   x1C
0527C:  CLRF   x1D
0527E:  CLRF   x1E
05280:  CLRF   x1F
05282:  CLRF   x20
05284:  CLRF   x21
05286:  CLRF   x22
05288:  CLRF   x23
0528A:  CLRF   x24
0528C:  CLRF   x25
0528E:  CLRF   x26
05290:  CLRF   x27
05292:  CLRF   x28
05294:  CLRF   x29
05296:  CLRF   x2A
....................     char tempx[3]={};
05298:  CLRF   x2B
0529A:  CLRF   x2C
0529C:  CLRF   x2D
....................     char *ptr;
....................     
....................    strcpy(TOKEN,"/,:\"");       //yy/mm/dd,hh:mm:ss
0529E:  CLRF   FEA
052A0:  MOVLW  22
052A2:  MOVWF  FE9
052A4:  MOVLW  00
052A6:  MOVLB  0
052A8:  CALL   011C
052AC:  TBLRD*-
052AE:  TBLRD*+
052B0:  MOVF   FF5,W
052B2:  MOVWF  FEE
052B4:  IORLW  00
052B6:  BNZ   52AE
....................    strcpy(temp,input);
052B8:  MOVLW  06
052BA:  MOVWF  FEA
052BC:  MOVLW  17
052BE:  MOVWF  FE9
052C0:  MOVFF  610,FE2
052C4:  MOVFF  60F,FE1
052C8:  MOVF   FE7,F
052CA:  MOVFF  FE6,FEE
052CE:  BNZ   52C8
....................    delay_ms(150);
052D0:  MOVLW  96
052D2:  MOVLB  6
052D4:  MOVWF  x6E
052D6:  MOVLB  0
052D8:  CALL   0F16
....................    ptr = strtok(temp,TOKEN);
052DC:  MOVLW  06
052DE:  MOVLB  6
052E0:  MOVWF  xA9
052E2:  MOVLW  17
052E4:  MOVWF  xA8
052E6:  CLRF   xAB
052E8:  MOVLW  22
052EA:  MOVWF  xAA
052EC:  MOVLB  0
052EE:  CALL   13B6
052F2:  MOVFF  02,62F
052F6:  MOVFF  01,62E
....................    strcpy(tempx,ptr);
052FA:  MOVLW  06
052FC:  MOVWF  FEA
052FE:  MOVLW  2B
05300:  MOVWF  FE9
05302:  MOVFF  62F,FE2
05306:  MOVFF  62E,FE1
0530A:  MOVF   FE7,F
0530C:  MOVFF  FE6,FEE
05310:  BNZ   530A
.................... //!   YEAR = atoi(tempx);
....................    years  = rtcDecToBCD(atoi(tempx));
05312:  MOVLW  06
05314:  MOVLB  6
05316:  MOVWF  x41
05318:  MOVLW  2B
0531A:  MOVWF  x40
0531C:  MOVLB  0
0531E:  CALL   14BA
05322:  MOVFF  01,630
05326:  MOVFF  01,631
0532A:  RCALL  51EC
0532C:  MOVFF  01,616
....................    //YEAR = YEAR + 2000;
....................    
....................    ptr = strtok(0,TOKEN);
05330:  MOVLB  6
05332:  CLRF   xA9
05334:  CLRF   xA8
05336:  CLRF   xAB
05338:  MOVLW  22
0533A:  MOVWF  xAA
0533C:  MOVLB  0
0533E:  CALL   13B6
05342:  MOVFF  02,62F
05346:  MOVFF  01,62E
....................    strcpy(tempx,ptr);
0534A:  MOVLW  06
0534C:  MOVWF  FEA
0534E:  MOVLW  2B
05350:  MOVWF  FE9
05352:  MOVFF  62F,FE2
05356:  MOVFF  62E,FE1
0535A:  MOVF   FE7,F
0535C:  MOVFF  FE6,FEE
05360:  BNZ   535A
.................... //!   MONTH = atoi(tempx);
....................    months  = rtcDecToBCD(atoi(tempx));
05362:  MOVLW  06
05364:  MOVLB  6
05366:  MOVWF  x41
05368:  MOVLW  2B
0536A:  MOVWF  x40
0536C:  MOVLB  0
0536E:  CALL   14BA
05372:  MOVFF  01,630
05376:  MOVFF  01,631
0537A:  RCALL  51EC
0537C:  MOVFF  01,615
....................    
....................    ptr = strtok(0,TOKEN);
05380:  MOVLB  6
05382:  CLRF   xA9
05384:  CLRF   xA8
05386:  CLRF   xAB
05388:  MOVLW  22
0538A:  MOVWF  xAA
0538C:  MOVLB  0
0538E:  CALL   13B6
05392:  MOVFF  02,62F
05396:  MOVFF  01,62E
....................    strcpy(tempx,ptr);
0539A:  MOVLW  06
0539C:  MOVWF  FEA
0539E:  MOVLW  2B
053A0:  MOVWF  FE9
053A2:  MOVFF  62F,FE2
053A6:  MOVFF  62E,FE1
053AA:  MOVF   FE7,F
053AC:  MOVFF  FE6,FEE
053B0:  BNZ   53AA
.................... //!   DAY = atoi(tempx);
....................    days  = rtcDecToBCD(atoi(tempx));
053B2:  MOVLW  06
053B4:  MOVLB  6
053B6:  MOVWF  x41
053B8:  MOVLW  2B
053BA:  MOVWF  x40
053BC:  MOVLB  0
053BE:  CALL   14BA
053C2:  MOVFF  01,630
053C6:  MOVFF  01,631
053CA:  RCALL  51EC
053CC:  MOVFF  01,614
....................    
....................    ptr = strtok(0,TOKEN);
053D0:  MOVLB  6
053D2:  CLRF   xA9
053D4:  CLRF   xA8
053D6:  CLRF   xAB
053D8:  MOVLW  22
053DA:  MOVWF  xAA
053DC:  MOVLB  0
053DE:  CALL   13B6
053E2:  MOVFF  02,62F
053E6:  MOVFF  01,62E
....................    strcpy(tempx,ptr);
053EA:  MOVLW  06
053EC:  MOVWF  FEA
053EE:  MOVLW  2B
053F0:  MOVWF  FE9
053F2:  MOVFF  62F,FE2
053F6:  MOVFF  62E,FE1
053FA:  MOVF   FE7,F
053FC:  MOVFF  FE6,FEE
05400:  BNZ   53FA
.................... //!   HOUR = atoi(tempx);
....................    hours  = rtcDecToBCD(atoi(tempx));
05402:  MOVLW  06
05404:  MOVLB  6
05406:  MOVWF  x41
05408:  MOVLW  2B
0540A:  MOVWF  x40
0540C:  MOVLB  0
0540E:  CALL   14BA
05412:  MOVFF  01,630
05416:  MOVFF  01,631
0541A:  RCALL  51EC
0541C:  MOVFF  01,613
....................    
....................    ptr = strtok(0,TOKEN);
05420:  MOVLB  6
05422:  CLRF   xA9
05424:  CLRF   xA8
05426:  CLRF   xAB
05428:  MOVLW  22
0542A:  MOVWF  xAA
0542C:  MOVLB  0
0542E:  CALL   13B6
05432:  MOVFF  02,62F
05436:  MOVFF  01,62E
....................    strcpy(tempx,ptr);
0543A:  MOVLW  06
0543C:  MOVWF  FEA
0543E:  MOVLW  2B
05440:  MOVWF  FE9
05442:  MOVFF  62F,FE2
05446:  MOVFF  62E,FE1
0544A:  MOVF   FE7,F
0544C:  MOVFF  FE6,FEE
05450:  BNZ   544A
.................... //!   MIN = atoi(tempx);
....................    minutes  = rtcDecToBCD(atoi(tempx));
05452:  MOVLW  06
05454:  MOVLB  6
05456:  MOVWF  x41
05458:  MOVLW  2B
0545A:  MOVWF  x40
0545C:  MOVLB  0
0545E:  CALL   14BA
05462:  MOVFF  01,630
05466:  MOVFF  01,631
0546A:  RCALL  51EC
0546C:  MOVFF  01,612
....................    
....................    ptr = strtok(0,TOKEN);
05470:  MOVLB  6
05472:  CLRF   xA9
05474:  CLRF   xA8
05476:  CLRF   xAB
05478:  MOVLW  22
0547A:  MOVWF  xAA
0547C:  MOVLB  0
0547E:  CALL   13B6
05482:  MOVFF  02,62F
05486:  MOVFF  01,62E
....................    strcpy(tempx,ptr);
0548A:  MOVLW  06
0548C:  MOVWF  FEA
0548E:  MOVLW  2B
05490:  MOVWF  FE9
05492:  MOVFF  62F,FE2
05496:  MOVFF  62E,FE1
0549A:  MOVF   FE7,F
0549C:  MOVFF  FE6,FEE
054A0:  BNZ   549A
.................... //!   SEC = atoi(tempx);
....................    seconds  = rtcDecToBCD(atoi(tempx));   
054A2:  MOVLW  06
054A4:  MOVLB  6
054A6:  MOVWF  x41
054A8:  MOVLW  2B
054AA:  MOVWF  x40
054AC:  MOVLB  0
054AE:  CALL   14BA
054B2:  MOVFF  01,630
054B6:  MOVFF  01,631
054BA:  RCALL  51EC
054BC:  MOVFF  01,611
....................    
....................     configI2C(RTC_SEC_REG, seconds);
054C0:  MOVLW  03
054C2:  MOVLB  6
054C4:  MOVWF  x30
054C6:  MOVFF  611,631
054CA:  MOVLB  0
054CC:  RCALL  5238
....................     configI2C(RTC_MIN_REG, minutes);
054CE:  MOVLW  04
054D0:  MOVLB  6
054D2:  MOVWF  x30
054D4:  MOVFF  612,631
054D8:  MOVLB  0
054DA:  RCALL  5238
....................     configI2C(RTC_HOUR_REG, hours);
054DC:  MOVLW  05
054DE:  MOVLB  6
054E0:  MOVWF  x30
054E2:  MOVFF  613,631
054E6:  MOVLB  0
054E8:  RCALL  5238
....................     configI2C(RTC_DATE_REG, days);
054EA:  MOVLW  06
054EC:  MOVLB  6
054EE:  MOVWF  x30
054F0:  MOVFF  614,631
054F4:  MOVLB  0
054F6:  RCALL  5238
....................     configI2C(RTC_MONTH_REG, months);
054F8:  MOVLW  08
054FA:  MOVLB  6
054FC:  MOVWF  x30
054FE:  MOVFF  615,631
05502:  MOVLB  0
05504:  RCALL  5238
....................     configI2C(RTC_YEAR_REG, years);
05506:  MOVLW  09
05508:  MOVLB  6
0550A:  MOVWF  x30
0550C:  MOVFF  616,631
05510:  MOVLB  0
05512:  RCALL  5238
....................    // readRtc(0);
....................    
....................     fprintf(USB, "RTC updated\n");
05514:  MOVLW  3C
05516:  MOVWF  FF6
05518:  MOVLW  08
0551A:  MOVWF  FF7
0551C:  MOVLW  00
0551E:  MOVWF  FF8
05520:  CALL   0F40
05524:  GOTO   5660 (RETURN)
.................... }
.................... 
.................... 
.................... #include <arQ1010/dateTimeDetails.c>
.................... void counterNewYear()
.................... {
....................    char *ptr=NULL;
....................    char temp[20]={};
....................    
....................    if (MIN == 0 && HOUR == 0 && DAY == 31 && MONTH == 12)
....................    {
....................       YEAR_PREV = YEAR - 2000;
....................       fprintf(USB, "YEAR_PREV=%i\n",YEAR_PREV);
....................    }
....................    
....................    if (MIN == 0 && HOUR == 0 && DAY == 1 && MONTH == 1)
....................    {
....................       strcpy(DESIRED_RESPONSE, "+CCLK: ");
....................       delay_ms(100);
....................       YEAR_PREV++;
....................       itoa(YEAR_PREV,10,InterruptUSB_Rxd);
....................       strcpy(temp,"/01/01,00:00:03");
....................       strcat(InterruptUSB_Rxd,temp);
....................       //strcat(InterruptUSB_Rxd,"/01/01,00:00:03");
....................       fprintf(USB, "from COUNTERNEWYEAR =%s\n",InterruptUSB_Rxd);
....................       clear_InterruptUSB();
....................       fprintf(GSM, "AT+CCLK=\"%s\"\r",InterruptUSB_Rxd);
....................       strcpy(InterruptUSB_Rxd,"");
....................       if (GetResponse())
....................          fprintf(USB,"clock set\n");
....................       delay_ms(200);
....................       clear_InterruptUSB();
....................       do {
....................          fprintf(GSM,"AT+CCLK?\r");
....................          delay_ms(200);
....................          ptr = GetResponse();
....................       }while(!ptr);
....................    }
.................... }
.................... 
.................... char *convertDateParam(int param)
.................... {
....................  char *funcSmallStr;
....................    
....................    //fprintf (USB,"param %i\n", param);
....................    
....................    if (param < 10)
*
01940:  MOVLB  6
01942:  MOVF   x66,W
01944:  SUBLW  09
01946:  BNC   196C
....................       sprintf(funcSmallStr,"0%i",param);
01948:  MOVFF  668,490
0194C:  MOVFF  667,48F
01950:  MOVLW  30
01952:  MOVWF  xBD
01954:  MOVLB  0
01956:  CALL   0FC6
0195A:  MOVFF  666,6B0
0195E:  MOVLW  18
01960:  MOVLB  6
01962:  MOVWF  xB1
01964:  MOVLB  0
01966:  RCALL  1860
01968:  BRA    1980
0196A:  MOVLB  6
....................    else
....................       sprintf(funcSmallStr,"%i",param);
0196C:  MOVFF  668,490
01970:  MOVFF  667,48F
01974:  MOVFF  666,6B0
01978:  MOVLW  18
0197A:  MOVWF  xB1
0197C:  MOVLB  0
0197E:  RCALL  1860
....................    
....................    //fprintf (USB,"funSmallSTr %s\n", funcSmallStr);
....................    
....................    //delay_ms(50);
....................    return funcSmallStr;
01980:  MOVLB  6
01982:  MOVFF  667,01
01986:  MOVFF  668,02
0198A:  MOVLB  0
0198C:  RETURN 0
....................  }
.................... 
.................... char *getMcuDateTime() 
*
01A76:  MOVLB  6
01A78:  CLRF   x63
01A7A:  CLRF   x65
01A7C:  CLRF   x64
.................... // create a string composed of date and time in the format YY/MM/DD,HH:MM:SS
.................... // store it in funcReturnVar variable 
.................... {
.................... //!   char strDateTime[20] ={};
.................... //!   char *strDateTime;
....................    char charx = NULL;
....................    char *ptr = NULL;
....................       
....................    charx='/'; 
01A7E:  MOVLW  2F
01A80:  MOVWF  x63
....................    
....................    //fprintf (USB,"YEAR: %i\n",YEAR);  
.................... //!   ptr = convertDateParam(YEAR);
.................... //!   strcpy(strDateTime,ptr);
....................    strcpy(strDateTime,convertDateParam(YEAR));
01A82:  MOVFF  385,666
01A86:  MOVLB  0
01A88:  RCALL  1940
01A8A:  MOVFF  02,667
01A8E:  MOVFF  01,666
01A92:  MOVLW  03
01A94:  MOVWF  FEA
01A96:  MOVLW  87
01A98:  MOVWF  FE9
01A9A:  MOVFF  02,FE2
01A9E:  MOVFF  01,FE1
01AA2:  MOVF   FE7,F
01AA4:  MOVFF  FE6,FEE
01AA8:  BNZ   1AA2
.................... //!   strncat(strDateTime,&charx,1);
.................... 
.................... //!   ptr = convertDateParam(MONTH);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(MONTH));
01AAA:  MOVFF  384,666
01AAE:  RCALL  1940
01AB0:  MOVFF  02,667
01AB4:  MOVFF  01,666
01AB8:  MOVLW  03
01ABA:  MOVLB  6
01ABC:  MOVWF  xA9
01ABE:  MOVLW  87
01AC0:  MOVWF  xA8
01AC2:  MOVFF  02,6AB
01AC6:  MOVFF  01,6AA
01ACA:  MOVLB  0
01ACC:  RCALL  198E
.................... //!   strncat(strDateTime,&charx,1);
....................    
.................... //!   charx=',';
....................    
.................... //!   ptr = convertDateParam(DAY);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(DAY));
01ACE:  MOVFF  383,666
01AD2:  RCALL  1940
01AD4:  MOVFF  02,667
01AD8:  MOVFF  01,666
01ADC:  MOVLW  03
01ADE:  MOVLB  6
01AE0:  MOVWF  xA9
01AE2:  MOVLW  87
01AE4:  MOVWF  xA8
01AE6:  MOVFF  02,6AB
01AEA:  MOVFF  01,6AA
01AEE:  MOVLB  0
01AF0:  RCALL  198E
....................    strncat(strDateTime,&charx,1);   
01AF2:  MOVLW  03
01AF4:  MOVLB  6
01AF6:  MOVWF  x67
01AF8:  MOVLW  87
01AFA:  MOVWF  x66
01AFC:  MOVLW  06
01AFE:  MOVWF  x69
01B00:  MOVLW  63
01B02:  MOVWF  x68
01B04:  CLRF   x6B
01B06:  MOVLW  01
01B08:  MOVWF  x6A
01B0A:  MOVLB  0
01B0C:  BRA    19F8
....................    
.................... //!   charx=':';
....................    
.................... //!   ptr = convertDateParam(HOUR);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(HOUR));
01B0E:  MOVFF  382,666
01B12:  RCALL  1940
01B14:  MOVFF  02,667
01B18:  MOVFF  01,666
01B1C:  MOVLW  03
01B1E:  MOVLB  6
01B20:  MOVWF  xA9
01B22:  MOVLW  87
01B24:  MOVWF  xA8
01B26:  MOVFF  02,6AB
01B2A:  MOVFF  01,6AA
01B2E:  MOVLB  0
01B30:  RCALL  198E
.................... //!   strncat(strDateTime,&charx,1);
....................    
.................... //!   ptr = convertDateParam(MIN);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(MIN));
01B32:  MOVFF  381,666
01B36:  RCALL  1940
01B38:  MOVFF  02,667
01B3C:  MOVFF  01,666
01B40:  MOVLW  03
01B42:  MOVLB  6
01B44:  MOVWF  xA9
01B46:  MOVLW  87
01B48:  MOVWF  xA8
01B4A:  MOVFF  02,6AB
01B4E:  MOVFF  01,6AA
01B52:  MOVLB  0
01B54:  RCALL  198E
.................... //!   strncat(strDateTime,&charx,1);
.................... 
.................... //!   ptr = convertDateParam(SEC);
.................... //!   strcat(strDateTime,ptr);
....................    strcat(strDateTime,convertDateParam(SEC));
01B56:  MOVFF  380,666
01B5A:  RCALL  1940
01B5C:  MOVFF  02,667
01B60:  MOVFF  01,666
01B64:  MOVLW  03
01B66:  MOVLB  6
01B68:  MOVWF  xA9
01B6A:  MOVLW  87
01B6C:  MOVWF  xA8
01B6E:  MOVFF  02,6AB
01B72:  MOVFF  01,6AA
01B76:  MOVLB  0
01B78:  RCALL  198E
.................... 
.................... //!   delay_ms(10);
....................   // fprintf(USB,"MCU date and time: %s\n",strDateTime);
....................     //strcpy(globalDT, strDateTime);
....................     
....................    return strDateTime;
01B7A:  MOVLW  87
01B7C:  MOVWF  01
01B7E:  MOVLW  03
01B80:  MOVWF  02
01B82:  RETURN 0
....................    
.................... 
.................... }
.................... void updateMcuDateTime(char *ptx) //converts strings to integer and change date and time values
*
0164C:  MOVLB  6
0164E:  CLRF   x28
01650:  CLRF   x27
.................... {
....................    char *dataz=NULL;
....................    char temp1[20]={};
01652:  CLRF   x29
01654:  CLRF   x2A
01656:  CLRF   x2B
01658:  CLRF   x2C
0165A:  CLRF   x2D
0165C:  CLRF   x2E
0165E:  CLRF   x2F
01660:  CLRF   x30
01662:  CLRF   x31
01664:  CLRF   x32
01666:  CLRF   x33
01668:  CLRF   x34
0166A:  CLRF   x35
0166C:  CLRF   x36
0166E:  CLRF   x37
01670:  CLRF   x38
01672:  CLRF   x39
01674:  CLRF   x3A
01676:  CLRF   x3B
01678:  CLRF   x3C
....................    char tempx[3]={};
0167A:  CLRF   x3D
0167C:  CLRF   x3E
0167E:  CLRF   x3F
....................    
....................    //fprintf(USB,"ptx: %s\n",ptx);
....................    
....................    strcpy(TOKEN,"/,:\"");       //yy/mm/dd,hh:mm:ss
01680:  CLRF   FEA
01682:  MOVLW  22
01684:  MOVWF  FE9
01686:  MOVLW  00
01688:  MOVLB  0
0168A:  CALL   011C
0168E:  TBLRD*-
01690:  TBLRD*+
01692:  MOVF   FF5,W
01694:  MOVWF  FEE
01696:  IORLW  00
01698:  BNZ   1690
....................    strcpy(temp1,ptx);
0169A:  MOVLW  06
0169C:  MOVWF  FEA
0169E:  MOVLW  29
016A0:  MOVWF  FE9
016A2:  MOVFF  626,FE2
016A6:  MOVFF  625,FE1
016AA:  MOVF   FE7,F
016AC:  MOVFF  FE6,FEE
016B0:  BNZ   16AA
....................    
....................    delay_ms(150);
016B2:  MOVLW  96
016B4:  MOVLB  6
016B6:  MOVWF  x6E
016B8:  MOVLB  0
016BA:  RCALL  0F16
....................    dataz = strtok(temp1,TOKEN);
016BC:  MOVLW  06
016BE:  MOVLB  6
016C0:  MOVWF  xA9
016C2:  MOVLW  29
016C4:  MOVWF  xA8
016C6:  CLRF   xAB
016C8:  MOVLW  22
016CA:  MOVWF  xAA
016CC:  MOVLB  0
016CE:  RCALL  13B6
016D0:  MOVFF  02,628
016D4:  MOVFF  01,627
....................    strcpy(tempx,dataz);
016D8:  MOVLW  06
016DA:  MOVWF  FEA
016DC:  MOVLW  3D
016DE:  MOVWF  FE9
016E0:  MOVFF  628,FE2
016E4:  MOVFF  627,FE1
016E8:  MOVF   FE7,F
016EA:  MOVFF  FE6,FEE
016EE:  BNZ   16E8
....................    YEAR = atoi(tempx);
016F0:  MOVLW  06
016F2:  MOVLB  6
016F4:  MOVWF  x41
016F6:  MOVLW  3D
016F8:  MOVWF  x40
016FA:  MOVLB  0
016FC:  RCALL  14BA
016FE:  MOVFF  01,385
....................    //YEAR = YEAR + 2000;
....................    
....................    dataz = strtok(0,TOKEN);
01702:  MOVLB  6
01704:  CLRF   xA9
01706:  CLRF   xA8
01708:  CLRF   xAB
0170A:  MOVLW  22
0170C:  MOVWF  xAA
0170E:  MOVLB  0
01710:  RCALL  13B6
01712:  MOVFF  02,628
01716:  MOVFF  01,627
....................    strcpy(tempx,dataz);
0171A:  MOVLW  06
0171C:  MOVWF  FEA
0171E:  MOVLW  3D
01720:  MOVWF  FE9
01722:  MOVFF  628,FE2
01726:  MOVFF  627,FE1
0172A:  MOVF   FE7,F
0172C:  MOVFF  FE6,FEE
01730:  BNZ   172A
....................    MONTH = atoi(tempx);
01732:  MOVLW  06
01734:  MOVLB  6
01736:  MOVWF  x41
01738:  MOVLW  3D
0173A:  MOVWF  x40
0173C:  MOVLB  0
0173E:  RCALL  14BA
01740:  MOVFF  01,384
....................    
....................    dataz = strtok(0,TOKEN);
01744:  MOVLB  6
01746:  CLRF   xA9
01748:  CLRF   xA8
0174A:  CLRF   xAB
0174C:  MOVLW  22
0174E:  MOVWF  xAA
01750:  MOVLB  0
01752:  RCALL  13B6
01754:  MOVFF  02,628
01758:  MOVFF  01,627
....................    strcpy(tempx,dataz);
0175C:  MOVLW  06
0175E:  MOVWF  FEA
01760:  MOVLW  3D
01762:  MOVWF  FE9
01764:  MOVFF  628,FE2
01768:  MOVFF  627,FE1
0176C:  MOVF   FE7,F
0176E:  MOVFF  FE6,FEE
01772:  BNZ   176C
....................    DAY = atoi(tempx);
01774:  MOVLW  06
01776:  MOVLB  6
01778:  MOVWF  x41
0177A:  MOVLW  3D
0177C:  MOVWF  x40
0177E:  MOVLB  0
01780:  RCALL  14BA
01782:  MOVFF  01,383
....................    
....................    dataz = strtok(0,TOKEN);
01786:  MOVLB  6
01788:  CLRF   xA9
0178A:  CLRF   xA8
0178C:  CLRF   xAB
0178E:  MOVLW  22
01790:  MOVWF  xAA
01792:  MOVLB  0
01794:  RCALL  13B6
01796:  MOVFF  02,628
0179A:  MOVFF  01,627
....................    strcpy(tempx,dataz);
0179E:  MOVLW  06
017A0:  MOVWF  FEA
017A2:  MOVLW  3D
017A4:  MOVWF  FE9
017A6:  MOVFF  628,FE2
017AA:  MOVFF  627,FE1
017AE:  MOVF   FE7,F
017B0:  MOVFF  FE6,FEE
017B4:  BNZ   17AE
....................    HOUR = atoi(tempx);
017B6:  MOVLW  06
017B8:  MOVLB  6
017BA:  MOVWF  x41
017BC:  MOVLW  3D
017BE:  MOVWF  x40
017C0:  MOVLB  0
017C2:  RCALL  14BA
017C4:  MOVFF  01,382
....................    
....................    dataz = strtok(0,TOKEN);
017C8:  MOVLB  6
017CA:  CLRF   xA9
017CC:  CLRF   xA8
017CE:  CLRF   xAB
017D0:  MOVLW  22
017D2:  MOVWF  xAA
017D4:  MOVLB  0
017D6:  RCALL  13B6
017D8:  MOVFF  02,628
017DC:  MOVFF  01,627
....................    strcpy(tempx,dataz);
017E0:  MOVLW  06
017E2:  MOVWF  FEA
017E4:  MOVLW  3D
017E6:  MOVWF  FE9
017E8:  MOVFF  628,FE2
017EC:  MOVFF  627,FE1
017F0:  MOVF   FE7,F
017F2:  MOVFF  FE6,FEE
017F6:  BNZ   17F0
....................    MIN = atoi(tempx);
017F8:  MOVLW  06
017FA:  MOVLB  6
017FC:  MOVWF  x41
017FE:  MOVLW  3D
01800:  MOVWF  x40
01802:  MOVLB  0
01804:  RCALL  14BA
01806:  MOVFF  01,381
....................    
....................    dataz = strtok(0,TOKEN);
0180A:  MOVLB  6
0180C:  CLRF   xA9
0180E:  CLRF   xA8
01810:  CLRF   xAB
01812:  MOVLW  22
01814:  MOVWF  xAA
01816:  MOVLB  0
01818:  RCALL  13B6
0181A:  MOVFF  02,628
0181E:  MOVFF  01,627
....................    strcpy(tempx,dataz);
01822:  MOVLW  06
01824:  MOVWF  FEA
01826:  MOVLW  3D
01828:  MOVWF  FE9
0182A:  MOVFF  628,FE2
0182E:  MOVFF  627,FE1
01832:  MOVF   FE7,F
01834:  MOVFF  FE6,FEE
01838:  BNZ   1832
....................    SEC = atoi(tempx);
0183A:  MOVLW  06
0183C:  MOVLB  6
0183E:  MOVWF  x41
01840:  MOVLW  3D
01842:  MOVWF  x40
01844:  MOVLB  0
01846:  RCALL  14BA
01848:  MOVFF  01,380
.................... 
.................... 
.................... //!   fprintf(USB,"MCU date and time: %u/%u/%u,%u:%u:%u\n",YEAR,MONTH,DAY,HOUR,MIN,SEC);
....................    
.................... 
....................    fprintf(USB,"MCU clock set\n");
0184C:  MOVLW  96
0184E:  MOVWF  FF6
01850:  MOVLW  08
01852:  MOVWF  FF7
01854:  MOVLW  00
01856:  MOVWF  FF8
01858:  CALL   0F40
0185C:  GOTO   1BB6 (RETURN)
....................    
.................... }
.................... 
.................... void rtc_acquire_sync()
.................... { char *ptr;
....................   char temp[20];
....................   
....................   ptr = readRtc();
*
01B84:  GOTO   10DE
01B88:  MOVFF  02,610
01B8C:  MOVFF  01,60F
.................... //!  fprintf(USB,"RTC date and time: %s\n",ptr);
.................... 
....................   strcpy(temp,ptr);
01B90:  MOVLW  06
01B92:  MOVWF  FEA
01B94:  MOVLW  11
01B96:  MOVWF  FE9
01B98:  MOVFF  610,FE2
01B9C:  MOVFF  60F,FE1
01BA0:  MOVF   FE7,F
01BA2:  MOVFF  FE6,FEE
01BA6:  BNZ   1BA0
....................   updateMcuDateTime(temp);
01BA8:  MOVLW  06
01BAA:  MOVLB  6
01BAC:  MOVWF  x26
01BAE:  MOVLW  11
01BB0:  MOVWF  x25
01BB2:  MOVLB  0
01BB4:  BRA    164C
....................   
....................   ptr=getMcuDateTime();
01BB6:  RCALL  1A76
01BB8:  MOVFF  02,610
01BBC:  MOVFF  01,60F
....................   fprintf(USB,"MCU date and time: %s\n",ptr);
01BC0:  MOVLW  A6
01BC2:  MOVWF  FF6
01BC4:  MOVLW  08
01BC6:  MOVWF  FF7
01BC8:  MOVLW  00
01BCA:  MOVWF  FF8
01BCC:  MOVLW  13
01BCE:  MOVLB  6
01BD0:  MOVWF  x91
01BD2:  MOVLB  0
01BD4:  CALL   1080
01BD8:  MOVFF  610,FEA
01BDC:  MOVFF  60F,FE9
01BE0:  CALL   10B4
01BE4:  MOVLW  0A
01BE6:  BTFSS  FA4.4
01BE8:  BRA    1BE6
01BEA:  MOVLB  F
01BEC:  MOVWF  x1C
01BEE:  MOVLB  0
01BF0:  RETURN 0
.................... 
.................... //!    if(stopBTD200Sampling)
.................... //!      {ptr=getMcuDateTime();
.................... //!       strcpy(temp,ptr);
.................... //!       updateMcuDateTime(temp);
.................... //!      
.................... //!      }        
....................           
.................... }
.................... 
.................... 
.................... //!
.................... //!void rtc_acquire_sync_noGSM()
.................... //!{
.................... //!   readRtc(1);
.................... //!   GetDateTime();
.................... //!   //SetGSMTime(funcReturnVar);   
.................... //!}
.................... 
.................... //!
.................... //!void downloadDateTime()
.................... //!{
.................... //!   getDataFromUSB();
.................... //!   SetGSMTime(FROMSERIALPC);
.................... //!   fprintf(USB,"%s",funcReturnVar);
.................... //!   InsertTimeToVariables(funcReturnVar);
.................... //!}
.................... //!
.................... 
.................... 
.................... 
.................... #include <arQ1010/debugmode.c>
.................... //#use rs232(baud=9600, xmit=PIN_G4, rcv=PIN_G3, stream=IDP)// IDP
.................... 
.................... void debugMenu()
.................... {
....................    //fprintf(USB,"\n    FIRMWARE VERSION: %s\n",FIRMWARE);
....................    
....................    fprintf(USB,"      DEBUG MODE MENU\n");
....................    fprintf(USB,"      A.     Get data from the sensor\n");
....................    fprintf(USB,"      B.     Get arQ's current configurations\n");
....................    fprintf(USB,"      C.     Display DEBUG menu\n");
....................    fprintf(USB,"      D.     Change sending time\n");
....................    fprintf(USB,"      E.     Check satellite sending\n");
....................    fprintf(USB,"      F.     Set server number\n");
....................    fprintf(USB,"      G.     List registered numbers\n");
....................    fprintf(USB,"      H.     Generate CRC code\n");
....................    fprintf(USB,"      I.     Set date and time\n");
....................    fprintf(USB,"      J.     Set power board configuration\n");
.................... //!   fprintf(USB,"      K.     VAISALA settings\n");
....................    fprintf(USB,"      L.     Download data from flash memory\n");
....................    fprintf(USB,"      M.     Change password\n");
....................    fprintf(USB,"      N.     Enable satellite\n");
....................    fprintf(USB,"      O.     Set the sensor type\n");
.................... //!   fprintf(USB,"P.    Rain gauge test\n");
....................    fprintf(USB,"      Q.    Test Iridium satellite commands\n");
....................    //fprintf(USB,"      R.     Set soil sensor (5TE) ID\n");
....................    fprintf(USB,"      S.     Turn off watchdog\n");
.................... //!   fprintf(USB,"      T.     Check boost pin\n");
.................... //!   #ifdef DYNAMICRAIN
.................... //!   fprintf(USB,"U.    Set dynamic rain\n");
.................... //!   #endif
.................... //!   fprintf(USB,"V.    Change RMYOUNG ID\n");
....................    fprintf(USB,"      W.     Exit DEBUG mode\n");
....................    fprintf(USB,"      X.     Delete registered number\n");
....................    //fprintf(USB,"Z.    Change SENSLOPE command\n");
....................    fprintf(USB,"      a.     Register number\n");
....................    //fprintf(USB,"      b.     Set GSM provider\n");
....................    //fprintf(USB,"      c.     Manual GSM commads\n");
....................    //fprintf(USB,"d.    IDP test\n");
....................    delay_ms(10);
.................... }
.................... 
.................... 
.................... int1 debugDetails()
*
05528:  MOVLB  5
0552A:  CLRF   xA0
0552C:  CLRF   x9F
0552E:  BCF    xA1.0
.................... {
....................    int16 yy=0;
....................    
....................    int1 exit_=0;
....................    char debugDataInquire[50]={};
05530:  CLRF   xA2
05532:  CLRF   xA3
05534:  CLRF   xA4
05536:  CLRF   xA5
05538:  CLRF   xA6
0553A:  CLRF   xA7
0553C:  CLRF   xA8
0553E:  CLRF   xA9
05540:  CLRF   xAA
05542:  CLRF   xAB
05544:  CLRF   xAC
05546:  CLRF   xAD
05548:  CLRF   xAE
0554A:  CLRF   xAF
0554C:  CLRF   xB0
0554E:  CLRF   xB1
05550:  CLRF   xB2
05552:  CLRF   xB3
05554:  CLRF   xB4
05556:  CLRF   xB5
05558:  CLRF   xB6
0555A:  CLRF   xB7
0555C:  CLRF   xB8
0555E:  CLRF   xB9
05560:  CLRF   xBA
05562:  CLRF   xBB
05564:  CLRF   xBC
05566:  CLRF   xBD
05568:  CLRF   xBE
0556A:  CLRF   xBF
0556C:  CLRF   xC0
0556E:  CLRF   xC1
05570:  CLRF   xC2
05572:  CLRF   xC3
05574:  CLRF   xC4
05576:  CLRF   xC5
05578:  CLRF   xC6
0557A:  CLRF   xC7
0557C:  CLRF   xC8
0557E:  CLRF   xC9
05580:  CLRF   xCA
05582:  CLRF   xCB
05584:  CLRF   xCC
05586:  CLRF   xCD
05588:  CLRF   xCE
0558A:  CLRF   xCF
0558C:  CLRF   xD0
0558E:  CLRF   xD1
05590:  CLRF   xD2
05592:  CLRF   xD3
....................    char passwordx[15]={};
05594:  CLRF   xD4
05596:  CLRF   xD5
05598:  CLRF   xD6
0559A:  CLRF   xD7
0559C:  CLRF   xD8
0559E:  CLRF   xD9
055A0:  CLRF   xDA
055A2:  CLRF   xDB
055A4:  CLRF   xDC
055A6:  CLRF   xDD
055A8:  CLRF   xDE
055AA:  CLRF   xDF
055AC:  CLRF   xE0
055AE:  CLRF   xE1
055B0:  CLRF   xE2
....................    
....................    char strx[20]={};
055B2:  CLRF   xE3
055B4:  CLRF   xE4
055B6:  CLRF   xE5
055B8:  CLRF   xE6
055BA:  CLRF   xE7
055BC:  CLRF   xE8
055BE:  CLRF   xE9
055C0:  CLRF   xEA
055C2:  CLRF   xEB
055C4:  CLRF   xEC
055C6:  CLRF   xED
055C8:  CLRF   xEE
055CA:  CLRF   xEF
055CC:  CLRF   xF0
055CE:  CLRF   xF1
055D0:  CLRF   xF2
055D2:  CLRF   xF3
055D4:  CLRF   xF4
055D6:  CLRF   xF5
055D8:  CLRF   xF6
....................    char spacex[2]=" ";
055DA:  MOVLW  20
055DC:  MOVWF  xF7
055DE:  CLRF   xF8
....................    char temp[20]={}; 
055E0:  CLRF   xF9
055E2:  CLRF   xFA
055E4:  CLRF   xFB
055E6:  CLRF   xFC
055E8:  CLRF   xFD
055EA:  CLRF   xFE
055EC:  CLRF   xFF
055EE:  MOVLB  6
055F0:  CLRF   x00
055F2:  CLRF   x01
055F4:  CLRF   x02
055F6:  CLRF   x03
055F8:  CLRF   x04
055FA:  CLRF   x05
055FC:  CLRF   x06
055FE:  CLRF   x07
05600:  CLRF   x08
05602:  CLRF   x09
05604:  CLRF   x0A
05606:  CLRF   x0B
05608:  CLRF   x0C
....................    
....................    char *ptrx;
....................  
....................    //strcpy(funcReturnVar,"");
.................... //   readDataEEprom(EEPROM_PASSWORD);
.................... //   strcpy(passwordx,funcReturnVar);
....................    
....................    fprintf(USB,"\nEnter Choice:\n");
0560A:  MOVLW  8A
0560C:  MOVWF  FF6
0560E:  MOVLW  0B
05610:  MOVWF  FF7
05612:  MOVLW  00
05614:  MOVWF  FF8
05616:  MOVLB  0
05618:  CALL   0F40
....................      
....................    getDataFromUSB();
0561C:  RCALL  51D6
....................    
....................    switch(InterruptUSB_Rxd[0])
0561E:  MOVF   2C,W
05620:  XORLW  49
05622:  BZ    5626
05624:  BRA    5666
....................    {
....................       case 'I': //SET DATE AND TIME
....................       {  
....................          getMCUDateTime();
05626:  CALL   1A76
....................          //fprintf(USB,"Current date and time: %s\n",funcReturnVar);
....................          fprintf(USB,"Press C to change\n");
0562A:  MOVLW  9A
0562C:  MOVWF  FF6
0562E:  MOVLW  0B
05630:  MOVWF  FF7
05632:  MOVLW  00
05634:  MOVWF  FF8
05636:  CALL   0F40
....................          
....................          getDataFromUSB();
0563A:  RCALL  51D6
....................                   
....................          if (InterruptUSB_Rxd[0] == 'C')
0563C:  MOVF   2C,W
0563E:  SUBLW  43
05640:  BNZ   5664
....................          {
....................             fprintf(USB,"Enter Date and Time (FORMAT \"YY/MM/DD,HH:MM:SS\")");
05642:  MOVLW  AE
05644:  MOVWF  FF6
05646:  MOVLW  0B
05648:  MOVWF  FF7
0564A:  MOVLW  00
0564C:  MOVWF  FF8
0564E:  CALL   0F40
....................             
....................             getDataFromUSB();
05652:  RCALL  51D6
....................             
....................             setRtc(InterruptUSB_Rxd);
05654:  MOVLB  6
05656:  CLRF   x10
05658:  MOVLW  2C
0565A:  MOVWF  x0F
0565C:  MOVLB  0
0565E:  BRA    5262
....................             
....................             rtc_acquire_sync();
05660:  CALL   1B84
....................             
....................             //delay_ms(50); //needed to stabilize USB input
....................             //sprintf(debugDataInquire,"DATETIME %s %s",passwordx,InterruptUSB_Rxd);
....................            
....................             //fprintf(USB, "%s",debugDataInquire);
....................             // gsmInquire(debugDataInquire,1);
....................            
.................... //!            InsertTimeToVariables(debugDataInquire);
.................... //!            rtcCreateTime();
.................... //!            //dateTimeStatus();
.................... //!            sprintf(SMS_TOBE_SENT,"DT-%s\n",funcReturnVar);
.................... 
....................          }
....................          break;
05664:  BRA    567C
....................       }
.................... //!      case 'J': //PBOARD CONFIG
.................... //!      {
.................... //!         //readDataEEprom(EEPROM_SERVER_IP);
.................... //!         //strcpy(strx,funcReturnVar); // get server ip
.................... //!         fprintf(PC,"PBOARDCONFIG = %s\n",PBOARDCONFIG);
.................... //!         fprintf(PC,"Press C to change\n");
.................... //!         getDataFromPC();
.................... //!         if (FROMSERIALPC[0] == 'C')
.................... //!         {
.................... //!            fprintf(PC,"ENTER NEW VALUE\n");
.................... //!            getDataFromPC();
.................... //!            delay_ms(10);
.................... //!            sprintf(debugDataInquire,"PBOARDCONFIG %s %s",passwordx,FROMSERIALPC);
.................... //!            gsmInquire(debugDataInquire,1);
.................... //!         }   
.................... //!         break;
.................... //!      }
.................... //!
....................       default:
....................          fprintf(USB,"Please choose another letter from the DEBUG menu\n");
05666:  MOVLW  E0
05668:  MOVWF  FF6
0566A:  MOVLW  0B
0566C:  MOVWF  FF7
0566E:  MOVLW  00
05670:  MOVWF  FF8
05672:  CALL   0F40
....................          break;
05676:  BRA    567C
....................       
....................    clear_InterruptUSB();
05678:  CALL   1BF2
....................    }
....................    return exit_;
0567C:  MOVLW  00
0567E:  MOVLB  5
05680:  BTFSC  xA1.0
05682:  MOVLW  01
05684:  MOVWF  01
05686:  MOVLB  0
05688:  GOTO   5982 (RETURN)
.................... }
.................... //!
.................... //!void testDTR()
.................... //!{
.................... //!   int x;
.................... //!   int y=0;
.................... //!   if (DEBUGMODE != IN_DEBUG_MENU)
.................... //!   {
.................... //!      if (input(pin_USB_STAT))
.................... //!      {
.................... //!         for (x=0;x<=60;x++)
.................... //!         {
.................... //!            if (input(pin_USB_STAT)) 
.................... //!               y++;
.................... //!            else
.................... //!               return;
.................... //!            delay_ms(25);
.................... //!         }
.................... //!      }
.................... //!      if (y >= 50)
.................... //!         DEBUGMODE = USB_DETECTED;
.................... //!      else
.................... //!         DEBUGMODE = NO_USB;
.................... //!   }
.................... //!}
.................... 
.................... 
.................... #include <arQ1010/crc_generate.c>
.................... 
.................... int16 crc_generator(int8 *data, int16 len){
*
027E4:  MOVLB  6
027E6:  SETF   x98
027E8:  SETF   x97
....................    int16 i;
....................    int16 crc = 0xFFFF;
....................    char crc_string[6];
....................    
....................    while(len--){
027EA:  MOVFF  694,03
027EE:  MOVF   x93,W
027F0:  BTFSC  FD8.2
027F2:  DECF   x94,F
027F4:  DECF   x93,F
027F6:  IORWF  03,W
027F8:  BZ    287A
....................       i = make8(crc,1) ^ *data++;
027FA:  MOVFF  692,FEA
027FE:  MOVF   x91,W
02800:  INCF   x91,F
02802:  BTFSC  FD8.2
02804:  INCF   x92,F
02806:  MOVWF  FE9
02808:  MOVF   FEF,W
0280A:  XORWF  x98,W
0280C:  MOVWF  x95
0280E:  CLRF   x96
....................       i ^= i>>4;
02810:  RRCF   x96,W
02812:  MOVWF  03
02814:  RRCF   x95,W
02816:  MOVWF  02
02818:  RRCF   03,F
0281A:  RRCF   02,F
0281C:  RRCF   03,F
0281E:  RRCF   02,F
02820:  RRCF   03,F
02822:  RRCF   02,F
02824:  MOVLW  0F
02826:  ANDWF  03,F
02828:  MOVF   02,W
0282A:  XORWF  x95,F
0282C:  MOVF   03,W
0282E:  XORWF  x96,F
....................       crc = (crc << 8) ^ (i << 12) ^ (i <<5) ^ i;
02830:  MOVFF  697,6A0
02834:  CLRF   x9F
02836:  SWAPF  x95,W
02838:  MOVWF  03
0283A:  CLRF   02
0283C:  MOVLW  F0
0283E:  ANDWF  03,F
02840:  MOVF   02,W
02842:  XORWF  x9F,F
02844:  MOVF   03,W
02846:  XORWF  xA0,F
02848:  RLCF   x95,W
0284A:  MOVWF  02
0284C:  RLCF   x96,W
0284E:  MOVWF  03
02850:  RLCF   02,F
02852:  RLCF   03,F
02854:  RLCF   02,F
02856:  RLCF   03,F
02858:  RLCF   02,F
0285A:  RLCF   03,F
0285C:  RLCF   02,F
0285E:  RLCF   03,F
02860:  MOVLW  E0
02862:  ANDWF  02,F
02864:  MOVF   02,W
02866:  XORWF  x9F,F
02868:  MOVF   03,W
0286A:  XORWF  xA0,F
0286C:  MOVF   x9F,W
0286E:  XORWF  x95,W
02870:  MOVWF  x97
02872:  MOVF   xA0,W
02874:  XORWF  x96,W
02876:  MOVWF  x98
02878:  BRA    27EA
....................    }
....................    //fprintf(PC,"CRC: %LX\n",crc);
....................    //sprintf(convto_string, "<%lu>", crc);
....................    itoa(crc,16,crc_string);
0287A:  CLRF   xA2
0287C:  CLRF   xA1
0287E:  MOVFF  698,6A0
02882:  MOVFF  697,69F
02886:  MOVLW  10
02888:  MOVWF  xA3
0288A:  MOVLW  06
0288C:  MOVWF  xA5
0288E:  MOVLW  99
02890:  MOVWF  xA4
02892:  MOVLB  0
02894:  BRA    262A
....................    //strcpy(funcReturnVar,crc_string);
....................    //fprintf(PC,"string: %lu\n",crc);
.................... 
....................    return crc;
02896:  MOVLB  6
02898:  MOVFF  697,01
0289C:  MOVFF  698,02
028A0:  MOVLB  0
028A2:  RETURN 0
.................... }
.................... 
.................... //#include <arQ1010/voltageDetails.c>
.................... #include <arQ1010/rs485.c>
.................... #define RS485_DE PIN_E5
.................... #define RS485_RE PIN_E6
.................... 
.................... void disable485(){
....................    output_high(RS485_RE);
....................    output_low(RS485_DE);
.................... }
.................... 
.................... void writeToRS485(){
....................    output_high(RS485_RE);
....................    output_high(RS485_DE);
.................... }
....................    
.................... void readFromRS485(){
....................    output_low(RS485_RE);
....................    output_low(RS485_DE);
.................... }
.................... 
.................... 
.................... 
.................... #include <sensors/AS3935.c>
.................... 
.................... //////////////////////////////// the AS3935 file ///////////////////////////////
.................... 
.................... 
.................... // register access macros - register address, bitmask [ NOT Currently using these ]
.................... //!#define AS3935_AFE_GB      0x00, 0x3E
.................... //!#define AS3935_PWD      0x00, 0x01
.................... //!#define AS3935_NF_LEV      0x01, 0x70
.................... //!#define AS3935_WDTH      0x01, 0x0F
.................... //!#define AS3935_CL_STAT      0x02, 0x40
.................... //!#define AS3935_MIN_NUM_LIGH   0x02, 0x30
.................... //!#define AS3935_SREJ      0x02, 0x0F
.................... //!#define AS3935_LCO_FDIV   0x03, 0xC0
.................... //!#define AS3935_MASK_DIST   0x03, 0x20
.................... //!#define AS3935_INT      0x03, 0x0F
.................... //!#define AS3935_DISTANCE   0x07, 0x3F
.................... //!#define AS3935_DISP_LCO   0x08, 0x80
.................... //!#define AS3935_DISP_SRCO   0x08, 0x40
.................... //!#define AS3935_DISP_TRCO   0x08, 0x20
.................... //!#define AS3935_TUN_CAP      0x08, 0x0F
.................... 
.................... // other constants
.................... #define INDOOR 0x12
.................... #define OUTDOOR 0x0E
....................  
.................... 
.................... //!unsigned int8 tmp1;
.................... //int32 tmp2;
.................... //int16 message_count = 0;
.................... //int16 Total_Lightings_Detected = 0;
.................... //int1 InterruptFlag = 0;
.................... //unsigned int8 buffer;
.................... unsigned int8 interrupt_source;
.................... //char i;
.................... 
.................... //Func protos
.................... int1 Thunder_Init(void);
.................... void Thunder_Write(unsigned int8 address, unsigned int8 data1);
.................... unsigned int8 Thunder_Read(unsigned int8 address);
.................... int32 Thunder_Read_Energy(void);
.................... unsigned int16 Thunder_Read_distance(void);
.................... void ReadInternalData(void);
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Init()
.................... *
.................... * These are the same functions from the PIC32 example from Mikroe which works fine
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function Initializes Thunder chip
.................... * Input: register address, data
.................... * Output: Nothing
.................... *******************************************************************************/
.................... int1 Thunder_Init(void) {
.................... unsigned int8 temp;
.................... int i;
.................... int checker=0;
....................  
....................   output_high(EN1);              // Set CS to idle
.................... 
....................   Thunder_Write(0x3C, 0x96);           // set all registers in default mode
....................   delay_ms(3);
....................   
....................   Thunder_Write(0x3D, 0x96);           // calibrate internal oscillator
....................   delay_ms(3);
....................   
.................... //!  //CHecking of current configuration values.
.................... //!  for (i=0; i<=8;i++)
.................... //!   {temp = Thunder_Read(i);
.................... //!    fprintf(USB, "0x0%i: 0x%X\n", i, temp);
.................... //!    delay_ms(3);
.................... //!   
.................... //!   }
....................   
.................... //!  temp = Thunder_Read(0x00) & 0xC1;
.................... //!  fprintf(USB, "Ox00 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x00, ((OUTDOOR  << 1) | temp)); // set to INDOOR or OUTDOOR
....................   delay_ms(3);
....................   
.................... //!  temp = Thunder_Read(0x01) & 0x80;
.................... //!  fprintf(USB, "Ox01 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x01, 0x22 | temp);    // set NFL and WDTreshold 0x44
....................   delay_ms(3);
....................   
.................... //!  temp = Thunder_Read(0x02) & 0x80;    // clear statistics, min number of ligtning, spike rejection
.................... //!  fprintf(USB, "Ox02 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x02, 0xC2); //set minimum number of lightning per interrupt.  0XC2 for for 1, 0XD2 for 5 
....................   delay_ms(3);
....................   
.................... //!  temp = Thunder_Read(0x03) & 0x1F;   // Frequency division ratio(antenna),mask disturber, interrupt
.................... //!  fprintf(USB, "Ox03 temp: 0x%X\n",temp);
.................... //!  delay_ms(3);
....................   Thunder_Write(0x03, 0x00 | temp);
....................   delay_ms(3);
....................   
....................   Thunder_Write(0x08, 0x00);           // LCO, SRCO, TRCO on IRQ, capacitors tuning
....................   delay_ms(200);
....................   
.................... /*
....................   //Check of current configuration values.
....................   for (i=0; i<=8;i++)
....................    {temp = Thunder_Read(i);
....................     switch(i)
....................       {
....................       case 0: 
....................          if(temp==0x1C || temp==0x1D) //0x1D is powered down/reset.
....................             checker++;
....................          break;
....................       
....................       case 1: 
....................          if(temp==0x22)
....................             checker++;
....................          break;
....................          
....................       case 2: 
....................          if(temp==0xC2)
....................             checker++;
....................          break;   
....................          
....................       case 3:
....................          if(temp==0x00 || temp==0x01 || temp==0x02 || temp==0x04 || temp==0x08)
....................             checker++;
....................          break;
....................       
....................       case 7: 
....................          if(temp==0x3F||0x11)
....................             checker++;
....................          break;
....................          
....................       default:
....................          if(temp==0x00)
....................             checker++;
....................          break;
....................       }  
....................          
....................     //fprintf(USB, "0x0%i: 0x%X\n", i, temp);
....................     delay_ms(5);
....................    }
....................    
....................    //fprintf(USB, "checker: %i\n", checker);
....................    if (checker==9)
....................       {fprintf(USB, "AS3935 Initiatized\n");
....................        return TRUE;
....................       }
....................    else
....................       {fprintf(USB, "AS3935 Error\n");
....................        return FALSE;
....................       }
.................... */
....................   fprintf(USB, "AS3935 Ready\n");
.................... }
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Write(unsigned short address, unsigned short data1)
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function writes desired byte into specified register address
.................... * Input: register address, byte
.................... * Output: Nothing
.................... *******************************************************************************/
.................... void Thunder_Write(unsigned int8 address, unsigned int8 data1)  {
....................    
....................   bit_clear(address,7);       // set both bits 6&7 to 0 to do a write                       
....................   bit_clear(address,6); 
....................   output_low(EN1);     
....................   //delay_ms(10);
....................   spi_xfer(address);         // spi_write(address);
....................   spi_xfer(data1);          // spi_write(data1);
....................  //delay_ms(10);
....................   output_high(EN1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Read(unsigned short address)
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function reads byte from specified address
.................... * Input: register address
.................... * Output: desired byte
.................... *******************************************************************************/
.................... unsigned int8 Thunder_Read(unsigned int8 address) {
....................   unsigned int8 tmp = 0;
....................  
....................  // fprintf(USB, "add: 0X%X\n", address);
....................   bit_clear(address,7);      // set both bits 7 =0 and bit 6 = 1 to do a read 
....................   bit_set(address,6);
....................   
....................   output_low(EN1);
....................   spi_xfer(address);            //spi_write(address); 
....................   tmp = spi_xfer(0);        // spi read data; 
....................   //fprintf(USB, "tmp: 0X%X\n", tmp);
....................   output_high(EN1);
....................   return tmp;
.................... }
.................... 
.................... 
.................... 
.................... /*******************************************************************************
.................... * Function Thunder_Read_Energy()
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function reads energy of detected thunder
.................... * Input: Nothing
.................... * Output: Measured result
.................... *******************************************************************************/
.................... int32 Thunder_Read_Energy() {
....................   unsigned int8 low_byte, mid_byte;
....................   int32 Out_thunder_energy;
....................  
....................   Out_thunder_energy = Thunder_Read(0x06) & 0x1F;
....................   mid_byte = Thunder_Read(0x05);
....................   low_byte = Thunder_Read(0x04);
....................  
....................   Out_thunder_energy = (Out_thunder_energy << 8);
....................   Out_thunder_energy = (Out_thunder_energy | mid_byte);
....................   Out_thunder_energy = (Out_thunder_energy << 8);
....................   Out_thunder_energy = (Out_thunder_energy | low_byte);
....................  
....................   return Out_thunder_energy;
.................... }
....................  
....................  
.................... /*******************************************************************************
.................... * Function Thunder_Read_distance()
.................... * ------------------------------------------------------------------------------
.................... * Overview: Function reads distance from detected thunder
.................... * Input: Nothing
.................... * Output: Measured result
.................... *******************************************************************************/
.................... unsigned int16 Thunder_Read_distance() {
....................   int16 Out_thunder_distance;
....................  
....................   Out_thunder_distance = Thunder_Read(0x07) & 0x3F;
....................   //fprintf(USB, "dist1: %lu\n", Out_thunder_distance);
....................   
....................   return Out_thunder_distance;
.................... }
.................... 
.................... #include <sensors/BTD200.c>
.................... 
.................... //#use rs232 (baud=9600, parity=e, bits=8, stop=1, xmit=PIN_E4, rcv=PIN_E7, stream=RS485_GDAT1)
.................... //char strBTD[100]={};
.................... //#use rs232(baud=57600, xmit=PIN_G4, rcv=PIN_G3, stream=RS232_BTD200)
.................... //#use rs232(baud=57600, xmit=TX_USB, rcv=RX_USB, stream=USB)
.................... 
....................  char message[255]={};
.................... 
.................... void btdStatus(w){
....................    //char recon;
....................   
....................    switch (w){
*
02C58:  MOVLB  6
02C5A:  MOVF   x62,W
02C5C:  XORLW  01
02C5E:  MOVLB  0
02C60:  BZ    2C7C
02C62:  XORLW  03
02C64:  BTFSC  FD8.2
02C66:  BRA    2E06
02C68:  XORLW  01
02C6A:  BTFSC  FD8.2
02C6C:  BRA    2F1C
02C6E:  XORLW  07
02C70:  BTFSC  FD8.2
02C72:  BRA    3032
02C74:  XORLW  01
02C76:  BTFSC  FD8.2
02C78:  BRA    3148
02C7A:  BRA    3260
....................       case 1:
....................          fprintf(USB,"\nLightning Detected!!!\n******************************************************************************************************************************************************");
02C7C:  MOVLW  20
02C7E:  MOVWF  FF6
02C80:  MOVLW  0C
02C82:  MOVWF  FF7
02C84:  MOVLW  00
02C86:  MOVWF  FF8
02C88:  CALL   0F40
....................          sprintf(message, "FC:%s+%sGS:*+BT:%s+DT:*\r", flashCount, BTDLaLo, biralBT); 
02C8C:  MOVLW  04
02C8E:  MOVLB  4
02C90:  MOVWF  x90
02C92:  MOVLW  93
02C94:  MOVWF  x8F
02C96:  MOVLW  CE
02C98:  MOVWF  FF6
02C9A:  MOVLW  0C
02C9C:  MOVWF  FF7
02C9E:  MOVLW  00
02CA0:  MOVWF  FF8
02CA2:  MOVLW  03
02CA4:  MOVLB  6
02CA6:  MOVWF  xB0
02CA8:  MOVLB  0
02CAA:  CALL   1C10
02CAE:  MOVFF  490,FEA
02CB2:  MOVFF  48F,FE9
02CB6:  CLRF   FEF
02CB8:  MOVLW  04
02CBA:  MOVWF  FEA
02CBC:  MOVLW  4F
02CBE:  MOVWF  FE9
02CC0:  CALL   1C42
02CC4:  MOVLW  2B
02CC6:  MOVLB  6
02CC8:  MOVWF  xBD
02CCA:  MOVLB  0
02CCC:  CALL   0FC6
02CD0:  MOVFF  490,FEA
02CD4:  MOVFF  48F,FE9
02CD8:  CLRF   FEF
02CDA:  MOVLW  03
02CDC:  MOVWF  FEA
02CDE:  MOVLW  AF
02CE0:  MOVWF  FE9
02CE2:  CALL   1C42
02CE6:  MOVLW  D6
02CE8:  MOVWF  FF6
02CEA:  MOVLW  0C
02CEC:  MOVWF  FF7
02CEE:  MOVLW  00
02CF0:  MOVWF  FF8
02CF2:  MOVLW  08
02CF4:  MOVLB  6
02CF6:  MOVWF  xB0
02CF8:  MOVLB  0
02CFA:  CALL   1C10
02CFE:  MOVFF  490,FEA
02D02:  MOVFF  48F,FE9
02D06:  CLRF   FEF
02D08:  MOVLW  03
02D0A:  MOVWF  FEA
02D0C:  MOVLW  9B
02D0E:  MOVWF  FE9
02D10:  CALL   1C42
02D14:  MOVLW  E0
02D16:  MOVWF  FF6
02D18:  MOVLW  0C
02D1A:  MOVWF  FF7
02D1C:  MOVLW  00
02D1E:  MOVWF  FF8
02D20:  MOVLW  06
02D22:  MOVLB  6
02D24:  MOVWF  xB0
02D26:  MOVLB  0
02D28:  CALL   1C10
....................          fprintf(USB, "SMS to Sent: %s", message);
02D2C:  MOVLW  E8
02D2E:  MOVWF  FF6
02D30:  MOVLW  0C
02D32:  MOVWF  FF7
02D34:  MOVLW  00
02D36:  MOVWF  FF8
02D38:  MOVLW  0D
02D3A:  MOVLB  6
02D3C:  MOVWF  x91
02D3E:  MOVLB  0
02D40:  CALL   1080
02D44:  MOVLW  04
02D46:  MOVWF  FEA
02D48:  MOVLW  93
02D4A:  MOVWF  FE9
02D4C:  CALL   10B4
....................          sendToLTE(message);
02D50:  MOVLW  04
02D52:  MOVLB  6
02D54:  MOVWF  x6A
02D56:  MOVLW  93
02D58:  MOVWF  x69
02D5A:  MOVLB  0
02D5C:  CALL   20A6
....................          strcpy(BTDLaLo, "");   
02D60:  MOVLW  03
02D62:  MOVWF  FEA
02D64:  MOVLW  AF
02D66:  MOVWF  FE9
02D68:  MOVLW  00
02D6A:  CALL   00EE
02D6E:  TBLRD*-
02D70:  TBLRD*+
02D72:  MOVF   FF5,W
02D74:  MOVWF  FEE
02D76:  IORLW  00
02D78:  BNZ   2D70
....................          
....................          getMcuDateTime();
02D7A:  CALL   1A76
....................          strcpy(biralBT, strDateTime);
02D7E:  MOVLW  03
02D80:  MOVWF  FEA
02D82:  MOVLW  9B
02D84:  MOVWF  FE9
02D86:  MOVLW  03
02D88:  MOVWF  FE2
02D8A:  MOVLW  87
02D8C:  MOVWF  FE1
02D8E:  MOVF   FE7,F
02D90:  MOVFF  FE6,FEE
02D94:  BNZ   2D8E
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
02D96:  MOVLW  F8
02D98:  MOVWF  FF6
02D9A:  MOVLW  0C
02D9C:  MOVWF  FF7
02D9E:  MOVLW  00
02DA0:  MOVWF  FF8
02DA2:  MOVLW  0B
02DA4:  MOVLB  6
02DA6:  MOVWF  x91
02DA8:  MOVLB  0
02DAA:  CALL   1080
02DAE:  MOVLW  03
02DB0:  MOVWF  FEA
02DB2:  MOVLW  9B
02DB4:  MOVWF  FE9
02DB6:  CALL   10B4
02DBA:  MOVLW  0A
02DBC:  BTFSS  FA4.4
02DBE:  BRA    2DBC
02DC0:  MOVLB  F
02DC2:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02DC4:  MOVLW  03
02DC6:  MOVWF  FEA
02DC8:  MOVLW  87
02DCA:  MOVWF  FE9
02DCC:  MOVLW  00
02DCE:  MOVLB  0
02DD0:  CALL   00EE
02DD4:  TBLRD*-
02DD6:  TBLRD*+
02DD8:  MOVF   FF5,W
02DDA:  MOVWF  FEE
02DDC:  IORLW  00
02DDE:  BNZ   2DD6
....................          strcpy(biralBT, ""); 
02DE0:  MOVLW  03
02DE2:  MOVWF  FEA
02DE4:  MOVLW  9B
02DE6:  MOVWF  FE9
02DE8:  MOVLW  00
02DEA:  CALL   00EE
02DEE:  TBLRD*-
02DF0:  TBLRD*+
02DF2:  MOVF   FF5,W
02DF4:  MOVWF  FEE
02DF6:  IORLW  00
02DF8:  BNZ   2DF0
....................          
....................          fprintf(USB, "\n");
02DFA:  MOVLW  0A
02DFC:  BTFSS  FA4.4
02DFE:  BRA    2DFC
02E00:  MOVLB  F
02E02:  MOVWF  x1C
....................          break;
02E04:  BRA    3262
....................       
....................       case 2:
....................          //fprintf(USB, "\nTest switch"); 
....................          strcpy(strBTD_con, "BTDrecon\r");
02E06:  MOVLW  04
02E08:  MOVWF  FEA
02E0A:  MOVLW  59
02E0C:  MOVWF  FE9
02E0E:  MOVLW  00
02E10:  CALL   0136
02E14:  TBLRD*-
02E16:  TBLRD*+
02E18:  MOVF   FF5,W
02E1A:  MOVWF  FEE
02E1C:  IORLW  00
02E1E:  BNZ   2E16
....................          sprintf(message, "%s", strBTD_con); 
02E20:  MOVLW  04
02E22:  MOVLB  4
02E24:  MOVWF  x90
02E26:  MOVLW  93
02E28:  MOVWF  x8F
02E2A:  MOVFF  490,FEA
02E2E:  MOVFF  48F,FE9
02E32:  CLRF   FEF
02E34:  MOVLW  04
02E36:  MOVWF  FEA
02E38:  MOVLW  59
02E3A:  MOVWF  FE9
02E3C:  MOVLB  0
02E3E:  CALL   1C42
....................          fprintf(USB, "SMS to Sent: %s", message);
02E42:  MOVLW  08
02E44:  MOVWF  FF6
02E46:  MOVLW  0D
02E48:  MOVWF  FF7
02E4A:  MOVLW  00
02E4C:  MOVWF  FF8
02E4E:  MOVLW  0D
02E50:  MOVLB  6
02E52:  MOVWF  x91
02E54:  MOVLB  0
02E56:  CALL   1080
02E5A:  MOVLW  04
02E5C:  MOVWF  FEA
02E5E:  MOVLW  93
02E60:  MOVWF  FE9
02E62:  CALL   10B4
....................          sendToLTE(message);
02E66:  MOVLW  04
02E68:  MOVLB  6
02E6A:  MOVWF  x6A
02E6C:  MOVLW  93
02E6E:  MOVWF  x69
02E70:  MOVLB  0
02E72:  CALL   20A6
....................          strcpy(strBTD_con, "");
02E76:  MOVLW  04
02E78:  MOVWF  FEA
02E7A:  MOVLW  59
02E7C:  MOVWF  FE9
02E7E:  MOVLW  00
02E80:  CALL   00EE
02E84:  TBLRD*-
02E86:  TBLRD*+
02E88:  MOVF   FF5,W
02E8A:  MOVWF  FEE
02E8C:  IORLW  00
02E8E:  BNZ   2E86
....................          
....................          getMcuDateTime();
02E90:  CALL   1A76
....................          strcpy(biralBT, strDateTime);
02E94:  MOVLW  03
02E96:  MOVWF  FEA
02E98:  MOVLW  9B
02E9A:  MOVWF  FE9
02E9C:  MOVLW  03
02E9E:  MOVWF  FE2
02EA0:  MOVLW  87
02EA2:  MOVWF  FE1
02EA4:  MOVF   FE7,F
02EA6:  MOVFF  FE6,FEE
02EAA:  BNZ   2EA4
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
02EAC:  MOVLW  18
02EAE:  MOVWF  FF6
02EB0:  MOVLW  0D
02EB2:  MOVWF  FF7
02EB4:  MOVLW  00
02EB6:  MOVWF  FF8
02EB8:  MOVLW  0B
02EBA:  MOVLB  6
02EBC:  MOVWF  x91
02EBE:  MOVLB  0
02EC0:  CALL   1080
02EC4:  MOVLW  03
02EC6:  MOVWF  FEA
02EC8:  MOVLW  9B
02ECA:  MOVWF  FE9
02ECC:  CALL   10B4
02ED0:  MOVLW  0A
02ED2:  BTFSS  FA4.4
02ED4:  BRA    2ED2
02ED6:  MOVLB  F
02ED8:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02EDA:  MOVLW  03
02EDC:  MOVWF  FEA
02EDE:  MOVLW  87
02EE0:  MOVWF  FE9
02EE2:  MOVLW  00
02EE4:  MOVLB  0
02EE6:  CALL   00EE
02EEA:  TBLRD*-
02EEC:  TBLRD*+
02EEE:  MOVF   FF5,W
02EF0:  MOVWF  FEE
02EF2:  IORLW  00
02EF4:  BNZ   2EEC
....................          strcpy(biralBT, ""); 
02EF6:  MOVLW  03
02EF8:  MOVWF  FEA
02EFA:  MOVLW  9B
02EFC:  MOVWF  FE9
02EFE:  MOVLW  00
02F00:  CALL   00EE
02F04:  TBLRD*-
02F06:  TBLRD*+
02F08:  MOVF   FF5,W
02F0A:  MOVWF  FEE
02F0C:  IORLW  00
02F0E:  BNZ   2F06
....................          
....................          fprintf(USB, "\n");
02F10:  MOVLW  0A
02F12:  BTFSS  FA4.4
02F14:  BRA    2F12
02F16:  MOVLB  F
02F18:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;  
02F1A:  BRA    3262
....................          
....................       case 3:
....................          strcpy(strBTD_con, "BTDcon\r");
02F1C:  MOVLW  04
02F1E:  MOVWF  FEA
02F20:  MOVLW  59
02F22:  MOVWF  FE9
02F24:  MOVLW  00
02F26:  CALL   0154
02F2A:  TBLRD*-
02F2C:  TBLRD*+
02F2E:  MOVF   FF5,W
02F30:  MOVWF  FEE
02F32:  IORLW  00
02F34:  BNZ   2F2C
....................          sprintf(message, "%s", strBTD_con); 
02F36:  MOVLW  04
02F38:  MOVLB  4
02F3A:  MOVWF  x90
02F3C:  MOVLW  93
02F3E:  MOVWF  x8F
02F40:  MOVFF  490,FEA
02F44:  MOVFF  48F,FE9
02F48:  CLRF   FEF
02F4A:  MOVLW  04
02F4C:  MOVWF  FEA
02F4E:  MOVLW  59
02F50:  MOVWF  FE9
02F52:  MOVLB  0
02F54:  CALL   1C42
....................          fprintf(USB, "SMS to Sent: %s", message);
02F58:  MOVLW  28
02F5A:  MOVWF  FF6
02F5C:  MOVLW  0D
02F5E:  MOVWF  FF7
02F60:  MOVLW  00
02F62:  MOVWF  FF8
02F64:  MOVLW  0D
02F66:  MOVLB  6
02F68:  MOVWF  x91
02F6A:  MOVLB  0
02F6C:  CALL   1080
02F70:  MOVLW  04
02F72:  MOVWF  FEA
02F74:  MOVLW  93
02F76:  MOVWF  FE9
02F78:  CALL   10B4
....................          sendToLTE(message);
02F7C:  MOVLW  04
02F7E:  MOVLB  6
02F80:  MOVWF  x6A
02F82:  MOVLW  93
02F84:  MOVWF  x69
02F86:  MOVLB  0
02F88:  CALL   20A6
....................          strcpy(strBTD_con, "");
02F8C:  MOVLW  04
02F8E:  MOVWF  FEA
02F90:  MOVLW  59
02F92:  MOVWF  FE9
02F94:  MOVLW  00
02F96:  CALL   00EE
02F9A:  TBLRD*-
02F9C:  TBLRD*+
02F9E:  MOVF   FF5,W
02FA0:  MOVWF  FEE
02FA2:  IORLW  00
02FA4:  BNZ   2F9C
....................          
....................          getMcuDateTime();
02FA6:  CALL   1A76
....................          strcpy(biralBT, strDateTime);
02FAA:  MOVLW  03
02FAC:  MOVWF  FEA
02FAE:  MOVLW  9B
02FB0:  MOVWF  FE9
02FB2:  MOVLW  03
02FB4:  MOVWF  FE2
02FB6:  MOVLW  87
02FB8:  MOVWF  FE1
02FBA:  MOVF   FE7,F
02FBC:  MOVFF  FE6,FEE
02FC0:  BNZ   2FBA
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
02FC2:  MOVLW  38
02FC4:  MOVWF  FF6
02FC6:  MOVLW  0D
02FC8:  MOVWF  FF7
02FCA:  MOVLW  00
02FCC:  MOVWF  FF8
02FCE:  MOVLW  0B
02FD0:  MOVLB  6
02FD2:  MOVWF  x91
02FD4:  MOVLB  0
02FD6:  CALL   1080
02FDA:  MOVLW  03
02FDC:  MOVWF  FEA
02FDE:  MOVLW  9B
02FE0:  MOVWF  FE9
02FE2:  CALL   10B4
02FE6:  MOVLW  0A
02FE8:  BTFSS  FA4.4
02FEA:  BRA    2FE8
02FEC:  MOVLB  F
02FEE:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
02FF0:  MOVLW  03
02FF2:  MOVWF  FEA
02FF4:  MOVLW  87
02FF6:  MOVWF  FE9
02FF8:  MOVLW  00
02FFA:  MOVLB  0
02FFC:  CALL   00EE
03000:  TBLRD*-
03002:  TBLRD*+
03004:  MOVF   FF5,W
03006:  MOVWF  FEE
03008:  IORLW  00
0300A:  BNZ   3002
....................          strcpy(biralBT, ""); 
0300C:  MOVLW  03
0300E:  MOVWF  FEA
03010:  MOVLW  9B
03012:  MOVWF  FE9
03014:  MOVLW  00
03016:  CALL   00EE
0301A:  TBLRD*-
0301C:  TBLRD*+
0301E:  MOVF   FF5,W
03020:  MOVWF  FEE
03022:  IORLW  00
03024:  BNZ   301C
....................          
....................          fprintf(USB, "\n");
03026:  MOVLW  0A
03028:  BTFSS  FA4.4
0302A:  BRA    3028
0302C:  MOVLB  F
0302E:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;
03030:  BRA    3262
....................          
....................      case 4:
....................          strcpy(strBTD_con, "BTDstable\r");
03032:  MOVLW  04
03034:  MOVWF  FEA
03036:  MOVLW  59
03038:  MOVWF  FE9
0303A:  MOVLW  00
0303C:  CALL   0170
03040:  TBLRD*-
03042:  TBLRD*+
03044:  MOVF   FF5,W
03046:  MOVWF  FEE
03048:  IORLW  00
0304A:  BNZ   3042
....................          sprintf(message, "%s", strBTD_con); 
0304C:  MOVLW  04
0304E:  MOVLB  4
03050:  MOVWF  x90
03052:  MOVLW  93
03054:  MOVWF  x8F
03056:  MOVFF  490,FEA
0305A:  MOVFF  48F,FE9
0305E:  CLRF   FEF
03060:  MOVLW  04
03062:  MOVWF  FEA
03064:  MOVLW  59
03066:  MOVWF  FE9
03068:  MOVLB  0
0306A:  CALL   1C42
....................          fprintf(USB, "SMS to Sent: %s", message);
0306E:  MOVLW  48
03070:  MOVWF  FF6
03072:  MOVLW  0D
03074:  MOVWF  FF7
03076:  MOVLW  00
03078:  MOVWF  FF8
0307A:  MOVLW  0D
0307C:  MOVLB  6
0307E:  MOVWF  x91
03080:  MOVLB  0
03082:  CALL   1080
03086:  MOVLW  04
03088:  MOVWF  FEA
0308A:  MOVLW  93
0308C:  MOVWF  FE9
0308E:  CALL   10B4
....................          sendToLTE(message);
03092:  MOVLW  04
03094:  MOVLB  6
03096:  MOVWF  x6A
03098:  MOVLW  93
0309A:  MOVWF  x69
0309C:  MOVLB  0
0309E:  CALL   20A6
....................          strcpy(strBTD_con, "");
030A2:  MOVLW  04
030A4:  MOVWF  FEA
030A6:  MOVLW  59
030A8:  MOVWF  FE9
030AA:  MOVLW  00
030AC:  CALL   00EE
030B0:  TBLRD*-
030B2:  TBLRD*+
030B4:  MOVF   FF5,W
030B6:  MOVWF  FEE
030B8:  IORLW  00
030BA:  BNZ   30B2
....................                   
....................          getMcuDateTime();
030BC:  CALL   1A76
....................          strcpy(biralBT, strDateTime);
030C0:  MOVLW  03
030C2:  MOVWF  FEA
030C4:  MOVLW  9B
030C6:  MOVWF  FE9
030C8:  MOVLW  03
030CA:  MOVWF  FE2
030CC:  MOVLW  87
030CE:  MOVWF  FE1
030D0:  MOVF   FE7,F
030D2:  MOVFF  FE6,FEE
030D6:  BNZ   30D0
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
030D8:  MOVLW  58
030DA:  MOVWF  FF6
030DC:  MOVLW  0D
030DE:  MOVWF  FF7
030E0:  MOVLW  00
030E2:  MOVWF  FF8
030E4:  MOVLW  0B
030E6:  MOVLB  6
030E8:  MOVWF  x91
030EA:  MOVLB  0
030EC:  CALL   1080
030F0:  MOVLW  03
030F2:  MOVWF  FEA
030F4:  MOVLW  9B
030F6:  MOVWF  FE9
030F8:  CALL   10B4
030FC:  MOVLW  0A
030FE:  BTFSS  FA4.4
03100:  BRA    30FE
03102:  MOVLB  F
03104:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
03106:  MOVLW  03
03108:  MOVWF  FEA
0310A:  MOVLW  87
0310C:  MOVWF  FE9
0310E:  MOVLW  00
03110:  MOVLB  0
03112:  CALL   00EE
03116:  TBLRD*-
03118:  TBLRD*+
0311A:  MOVF   FF5,W
0311C:  MOVWF  FEE
0311E:  IORLW  00
03120:  BNZ   3118
....................          strcpy(biralBT, ""); 
03122:  MOVLW  03
03124:  MOVWF  FEA
03126:  MOVLW  9B
03128:  MOVWF  FE9
0312A:  MOVLW  00
0312C:  CALL   00EE
03130:  TBLRD*-
03132:  TBLRD*+
03134:  MOVF   FF5,W
03136:  MOVWF  FEE
03138:  IORLW  00
0313A:  BNZ   3132
....................          
....................          fprintf(USB, "\n");
0313C:  MOVLW  0A
0313E:  BTFSS  FA4.4
03140:  BRA    313E
03142:  MOVLB  F
03144:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;
03146:  BRA    3262
....................          
....................       case 5:
....................          strcpy(strBTD_con, "BTDcon\r");
03148:  MOVLW  04
0314A:  MOVWF  FEA
0314C:  MOVLW  59
0314E:  MOVWF  FE9
03150:  MOVLW  00
03152:  CALL   0154
03156:  TBLRD*-
03158:  TBLRD*+
0315A:  MOVF   FF5,W
0315C:  MOVWF  FEE
0315E:  IORLW  00
03160:  BNZ   3158
....................          sprintf(message, "%s", strBTD_con); 
03162:  MOVLW  04
03164:  MOVLB  4
03166:  MOVWF  x90
03168:  MOVLW  93
0316A:  MOVWF  x8F
0316C:  MOVFF  490,FEA
03170:  MOVFF  48F,FE9
03174:  CLRF   FEF
03176:  MOVLW  04
03178:  MOVWF  FEA
0317A:  MOVLW  59
0317C:  MOVWF  FE9
0317E:  MOVLB  0
03180:  CALL   1C42
....................          fprintf(USB, "SMS to Sent: %s", message);
03184:  MOVLW  68
03186:  MOVWF  FF6
03188:  MOVLW  0D
0318A:  MOVWF  FF7
0318C:  MOVLW  00
0318E:  MOVWF  FF8
03190:  MOVLW  0D
03192:  MOVLB  6
03194:  MOVWF  x91
03196:  MOVLB  0
03198:  CALL   1080
0319C:  MOVLW  04
0319E:  MOVWF  FEA
031A0:  MOVLW  93
031A2:  MOVWF  FE9
031A4:  CALL   10B4
....................          sendToLTE(message);
031A8:  MOVLW  04
031AA:  MOVLB  6
031AC:  MOVWF  x6A
031AE:  MOVLW  93
031B0:  MOVWF  x69
031B2:  MOVLB  0
031B4:  CALL   20A6
....................          strcpy(strBTD_con, "");
031B8:  MOVLW  04
031BA:  MOVWF  FEA
031BC:  MOVLW  59
031BE:  MOVWF  FE9
031C0:  MOVLW  00
031C2:  CALL   00EE
031C6:  TBLRD*-
031C8:  TBLRD*+
031CA:  MOVF   FF5,W
031CC:  MOVWF  FEE
031CE:  IORLW  00
031D0:  BNZ   31C8
....................            
....................          
....................          getMcuDateTime();
031D2:  CALL   1A76
....................          strcpy(biralBT, strDateTime);
031D6:  MOVLW  03
031D8:  MOVWF  FEA
031DA:  MOVLW  9B
031DC:  MOVWF  FE9
031DE:  MOVLW  03
031E0:  MOVWF  FE2
031E2:  MOVLW  87
031E4:  MOVWF  FE1
031E6:  MOVF   FE7,F
031E8:  MOVFF  FE6,FEE
031EC:  BNZ   31E6
....................          fprintf(USB, "Date-Time: %s\n", biralBT);
031EE:  MOVLW  78
031F0:  MOVWF  FF6
031F2:  MOVLW  0D
031F4:  MOVWF  FF7
031F6:  MOVLW  00
031F8:  MOVWF  FF8
031FA:  MOVLW  0B
031FC:  MOVLB  6
031FE:  MOVWF  x91
03200:  MOVLB  0
03202:  CALL   1080
03206:  MOVLW  03
03208:  MOVWF  FEA
0320A:  MOVLW  9B
0320C:  MOVWF  FE9
0320E:  CALL   10B4
03212:  MOVLW  0A
03214:  BTFSS  FA4.4
03216:  BRA    3214
03218:  MOVLB  F
0321A:  MOVWF  x1C
....................          
....................          strcpy(strDateTime, ""); 
0321C:  MOVLW  03
0321E:  MOVWF  FEA
03220:  MOVLW  87
03222:  MOVWF  FE9
03224:  MOVLW  00
03226:  MOVLB  0
03228:  CALL   00EE
0322C:  TBLRD*-
0322E:  TBLRD*+
03230:  MOVF   FF5,W
03232:  MOVWF  FEE
03234:  IORLW  00
03236:  BNZ   322E
....................          strcpy(biralBT, ""); 
03238:  MOVLW  03
0323A:  MOVWF  FEA
0323C:  MOVLW  9B
0323E:  MOVWF  FE9
03240:  MOVLW  00
03242:  CALL   00EE
03246:  TBLRD*-
03248:  TBLRD*+
0324A:  MOVF   FF5,W
0324C:  MOVWF  FEE
0324E:  IORLW  00
03250:  BNZ   3248
....................          
....................          fprintf(USB, "\n");
03252:  MOVLW  0A
03254:  BTFSS  FA4.4
03256:  BRA    3254
03258:  MOVLB  F
0325A:  MOVWF  x1C
....................          //fprintf(USB, "\nTest end of switch"); 
....................          break;   
0325C:  BRA    3262
0325E:  MOVLB  0
....................          
....................       default:
....................          break;    
03260:  MOVLB  F
....................    }
....................    fprintf(USB, "\n"); 
03262:  MOVLW  0A
03264:  BTFSS  FA4.4
03266:  BRA    3264
03268:  MOVWF  x1C
0326A:  MOVLB  0
0326C:  RETURN 0
.................... } 
.................... 
.................... 
.................... int readData(a, b, c, d, e, f){
....................    int sendResponse;
....................    //fprintf(USB, "\nTest readeData"); 
....................    
....................    if (a==0x0a && b==0x00 && c==0x20 && d==0x00 && e==0x21){
*
02112:  MOVLB  6
02114:  MOVF   x62,W
02116:  SUBLW  0A
02118:  BNZ   2134
0211A:  MOVF   x63,F
0211C:  BNZ   2134
0211E:  MOVF   x64,W
02120:  SUBLW  20
02122:  BNZ   2134
02124:  MOVF   x65,F
02126:  BNZ   2134
02128:  MOVF   x66,W
0212A:  SUBLW  21
0212C:  BNZ   2134
....................       
....................       //fprintf(USB, "\n\nBTD Request to Connect: ");
....................       //getMcuDateTime();
....................       //fprintf(USB, "\nBTD Requesting to Connect");
....................       sendResponse = 1;
0212E:  MOVLW  01
02130:  MOVWF  x68
....................       break;
....................    }
02132:  BRA    22DE
....................    
....................    else if (a==0x10 && b==0x00 && c==0x20 && d==0x00 && e==0x01){ 
02134:  MOVF   x62,W
02136:  SUBLW  10
02138:  BNZ   217A
0213A:  MOVF   x63,F
0213C:  BNZ   217A
0213E:  MOVF   x64,W
02140:  SUBLW  20
02142:  BNZ   217A
02144:  MOVF   x65,F
02146:  BNZ   217A
02148:  DECFSZ x66,W
0214A:  BRA    217A
....................       fprintf(USB, "\n");
0214C:  MOVLW  0A
0214E:  BTFSS  FA4.4
02150:  BRA    214E
02152:  MOVLB  F
02154:  MOVWF  x1C
....................       strcpy(btdCode, "RMS*");
02156:  MOVLW  04
02158:  MOVWF  FEA
0215A:  MOVLW  77
0215C:  MOVWF  FE9
0215E:  MOVLW  00
02160:  MOVLB  0
02162:  CALL   0190
02166:  TBLRD*-
02168:  TBLRD*+
0216A:  MOVF   FF5,W
0216C:  MOVWF  FEE
0216E:  IORLW  00
02170:  BNZ   2168
....................       //fprintf(USB, "\n\nBTD Request Module Status: ");
....................       sendResponse = 2;
02172:  MOVLW  02
02174:  MOVLB  6
02176:  MOVWF  x68
....................       break;
....................    }
02178:  BRA    22DE
....................    
....................    else if (a==0x37 && b==0x00 && c==0x20 && d==0x00 && e==0x02){
0217A:  MOVF   x62,W
0217C:  SUBLW  37
0217E:  BNZ   219A
02180:  MOVF   x63,F
02182:  BNZ   219A
02184:  MOVF   x64,W
02186:  SUBLW  20
02188:  BNZ   219A
0218A:  MOVF   x65,F
0218C:  BNZ   219A
0218E:  MOVF   x66,W
02190:  SUBLW  02
02192:  BNZ   219A
....................       
....................       //fprintf(USB, "\n\nBTD System Status Message - Maintenance Mode: ");
....................       sendResponse = 3;
02194:  MOVLW  03
02196:  MOVWF  x68
....................       break;
....................    }
02198:  BRA    22DE
....................    
....................    else if (a==0x27 && b==0x00 && c==0x20 && d==0x00 && e==0x03){
0219A:  MOVF   x62,W
0219C:  SUBLW  27
0219E:  BNZ   21D8
021A0:  MOVF   x63,F
021A2:  BNZ   21D8
021A4:  MOVF   x64,W
021A6:  SUBLW  20
021A8:  BNZ   21D8
021AA:  MOVF   x65,F
021AC:  BNZ   21D8
021AE:  MOVF   x66,W
021B0:  SUBLW  03
021B2:  BNZ   21D8
....................       //fprintf(USB, "\n\nBTD No Flash Data Message: ");
....................       strcpy(btdCode, "NFD*");
021B4:  MOVLW  04
021B6:  MOVWF  FEA
021B8:  MOVLW  77
021BA:  MOVWF  FE9
021BC:  MOVLW  00
021BE:  MOVLB  0
021C0:  CALL   01AA
021C4:  TBLRD*-
021C6:  TBLRD*+
021C8:  MOVF   FF5,W
021CA:  MOVWF  FEE
021CC:  IORLW  00
021CE:  BNZ   21C6
....................       sendResponse = 3;
021D0:  MOVLW  03
021D2:  MOVLB  6
021D4:  MOVWF  x68
....................       break;
....................    }
021D6:  BRA    22DE
....................    
....................    else if (a==0x10 && b==0x00 && c==0x20 && d==0x00 && e==0x0f){
021D8:  MOVF   x62,W
021DA:  SUBLW  10
021DC:  BNZ   2220
021DE:  MOVF   x63,F
021E0:  BNZ   2220
021E2:  MOVF   x64,W
021E4:  SUBLW  20
021E6:  BNZ   2220
021E8:  MOVF   x65,F
021EA:  BNZ   2220
021EC:  MOVF   x66,W
021EE:  SUBLW  0F
021F0:  BNZ   2220
....................       //fprintf(USB, "\n\nBTD Change in Relay Status: ");
....................       fprintf(USB, "\n");
021F2:  MOVLW  0A
021F4:  BTFSS  FA4.4
021F6:  BRA    21F4
021F8:  MOVLB  F
021FA:  MOVWF  x1C
....................       strcpy(btdCode, "CRS*");
021FC:  MOVLW  04
021FE:  MOVWF  FEA
02200:  MOVLW  77
02202:  MOVWF  FE9
02204:  MOVLW  00
02206:  MOVLB  0
02208:  CALL   01C4
0220C:  TBLRD*-
0220E:  TBLRD*+
02210:  MOVF   FF5,W
02212:  MOVWF  FEE
02214:  IORLW  00
02216:  BNZ   220E
....................       sendResponse = 3;
02218:  MOVLW  03
0221A:  MOVLB  6
0221C:  MOVWF  x68
....................       break;
....................    }
0221E:  BRA    22DE
.................... 
....................    else if (a==0x57 && b==0x00 && c==0x20 && d==0x00 && e==0x04){
02220:  MOVF   x62,W
02222:  SUBLW  57
02224:  BNZ   2240
02226:  MOVF   x63,F
02228:  BNZ   2240
0222A:  MOVF   x64,W
0222C:  SUBLW  20
0222E:  BNZ   2240
02230:  MOVF   x65,F
02232:  BNZ   2240
02234:  MOVF   x66,W
02236:  SUBLW  04
02238:  BNZ   2240
....................       //fprintf(USB, "\n\nBTD Flash Data Message: ");
....................       sendResponse = 3;
0223A:  MOVLW  03
0223C:  MOVWF  x68
....................       break;
....................    }
0223E:  BRA    22DE
....................    
....................    else if (a==0x12 && b==0x00 && c==0x20 && d==0x00 && e==0x05){
02240:  MOVF   x62,W
02242:  SUBLW  12
02244:  BNZ   2288
02246:  MOVF   x63,F
02248:  BNZ   2288
0224A:  MOVF   x64,W
0224C:  SUBLW  20
0224E:  BNZ   2288
02250:  MOVF   x65,F
02252:  BNZ   2288
02254:  MOVF   x66,W
02256:  SUBLW  05
02258:  BNZ   2288
....................       //fprintf(USB, "\n\nBTD Change in Warning Status: ");
....................       fprintf(USB, "\n");
0225A:  MOVLW  0A
0225C:  BTFSS  FA4.4
0225E:  BRA    225C
02260:  MOVLB  F
02262:  MOVWF  x1C
....................       strcpy(btdCode, "CWS*");
02264:  MOVLW  04
02266:  MOVWF  FEA
02268:  MOVLW  77
0226A:  MOVWF  FE9
0226C:  MOVLW  00
0226E:  MOVLB  0
02270:  CALL   01DE
02274:  TBLRD*-
02276:  TBLRD*+
02278:  MOVF   FF5,W
0227A:  MOVWF  FEE
0227C:  IORLW  00
0227E:  BNZ   2276
....................       sendResponse = 3;
02280:  MOVLW  03
02282:  MOVLB  6
02284:  MOVWF  x68
....................       break;
....................    }
02286:  BRA    22DE
....................    
....................    else if (a==0x3f && b==0x00 && c==0x20 && d==0x00 && e==0x06){
02288:  MOVF   x62,W
0228A:  SUBLW  3F
0228C:  BNZ   22A4
0228E:  MOVF   x63,F
02290:  BNZ   22A4
02292:  MOVF   x64,W
02294:  SUBLW  20
02296:  BNZ   22A4
02298:  MOVF   x65,F
0229A:  BNZ   22A4
0229C:  MOVF   x66,W
0229E:  SUBLW  06
022A0:  BNZ   22A4
....................       //fprintf(USB, "\nBTD Configuration Message: ");
....................       break;
....................    }
022A2:  BRA    22DE
....................    
....................    else if (a==0x16 && b==0x00 && c==0x20 && d==0x00 && e==0x07){
022A4:  MOVF   x62,W
022A6:  SUBLW  16
022A8:  BNZ   22C0
022AA:  MOVF   x63,F
022AC:  BNZ   22C0
022AE:  MOVF   x64,W
022B0:  SUBLW  20
022B2:  BNZ   22C0
022B4:  MOVF   x65,F
022B6:  BNZ   22C0
022B8:  MOVF   x66,W
022BA:  SUBLW  07
022BC:  BNZ   22C0
....................       //fprintf(USB, "\nBTD Acknowledge Data: ");
....................       break;
....................    }
022BE:  BRA    22DE
.................... 
....................    else if (a==0x16 && b==0x00 && c==0x20 && d==0x00 && e==0x09){
022C0:  MOVF   x62,W
022C2:  SUBLW  16
022C4:  BNZ   22DC
022C6:  MOVF   x63,F
022C8:  BNZ   22DC
022CA:  MOVF   x64,W
022CC:  SUBLW  20
022CE:  BNZ   22DC
022D0:  MOVF   x65,F
022D2:  BNZ   22DC
022D4:  MOVF   x66,W
022D6:  SUBLW  09
022D8:  BNZ   22DC
....................       //fprintf(USB, "\nBTD Date and Time: ");
....................       break;
....................    }
022DA:  BRA    22DE
.................... 
....................    else{
....................       //fprintf(USB,"\nBTD Invalid Message: ");
....................    sendResponse = 0;
022DC:  CLRF   x68
....................       break;
....................    }
....................    clear_InterruptGSM();
022DE:  MOVLB  0
022E0:  RCALL  1E64
....................    strcpy(strBTD_info, btdCode);
022E2:  MOVLW  04
022E4:  MOVWF  FEA
022E6:  MOVLW  63
022E8:  MOVWF  FE9
022EA:  MOVLW  04
022EC:  MOVWF  FE2
022EE:  MOVLW  77
022F0:  MOVWF  FE1
022F2:  MOVF   FE7,F
022F4:  MOVFF  FE6,FEE
022F8:  BNZ   22F2
....................    sprintf(message, "%s%i\r", strBTD_info, f); 
022FA:  MOVLW  04
022FC:  MOVLB  4
022FE:  MOVWF  x90
02300:  MOVLW  93
02302:  MOVWF  x8F
02304:  MOVFF  490,FEA
02308:  MOVFF  48F,FE9
0230C:  CLRF   FEF
0230E:  MOVLW  04
02310:  MOVWF  FEA
02312:  MOVLW  63
02314:  MOVWF  FE9
02316:  MOVLB  0
02318:  RCALL  1C42
0231A:  MOVFF  667,6B0
0231E:  MOVLW  18
02320:  MOVLB  6
02322:  MOVWF  xB1
02324:  MOVLB  0
02326:  CALL   1860
0232A:  MOVLW  0D
0232C:  MOVLB  6
0232E:  MOVWF  xBD
02330:  MOVLB  0
02332:  CALL   0FC6
....................    fprintf(USB, "SMS to Sent: %s", message);
02336:  MOVLW  88
02338:  MOVWF  FF6
0233A:  MOVLW  0D
0233C:  MOVWF  FF7
0233E:  MOVLW  00
02340:  MOVWF  FF8
02342:  MOVLW  0D
02344:  MOVLB  6
02346:  MOVWF  x91
02348:  MOVLB  0
0234A:  CALL   1080
0234E:  MOVLW  04
02350:  MOVWF  FEA
02352:  MOVLW  93
02354:  MOVWF  FE9
02356:  CALL   10B4
....................    strcpy(strBTD_info, "");
0235A:  MOVLW  04
0235C:  MOVWF  FEA
0235E:  MOVLW  63
02360:  MOVWF  FE9
02362:  MOVLW  00
02364:  CALL   00EE
02368:  TBLRD*-
0236A:  TBLRD*+
0236C:  MOVF   FF5,W
0236E:  MOVWF  FEE
02370:  IORLW  00
02372:  BNZ   236A
....................    strcpy(btdCode, "");
02374:  MOVLW  04
02376:  MOVWF  FEA
02378:  MOVLW  77
0237A:  MOVWF  FE9
0237C:  MOVLW  00
0237E:  CALL   00EE
02382:  TBLRD*-
02384:  TBLRD*+
02386:  MOVF   FF5,W
02388:  MOVWF  FEE
0238A:  IORLW  00
0238C:  BNZ   2384
....................    sendToLTE(message);
0238E:  MOVLW  04
02390:  MOVLB  6
02392:  MOVWF  x6A
02394:  MOVLW  93
02396:  MOVWF  x69
02398:  MOVLB  0
0239A:  RCALL  20A6
....................    
....................    
....................    
....................    delay_ms(200);
0239C:  MOVLW  C8
0239E:  MOVLB  6
023A0:  MOVWF  x6E
023A2:  MOVLB  0
023A4:  CALL   0F16
....................    return sendResponse;
023A8:  MOVLB  6
023AA:  MOVFF  668,01
023AE:  MOVLB  0
023B0:  GOTO   4C42 (RETURN)
.................... }
.................... 
.................... void dMonth(m){
....................    //char month;
....................    switch(m){    
....................       case 1: //fprintf(USB, "January");
....................          break;
....................       case 2: //fprintf(USB, "February");
....................          break;
....................       case 3: //fprintf(USB, "March");
....................          break;
....................       case 4: //fprintf(USB, "April");
....................          break;
....................       case 5: //fprintf(USB, "May");
....................          break;
....................       case 6: //fprintf(USB, "June");
....................          break;
....................       case 7: //fprintf(USB, "July");
....................          break;
....................       case 8: //fprintf(USB, "August");
....................          break;
....................       case 9: //fprintf(USB, "September");
....................          break;
....................       case 10: //fprintf(USB, "October");
....................          break;
....................       case 11: //fprintf(USB, "November");
....................          break;
....................       case 12: //fprintf(USB, "December");
....................          break;
....................       default : 
....................          break;
....................    }
.................... }
.................... 
.................... void writeData(w, t){
*
028A4:  MOVLB  6
028A6:  CLRF   x65
028A8:  CLRF   x64
028AA:  CLRF   x68
....................    int16 crc=0;
....................    uint8_t  bytes[2];
....................    int i = 0;
....................    char msmD [18] = {0xff, 0xff, 0x12, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0x6b};
028AC:  SETF   x69
028AE:  SETF   x6A
028B0:  MOVLW  12
028B2:  MOVWF  x6B
028B4:  CLRF   x6C
028B6:  MOVLW  02
028B8:  MOVWF  x6D
028BA:  MOVWF  x6E
028BC:  CLRF   x6F
028BE:  CLRF   x70
028C0:  CLRF   x71
028C2:  MOVLW  01
028C4:  MOVWF  x72
028C6:  MOVWF  x73
028C8:  CLRF   x74
028CA:  CLRF   x75
028CC:  CLRF   x76
028CE:  CLRF   x77
028D0:  CLRF   x78
028D2:  MOVLW  AD
028D4:  MOVWF  x79
028D6:  MOVLW  6B
028D8:  MOVWF  x7A
....................    char ack [22] = {0xff, 0xff, 0x16, 0x00, 0x02, 0x01, 0x00, 0x06, 0x00, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x5a};
028DA:  SETF   x7B
028DC:  SETF   x7C
028DE:  MOVLW  16
028E0:  MOVWF  x7D
028E2:  CLRF   x7E
028E4:  MOVLW  02
028E6:  MOVWF  x7F
028E8:  MOVLW  01
028EA:  MOVWF  x80
028EC:  CLRF   x81
028EE:  MOVLW  06
028F0:  MOVWF  x82
028F2:  CLRF   x83
028F4:  MOVLW  04
028F6:  MOVWF  x84
028F8:  MOVLW  06
028FA:  MOVWF  x85
028FC:  MOVLW  01
028FE:  MOVWF  x86
02900:  CLRF   x87
02902:  CLRF   x88
02904:  CLRF   x89
02906:  CLRF   x8A
02908:  CLRF   x8B
0290A:  CLRF   x8C
0290C:  CLRF   x8D
0290E:  CLRF   x8E
02910:  MOVLW  3E
02912:  MOVWF  x8F
02914:  MOVLW  5A
02916:  MOVWF  x90
....................          
....................    
....................    switch(w){
02918:  MOVF   x62,W
0291A:  XORLW  01
0291C:  MOVLB  0
0291E:  BZ    292C
02920:  XORLW  03
02922:  BZ    29C8
02924:  XORLW  01
02926:  BTFSC  FD8.2
02928:  BRA    2AEE
0292A:  BRA    2C50
....................    case 1:
....................       //fprintf(USB, "\narQ Accept Connect Request = %X %X %X %X %X %X %X %X %X %X", 0xff, 0xff, 0x0a, 0x00, 0x02, 0x33, 0x00, 0x00, 0x9f, 0xf7);
....................       fprintf(USB, "\nARQ Accepts Request\n"); 
0292C:  MOVLW  98
0292E:  MOVWF  FF6
02930:  MOVLW  0D
02932:  MOVWF  FF7
02934:  MOVLW  00
02936:  MOVWF  FF8
02938:  CALL   0F40
....................       fprintf(RS232_BTD200, "%c%c%c%c%c%c%c%c%c%c", 0xff, 0xff, 0x0a, 0x00, 0x02, 0x33, 0x00, 0x00, 0x9f, 0xf7);
0293C:  MOVLB  6
0293E:  SETF   x91
02940:  MOVLB  0
02942:  RCALL  23B4
02944:  MOVLB  6
02946:  SETF   x91
02948:  MOVLB  0
0294A:  RCALL  23B4
0294C:  MOVLW  0A
0294E:  MOVLB  6
02950:  MOVWF  x91
02952:  MOVLB  0
02954:  RCALL  23B4
02956:  MOVLB  6
02958:  CLRF   x91
0295A:  MOVLB  0
0295C:  RCALL  23B4
0295E:  MOVLW  02
02960:  MOVLB  6
02962:  MOVWF  x91
02964:  MOVLB  0
02966:  RCALL  23B4
02968:  MOVLW  33
0296A:  MOVLB  6
0296C:  MOVWF  x91
0296E:  MOVLB  0
02970:  RCALL  23B4
02972:  MOVLB  6
02974:  CLRF   x91
02976:  MOVLB  0
02978:  RCALL  23B4
0297A:  MOVLB  6
0297C:  CLRF   x91
0297E:  MOVLB  0
02980:  RCALL  23B4
02982:  MOVLW  9F
02984:  MOVLB  6
02986:  MOVWF  x91
02988:  MOVLB  0
0298A:  RCALL  23B4
0298C:  MOVLW  F7
0298E:  MOVLB  6
02990:  MOVWF  x91
02992:  MOVLB  0
02994:  RCALL  23B4
....................       //BTDhealth[0] = 100;
....................       fprintf(USB, "Message Number = %i\n", t);
02996:  MOVLW  AE
02998:  MOVWF  FF6
0299A:  MOVLW  0D
0299C:  MOVWF  FF7
0299E:  MOVLW  00
029A0:  MOVWF  FF8
029A2:  MOVLW  11
029A4:  MOVLB  6
029A6:  MOVWF  x91
029A8:  MOVLB  0
029AA:  CALL   1080
029AE:  MOVFF  663,691
029B2:  MOVLW  18
029B4:  MOVLB  6
029B6:  MOVWF  x92
029B8:  MOVLB  0
029BA:  RCALL  23FA
029BC:  MOVLW  0A
029BE:  BTFSS  FA4.4
029C0:  BRA    29BE
029C2:  MOVLB  F
029C4:  MOVWF  x1C
....................       break;
029C6:  BRA    2C52
....................       //%d%d%d%d%d%d%d%d%d%d
....................    case 2:
....................       for (i=0;i<18;i++){
029C8:  MOVLB  6
029CA:  CLRF   x68
029CC:  MOVF   x68,W
029CE:  SUBLW  11
029D0:  BNC   29DA
....................          msmD[7] = t;
029D2:  MOVFF  663,670
029D6:  INCF   x68,F
029D8:  BRA    29CC
....................       }
....................       crc=crc_generator(msmD, 16);
029DA:  MOVLW  06
029DC:  MOVWF  x92
029DE:  MOVLW  69
029E0:  MOVWF  x91
029E2:  CLRF   x94
029E4:  MOVLW  10
029E6:  MOVWF  x93
029E8:  MOVLB  0
029EA:  RCALL  27E4
029EC:  MOVFF  02,665
029F0:  MOVFF  01,664
....................       bytes[0] = *((uint8_t*)&(crc)+1);
029F4:  MOVLW  06
029F6:  MOVWF  03
029F8:  MOVLW  65
029FA:  MOVWF  FE9
029FC:  MOVFF  03,FEA
02A00:  MOVFF  FEF,666
....................       bytes[1] = *((uint8_t*)&(crc)+0);
02A04:  MOVLW  06
02A06:  MOVWF  03
02A08:  MOVLW  64
02A0A:  MOVWF  FE9
02A0C:  MOVFF  03,FEA
02A10:  MOVFF  FEF,667
....................       //fprintf(USB, "\nARQ Module Status Message: ");
....................       
....................       for (i=0;i<18;i++){ 
02A14:  MOVLB  6
02A16:  CLRF   x68
02A18:  MOVF   x68,W
02A1A:  SUBLW  11
02A1C:  BNC   2A2A
....................          msmD[16] = bytes[1];
02A1E:  MOVFF  667,679
....................          msmD[17] = bytes[0];
02A22:  MOVFF  666,67A
02A26:  INCF   x68,F
02A28:  BRA    2A18
....................       }
....................       
....................       //for (i=0;i<18;i++){
....................          //fprintf(USB, "%X ", msmD[i]);
....................       //}
....................       fprintf(RS232_BTD200, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c", 0xff, 0xff, 0x12, 0x00, 0x02, 0x02, 0x00,  msmD[7], 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, msmD[16], msmD[17]);
02A2A:  SETF   x91
02A2C:  MOVLB  0
02A2E:  RCALL  23B4
02A30:  MOVLB  6
02A32:  SETF   x91
02A34:  MOVLB  0
02A36:  RCALL  23B4
02A38:  MOVLW  12
02A3A:  MOVLB  6
02A3C:  MOVWF  x91
02A3E:  MOVLB  0
02A40:  RCALL  23B4
02A42:  MOVLB  6
02A44:  CLRF   x91
02A46:  MOVLB  0
02A48:  RCALL  23B4
02A4A:  MOVLW  02
02A4C:  MOVLB  6
02A4E:  MOVWF  x91
02A50:  MOVLB  0
02A52:  RCALL  23B4
02A54:  MOVLW  02
02A56:  MOVLB  6
02A58:  MOVWF  x91
02A5A:  MOVLB  0
02A5C:  RCALL  23B4
02A5E:  MOVLB  6
02A60:  CLRF   x91
02A62:  MOVLB  0
02A64:  RCALL  23B4
02A66:  MOVFF  670,691
02A6A:  RCALL  23B4
02A6C:  MOVLB  6
02A6E:  CLRF   x91
02A70:  MOVLB  0
02A72:  RCALL  23B4
02A74:  MOVLW  01
02A76:  MOVLB  6
02A78:  MOVWF  x91
02A7A:  MOVLB  0
02A7C:  RCALL  23B4
02A7E:  MOVLW  01
02A80:  MOVLB  6
02A82:  MOVWF  x91
02A84:  MOVLB  0
02A86:  RCALL  23B4
02A88:  MOVLB  6
02A8A:  CLRF   x91
02A8C:  MOVLB  0
02A8E:  RCALL  23B4
02A90:  MOVLB  6
02A92:  CLRF   x91
02A94:  MOVLB  0
02A96:  RCALL  23B4
02A98:  MOVLB  6
02A9A:  CLRF   x91
02A9C:  MOVLB  0
02A9E:  RCALL  23B4
02AA0:  MOVLB  6
02AA2:  CLRF   x91
02AA4:  MOVLB  0
02AA6:  RCALL  23B4
02AA8:  MOVLB  6
02AAA:  CLRF   x91
02AAC:  MOVLB  0
02AAE:  RCALL  23B4
02AB0:  MOVFF  679,691
02AB4:  RCALL  23B4
02AB6:  MOVFF  67A,691
02ABA:  RCALL  23B4
....................       fprintf(USB, "\nMessage Number = %i\n", t);
02ABC:  MOVLW  C4
02ABE:  MOVWF  FF6
02AC0:  MOVLW  0D
02AC2:  MOVWF  FF7
02AC4:  MOVLW  00
02AC6:  MOVWF  FF8
02AC8:  MOVLW  12
02ACA:  MOVLB  6
02ACC:  MOVWF  x91
02ACE:  MOVLB  0
02AD0:  CALL   1080
02AD4:  MOVFF  663,691
02AD8:  MOVLW  18
02ADA:  MOVLB  6
02ADC:  MOVWF  x92
02ADE:  MOVLB  0
02AE0:  RCALL  23FA
02AE2:  MOVLW  0A
02AE4:  BTFSS  FA4.4
02AE6:  BRA    2AE4
02AE8:  MOVLB  F
02AEA:  MOVWF  x1C
....................       break;
02AEC:  BRA    2C52
....................    
....................    case 3:
....................       for (i=0;i<22;i++){
02AEE:  MOVLB  6
02AF0:  CLRF   x68
02AF2:  MOVF   x68,W
02AF4:  SUBLW  15
02AF6:  BNC   2B00
....................          ack[7] = t;
02AF8:  MOVFF  663,682
02AFC:  INCF   x68,F
02AFE:  BRA    2AF2
....................       }  
....................       crc=crc_generator(ack, 20);
02B00:  MOVLW  06
02B02:  MOVWF  x92
02B04:  MOVLW  7B
02B06:  MOVWF  x91
02B08:  CLRF   x94
02B0A:  MOVLW  14
02B0C:  MOVWF  x93
02B0E:  MOVLB  0
02B10:  RCALL  27E4
02B12:  MOVFF  02,665
02B16:  MOVFF  01,664
....................       bytes[0] = *((uint8_t*)&(crc)+1);
02B1A:  MOVLW  06
02B1C:  MOVWF  03
02B1E:  MOVLW  65
02B20:  MOVWF  FE9
02B22:  MOVFF  03,FEA
02B26:  MOVFF  FEF,666
....................       bytes[1] = *((uint8_t*)&(crc)+0);
02B2A:  MOVLW  06
02B2C:  MOVWF  03
02B2E:  MOVLW  64
02B30:  MOVWF  FE9
02B32:  MOVFF  03,FEA
02B36:  MOVFF  FEF,667
....................       //fprintf(USB, "\nARQ Acknowledge Data: "); 
....................       
....................       for (i=0;i<22;i++){
02B3A:  MOVLB  6
02B3C:  CLRF   x68
02B3E:  MOVF   x68,W
02B40:  SUBLW  15
02B42:  BNC   2B50
....................          ack[20] = bytes[1];
02B44:  MOVFF  667,68F
....................          ack[21] = bytes[0];
02B48:  MOVFF  666,690
02B4C:  INCF   x68,F
02B4E:  BRA    2B3E
....................       }
....................      
....................       //for (i=0;i<22;i++){
....................          //fprintf(USB, "%X ", ack[i]);
....................       //}
....................       
....................       fprintf(RS232_BTD200, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c", 0xff, 0xff, 0x16, 0x00, 0x02, 0x01, 0x00, ack[7], 0x00, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ack[20], ack[21]);
02B50:  SETF   x91
02B52:  MOVLB  0
02B54:  RCALL  23B4
02B56:  MOVLB  6
02B58:  SETF   x91
02B5A:  MOVLB  0
02B5C:  RCALL  23B4
02B5E:  MOVLW  16
02B60:  MOVLB  6
02B62:  MOVWF  x91
02B64:  MOVLB  0
02B66:  RCALL  23B4
02B68:  MOVLB  6
02B6A:  CLRF   x91
02B6C:  MOVLB  0
02B6E:  RCALL  23B4
02B70:  MOVLW  02
02B72:  MOVLB  6
02B74:  MOVWF  x91
02B76:  MOVLB  0
02B78:  RCALL  23B4
02B7A:  MOVLW  01
02B7C:  MOVLB  6
02B7E:  MOVWF  x91
02B80:  MOVLB  0
02B82:  RCALL  23B4
02B84:  MOVLB  6
02B86:  CLRF   x91
02B88:  MOVLB  0
02B8A:  RCALL  23B4
02B8C:  MOVFF  682,691
02B90:  RCALL  23B4
02B92:  MOVLB  6
02B94:  CLRF   x91
02B96:  MOVLB  0
02B98:  RCALL  23B4
02B9A:  MOVLW  04
02B9C:  MOVLB  6
02B9E:  MOVWF  x91
02BA0:  MOVLB  0
02BA2:  RCALL  23B4
02BA4:  MOVLW  06
02BA6:  MOVLB  6
02BA8:  MOVWF  x91
02BAA:  MOVLB  0
02BAC:  RCALL  23B4
02BAE:  MOVLW  01
02BB0:  MOVLB  6
02BB2:  MOVWF  x91
02BB4:  MOVLB  0
02BB6:  CALL   23B4
02BBA:  MOVLB  6
02BBC:  CLRF   x91
02BBE:  MOVLB  0
02BC0:  CALL   23B4
02BC4:  MOVLB  6
02BC6:  CLRF   x91
02BC8:  MOVLB  0
02BCA:  CALL   23B4
02BCE:  MOVLB  6
02BD0:  CLRF   x91
02BD2:  MOVLB  0
02BD4:  CALL   23B4
02BD8:  MOVLB  6
02BDA:  CLRF   x91
02BDC:  MOVLB  0
02BDE:  CALL   23B4
02BE2:  MOVLB  6
02BE4:  CLRF   x91
02BE6:  MOVLB  0
02BE8:  CALL   23B4
02BEC:  MOVLB  6
02BEE:  CLRF   x91
02BF0:  MOVLB  0
02BF2:  CALL   23B4
02BF6:  MOVLB  6
02BF8:  CLRF   x91
02BFA:  MOVLB  0
02BFC:  CALL   23B4
02C00:  MOVLB  6
02C02:  CLRF   x91
02C04:  MOVLB  0
02C06:  CALL   23B4
02C0A:  MOVFF  68F,691
02C0E:  CALL   23B4
02C12:  MOVFF  690,691
02C16:  CALL   23B4
....................       fprintf(USB, "\nMessage Number = %i\n", t);
02C1A:  MOVLW  DA
02C1C:  MOVWF  FF6
02C1E:  MOVLW  0D
02C20:  MOVWF  FF7
02C22:  MOVLW  00
02C24:  MOVWF  FF8
02C26:  MOVLW  12
02C28:  MOVLB  6
02C2A:  MOVWF  x91
02C2C:  MOVLB  0
02C2E:  CALL   1080
02C32:  MOVFF  663,691
02C36:  MOVLW  18
02C38:  MOVLB  6
02C3A:  MOVWF  x92
02C3C:  MOVLB  0
02C3E:  CALL   23FA
02C42:  MOVLW  0A
02C44:  BTFSS  FA4.4
02C46:  BRA    2C44
02C48:  MOVLB  F
02C4A:  MOVWF  x1C
....................       break;
02C4C:  BRA    2C52
02C4E:  MOVLB  0
....................    
....................    default:
....................       //fprintf(USB,"\nARQ No Valid Response.");
....................       break;  
02C50:  MOVLB  F
....................    }
02C52:  MOVLB  0
02C54:  GOTO   4C52 (RETURN)
.................... }
.................... 
.................... void polarConverter(){
....................    float x, y;
....................    const float piVal = 3.141592; 
....................    char LatLong[30]={};
*
043A4:  MOVLB  6
043A6:  CLRF   x6A
043A8:  CLRF   x6B
043AA:  CLRF   x6C
043AC:  CLRF   x6D
043AE:  CLRF   x6E
043B0:  CLRF   x6F
043B2:  CLRF   x70
043B4:  CLRF   x71
043B6:  CLRF   x72
043B8:  CLRF   x73
043BA:  CLRF   x74
043BC:  CLRF   x75
043BE:  CLRF   x76
043C0:  CLRF   x77
043C2:  CLRF   x78
043C4:  CLRF   x79
043C6:  CLRF   x7A
043C8:  CLRF   x7B
043CA:  CLRF   x7C
043CC:  CLRF   x7D
043CE:  CLRF   x7E
043D0:  CLRF   x7F
043D2:  CLRF   x80
043D4:  CLRF   x81
043D6:  CLRF   x82
043D8:  CLRF   x83
043DA:  CLRF   x84
043DC:  CLRF   x85
043DE:  CLRF   x86
043E0:  CLRF   x87
....................    char septr[3], *ptr;
....................    
....................    int16 num;
....................    int  rt[10]={}; 
043E2:  CLRF   x8F
043E4:  CLRF   x90
043E6:  CLRF   x91
043E8:  CLRF   x92
043EA:  CLRF   x93
043EC:  CLRF   x94
043EE:  CLRF   x95
043F0:  CLRF   x96
043F2:  CLRF   x97
043F4:  CLRF   x98
....................    int i;
....................    float r;
....................    //int16 dirVal;
....................    long int dirVal;
....................    //unsigned int t;
....................    
....................    // fprintf(USB,"\nTest Data: %s", distDir);  
....................    strcpy(septr,".+");
043F6:  MOVLW  06
043F8:  MOVWF  FEA
043FA:  MOVLW  88
043FC:  MOVWF  FE9
043FE:  MOVLW  00
04400:  MOVLB  0
04402:  CALL   01F8
04406:  TBLRD*-
04408:  TBLRD*+
0440A:  MOVF   FF5,W
0440C:  MOVWF  FEE
0440E:  IORLW  00
04410:  BNZ   4408
....................    ptr = strtok(distDir, septr);
04412:  MOVLW  04
04414:  MOVLB  6
04416:  MOVWF  xA9
04418:  MOVLW  45
0441A:  MOVWF  xA8
0441C:  MOVLW  06
0441E:  MOVWF  xAB
04420:  MOVLW  88
04422:  MOVWF  xAA
04424:  MOVLB  0
04426:  CALL   13B6
0442A:  MOVFF  02,68C
0442E:  MOVFF  01,68B
....................    while(ptr!=0){
04432:  MOVLB  6
04434:  MOVF   x8B,F
04436:  BNZ   443C
04438:  MOVF   x8C,F
0443A:  BZ    44A6
....................       for (i=0;i<4;i++){   
0443C:  CLRF   x99
0443E:  MOVF   x99,W
04440:  SUBLW  03
04442:  BNC   44A4
....................          //unsigned long num = (unsigned long)strtol(ptr, NULL, 10);
....................          num = (int16)strtol(ptr, NULL, 10);
04444:  MOVFF  68C,6A9
04448:  MOVFF  68B,6A8
0444C:  CLRF   xAB
0444E:  CLRF   xAA
04450:  MOVLW  0A
04452:  MOVWF  xAC
04454:  MOVLB  0
04456:  GOTO   37C2
0445A:  MOVFF  02,68E
0445E:  MOVFF  01,68D
....................          //fprintf(USB, "%s ----- ", ptr);
....................          rt[i] = num;  
04462:  CLRF   03
04464:  MOVLB  6
04466:  MOVF   x99,W
04468:  ADDLW  8F
0446A:  MOVWF  FE9
0446C:  MOVLW  06
0446E:  ADDWFC 03,W
04470:  MOVWF  FEA
04472:  MOVFF  68D,FEF
....................          //fprintf(USB, "\nVal: %lu", num);  
....................          if (i==2){
04476:  MOVF   x99,W
04478:  SUBLW  02
0447A:  BNZ   4484
....................          dirVal = num;}
0447C:  MOVFF  68E,69F
04480:  MOVFF  68D,69E
....................          ptr = strtok(0, septr);  
04484:  CLRF   xA9
04486:  CLRF   xA8
04488:  MOVLW  06
0448A:  MOVWF  xAB
0448C:  MOVLW  88
0448E:  MOVWF  xAA
04490:  MOVLB  0
04492:  CALL   13B6
04496:  MOVFF  02,68C
0449A:  MOVFF  01,68B
0449E:  MOVLB  6
044A0:  INCF   x99,F
044A2:  BRA    443E
....................       }
044A4:  BRA    4434
....................    } 
....................    //r = rt[0] + (0.01*rt[1]) + 0.05;
....................    r = rt[0] + (0.01*rt[1]);
044A6:  CLRF   xE3
044A8:  MOVFF  690,6E2
044AC:  MOVLB  0
044AE:  CALL   326E
044B2:  MOVLW  0A
044B4:  MOVLB  6
044B6:  MOVWF  xE5
044B8:  MOVLW  D7
044BA:  MOVWF  xE4
044BC:  MOVLW  23
044BE:  MOVWF  xE3
044C0:  MOVLW  78
044C2:  MOVWF  xE2
044C4:  MOVFF  03,6E9
044C8:  MOVFF  02,6E8
044CC:  MOVFF  01,6E7
044D0:  MOVFF  00,6E6
044D4:  MOVLB  0
044D6:  CALL   32A4
044DA:  MOVFF  03,6AB
044DE:  MOVFF  02,6AA
044E2:  MOVFF  01,6A9
044E6:  MOVFF  00,6A8
044EA:  MOVLB  6
044EC:  CLRF   xE3
044EE:  MOVFF  68F,6E2
044F2:  MOVLB  0
044F4:  CALL   326E
044F8:  BCF    FD8.1
044FA:  MOVFF  03,6E5
044FE:  MOVFF  02,6E4
04502:  MOVFF  01,6E3
04506:  MOVFF  00,6E2
0450A:  MOVFF  6AB,6E9
0450E:  MOVFF  6AA,6E8
04512:  MOVFF  6A9,6E7
04516:  MOVFF  6A8,6E6
0451A:  CALL   3B18
0451E:  MOVFF  03,69D
04522:  MOVFF  02,69C
04526:  MOVFF  01,69B
0452A:  MOVFF  00,69A
....................    //ASTI Latlong
....................    float latA = 14.647; //14.646990
....................    float lonA = 121.072; //121.072072
0452E:  MOVLW  1D
04530:  MOVLB  6
04532:  MOVWF  xA3
04534:  MOVLW  5A
04536:  MOVWF  xA2
04538:  MOVLW  6A
0453A:  MOVWF  xA1
0453C:  MOVLW  82
0453E:  MOVWF  xA0
04540:  MOVLW  DD
04542:  MOVWF  xA7
04544:  MOVLW  24
04546:  MOVWF  xA6
04548:  MOVLW  72
0454A:  MOVWF  xA5
0454C:  MOVLW  85
0454E:  MOVWF  xA4
....................    //fprintf(USB,"\nDirection Value: %li", dirVal); 
....................    
....................    x = (r*cos(dirVal*(piVal / 180.0)))/111.111;
04550:  MOVFF  69F,6E3
04554:  MOVFF  69E,6E2
04558:  MOVLB  0
0455A:  CALL   326E
0455E:  MOVFF  03,6E5
04562:  MOVFF  02,6E4
04566:  MOVFF  01,6E3
0456A:  MOVFF  00,6E2
0456E:  MOVLW  33
04570:  MOVLB  6
04572:  MOVWF  xE9
04574:  MOVLW  FA
04576:  MOVWF  xE8
04578:  MOVLW  0E
0457A:  MOVWF  xE7
0457C:  MOVLW  79
0457E:  MOVWF  xE6
04580:  MOVLB  0
04582:  CALL   32A4
04586:  MOVFF  03,6AB
0458A:  MOVFF  02,6AA
0458E:  MOVFF  01,6A9
04592:  MOVFF  00,6A8
04596:  MOVFF  03,6B7
0459A:  MOVFF  02,6B6
0459E:  MOVFF  01,6B5
045A2:  MOVFF  00,6B4
045A6:  RCALL  3E48
045A8:  MOVFF  69D,6E5
045AC:  MOVFF  69C,6E4
045B0:  MOVFF  69B,6E3
045B4:  MOVFF  69A,6E2
045B8:  MOVFF  03,6E9
045BC:  MOVFF  02,6E8
045C0:  MOVFF  01,6E7
045C4:  MOVFF  00,6E6
045C8:  CALL   32A4
045CC:  MOVFF  03,6AB
045D0:  MOVFF  02,6AA
045D4:  MOVFF  01,6A9
045D8:  MOVFF  00,6A8
045DC:  MOVFF  03,6AF
045E0:  MOVFF  02,6AE
045E4:  MOVFF  01,6AD
045E8:  MOVFF  00,6AC
045EC:  MOVLW  D5
045EE:  MOVLB  6
045F0:  MOVWF  xB3
045F2:  MOVLW  38
045F4:  MOVWF  xB2
045F6:  MOVLW  5E
045F8:  MOVWF  xB1
045FA:  MOVLW  85
045FC:  MOVWF  xB0
045FE:  MOVLB  0
04600:  RCALL  41CC
04602:  MOVFF  03,665
04606:  MOVFF  02,664
0460A:  MOVFF  01,663
0460E:  MOVFF  00,662
....................    y = (r*sin(dirVal*(piVal / 180.0)))/107.721;  
04612:  MOVFF  69F,6E3
04616:  MOVFF  69E,6E2
0461A:  CALL   326E
0461E:  MOVFF  03,6E5
04622:  MOVFF  02,6E4
04626:  MOVFF  01,6E3
0462A:  MOVFF  00,6E2
0462E:  MOVLW  33
04630:  MOVLB  6
04632:  MOVWF  xE9
04634:  MOVLW  FA
04636:  MOVWF  xE8
04638:  MOVLW  0E
0463A:  MOVWF  xE7
0463C:  MOVLW  79
0463E:  MOVWF  xE6
04640:  MOVLB  0
04642:  CALL   32A4
04646:  MOVFF  03,6AB
0464A:  MOVFF  02,6AA
0464E:  MOVFF  01,6A9
04652:  MOVFF  00,6A8
04656:  MOVFF  03,6AF
0465A:  MOVFF  02,6AE
0465E:  MOVFF  01,6AD
04662:  MOVFF  00,6AC
04666:  BRA    432A
04668:  MOVFF  69D,6E5
0466C:  MOVFF  69C,6E4
04670:  MOVFF  69B,6E3
04674:  MOVFF  69A,6E2
04678:  MOVFF  03,6E9
0467C:  MOVFF  02,6E8
04680:  MOVFF  01,6E7
04684:  MOVFF  00,6E6
04688:  CALL   32A4
0468C:  MOVFF  03,6AB
04690:  MOVFF  02,6AA
04694:  MOVFF  01,6A9
04698:  MOVFF  00,6A8
0469C:  MOVFF  03,6AF
046A0:  MOVFF  02,6AE
046A4:  MOVFF  01,6AD
046A8:  MOVFF  00,6AC
046AC:  MOVLW  27
046AE:  MOVLB  6
046B0:  MOVWF  xB3
046B2:  MOVLW  71
046B4:  MOVWF  xB2
046B6:  MOVLW  57
046B8:  MOVWF  xB1
046BA:  MOVLW  85
046BC:  MOVWF  xB0
046BE:  MOVLB  0
046C0:  RCALL  41CC
046C2:  MOVFF  03,669
046C6:  MOVFF  02,668
046CA:  MOVFF  01,667
046CE:  MOVFF  00,666
.................... 
....................    if (r > 0){
046D2:  MOVLB  6
046D4:  CLRF   xE1
046D6:  CLRF   xE0
046D8:  CLRF   xDF
046DA:  CLRF   xDE
046DC:  MOVFF  69D,6E5
046E0:  MOVFF  69C,6E4
046E4:  MOVFF  69B,6E3
046E8:  MOVFF  69A,6E2
046EC:  MOVLB  0
046EE:  CALL   3D90
046F2:  BTFSS  FD8.0
046F4:  BRA    483A
....................       //sprintf(LatLong, "LT%i:%0.6f+LN%i:%0.6f+", rt[3], x+latA, rt[3], y+lonA);
....................       sprintf(LatLong, "LT%i:%0.3f+LN%i:%0.3f+", rt[3], x+latA, rt[3], y+lonA);
046F6:  BCF    FD8.1
046F8:  MOVFF  665,6E5
046FC:  MOVFF  664,6E4
04700:  MOVFF  663,6E3
04704:  MOVFF  662,6E2
04708:  MOVFF  6A3,6E9
0470C:  MOVFF  6A2,6E8
04710:  MOVFF  6A1,6E7
04714:  MOVFF  6A0,6E6
04718:  CALL   3B18
0471C:  MOVFF  03,6AB
04720:  MOVFF  02,6AA
04724:  MOVFF  01,6A9
04728:  MOVFF  00,6A8
0472C:  BCF    FD8.1
0472E:  MOVFF  669,6E5
04732:  MOVFF  668,6E4
04736:  MOVFF  667,6E3
0473A:  MOVFF  666,6E2
0473E:  MOVFF  6A7,6E9
04742:  MOVFF  6A6,6E8
04746:  MOVFF  6A5,6E7
0474A:  MOVFF  6A4,6E6
0474E:  CALL   3B18
04752:  MOVFF  03,6AF
04756:  MOVFF  02,6AE
0475A:  MOVFF  01,6AD
0475E:  MOVFF  00,6AC
04762:  MOVLW  06
04764:  MOVLB  4
04766:  MOVWF  x90
04768:  MOVLW  6A
0476A:  MOVWF  x8F
0476C:  MOVLW  4C
0476E:  MOVLB  6
04770:  MOVWF  xBD
04772:  MOVLB  0
04774:  CALL   0FC6
04778:  MOVLW  54
0477A:  MOVLB  6
0477C:  MOVWF  xBD
0477E:  MOVLB  0
04780:  CALL   0FC6
04784:  MOVFF  692,6B0
04788:  MOVLW  18
0478A:  MOVLB  6
0478C:  MOVWF  xB1
0478E:  MOVLB  0
04790:  CALL   1860
04794:  MOVLW  3A
04796:  MOVLB  6
04798:  MOVWF  xBD
0479A:  MOVLB  0
0479C:  CALL   0FC6
047A0:  MOVLW  C9
047A2:  MOVWF  FE9
047A4:  MOVFF  6AB,6B3
047A8:  MOVFF  6AA,6B2
047AC:  MOVFF  6A9,6B1
047B0:  MOVFF  6A8,6B0
047B4:  MOVLW  03
047B6:  MOVLB  6
047B8:  MOVWF  xB4
047BA:  MOVLB  0
047BC:  CALL   3472
047C0:  MOVLW  FA
047C2:  MOVWF  FF6
047C4:  MOVLW  0D
047C6:  MOVWF  FF7
047C8:  MOVLW  00
047CA:  MOVWF  FF8
047CC:  MOVLW  03
047CE:  MOVLB  6
047D0:  MOVWF  xB0
047D2:  MOVLB  0
047D4:  CALL   1C10
047D8:  MOVFF  692,6B0
047DC:  MOVLW  18
047DE:  MOVLB  6
047E0:  MOVWF  xB1
047E2:  MOVLB  0
047E4:  CALL   1860
047E8:  MOVLW  3A
047EA:  MOVLB  6
047EC:  MOVWF  xBD
047EE:  MOVLB  0
047F0:  CALL   0FC6
047F4:  MOVLW  C9
047F6:  MOVWF  FE9
047F8:  MOVFF  6AF,6B3
047FC:  MOVFF  6AE,6B2
04800:  MOVFF  6AD,6B1
04804:  MOVFF  6AC,6B0
04808:  MOVLW  03
0480A:  MOVLB  6
0480C:  MOVWF  xB4
0480E:  MOVLB  0
04810:  CALL   3472
04814:  MOVLW  2B
04816:  MOVLB  6
04818:  MOVWF  xBD
0481A:  MOVLB  0
0481C:  CALL   0FC6
....................       //strcat(strLaLo, LatLong);
....................       strcat(BTDLaLo, LatLong);
04820:  MOVLW  03
04822:  MOVLB  6
04824:  MOVWF  xA9
04826:  MOVLW  AF
04828:  MOVWF  xA8
0482A:  MOVLW  06
0482C:  MOVWF  xAB
0482E:  MOVLW  6A
04830:  MOVWF  xAA
04832:  MOVLB  0
04834:  CALL   198E
....................       //strcpy(LatLong, "");
....................    }
04838:  BRA    48EC
....................    
....................    else{
....................    sprintf(LatLong, "LT%i:%s+LN%i:%s+", rt[3], "00.000", rt[3],  "000.000");
0483A:  MOVLW  06
0483C:  MOVLB  4
0483E:  MOVWF  x90
04840:  MOVLW  6A
04842:  MOVWF  x8F
04844:  MOVLW  4C
04846:  MOVLB  6
04848:  MOVWF  xBD
0484A:  MOVLB  0
0484C:  CALL   0FC6
04850:  MOVLW  54
04852:  MOVLB  6
04854:  MOVWF  xBD
04856:  MOVLB  0
04858:  CALL   0FC6
0485C:  MOVFF  692,6B0
04860:  MOVLW  18
04862:  MOVLB  6
04864:  MOVWF  xB1
04866:  MOVLB  0
04868:  CALL   1860
0486C:  MOVLW  3A
0486E:  MOVLB  6
04870:  MOVWF  xBD
04872:  MOVLB  0
04874:  CALL   0FC6
04878:  MOVLW  1A
0487A:  MOVWF  FF6
0487C:  MOVLW  0E
0487E:  MOVWF  FF7
04880:  MOVLW  00
04882:  MOVWF  FF8
04884:  RCALL  437A
04886:  MOVLW  0F
04888:  MOVWF  FF6
0488A:  MOVLW  0E
0488C:  MOVWF  FF7
0488E:  MOVLW  00
04890:  MOVWF  FF8
04892:  MOVLW  03
04894:  MOVLB  6
04896:  MOVWF  xB0
04898:  MOVLB  0
0489A:  CALL   1C10
0489E:  MOVFF  692,6B0
048A2:  MOVLW  18
048A4:  MOVLB  6
048A6:  MOVWF  xB1
048A8:  MOVLB  0
048AA:  CALL   1860
048AE:  MOVLW  3A
048B0:  MOVLB  6
048B2:  MOVWF  xBD
048B4:  MOVLB  0
048B6:  CALL   0FC6
048BA:  MOVLW  22
048BC:  MOVWF  FF6
048BE:  MOVLW  0E
048C0:  MOVWF  FF7
048C2:  MOVLW  00
048C4:  MOVWF  FF8
048C6:  RCALL  437A
048C8:  MOVLW  2B
048CA:  MOVLB  6
048CC:  MOVWF  xBD
048CE:  MOVLB  0
048D0:  CALL   0FC6
....................    //sprintf(LatLong, "LT%i:%s+LN%i:%s+", rt[3], "00.000000", rt[3],  "000.000000");
....................    //strcat(strLaLo, LatLong);
....................    strcat(BTDLaLo, LatLong);
048D4:  MOVLW  03
048D6:  MOVLB  6
048D8:  MOVWF  xA9
048DA:  MOVLW  AF
048DC:  MOVWF  xA8
048DE:  MOVLW  06
048E0:  MOVWF  xAB
048E2:  MOVLW  6A
048E4:  MOVWF  xAA
048E6:  MOVLB  0
048E8:  CALL   198E
....................    //strcat(BTDLaLo, LatLong);
....................    //strcpy(LatLong, "");
....................    }
....................    //fprintf(USB, "\nConverted Polar: %s", LatLong);
....................    //fprintf(USB, "\nAcquired: %s", BTDLaLo);
....................    strcpy(LatLong, "");
048EC:  MOVLW  06
048EE:  MOVWF  FEA
048F0:  MOVLW  6A
048F2:  MOVWF  FE9
048F4:  MOVLW  00
048F6:  CALL   00EE
048FA:  TBLRD*-
048FC:  TBLRD*+
048FE:  MOVF   FF5,W
04900:  MOVWF  FEE
04902:  IORLW  00
04904:  BNZ   48FC
04906:  GOTO   4FE2 (RETURN)
....................    //return 0;  
.................... }  
.................... 
.................... //Reading BTD-200
.................... void readSerial(){
*
04AB6:  CLRF   x05
04AB8:  CLRF   x04
04ABA:  MOVLW  01
04ABC:  MOVWF  x10
....................   // fprintf(USB, "\nInitializing BTD200 ");
....................    char cx[100] = {}; //0xed, 0x08, 0x2d,
*
049EA:  MOVLB  5
049EC:  CLRF   x9F
049EE:  CLRF   xA0
049F0:  CLRF   xA1
049F2:  CLRF   xA2
049F4:  CLRF   xA3
049F6:  CLRF   xA4
049F8:  CLRF   xA5
049FA:  CLRF   xA6
049FC:  CLRF   xA7
049FE:  CLRF   xA8
04A00:  CLRF   xA9
04A02:  CLRF   xAA
04A04:  CLRF   xAB
04A06:  CLRF   xAC
04A08:  CLRF   xAD
04A0A:  CLRF   xAE
04A0C:  CLRF   xAF
04A0E:  CLRF   xB0
04A10:  CLRF   xB1
04A12:  CLRF   xB2
04A14:  CLRF   xB3
04A16:  CLRF   xB4
04A18:  CLRF   xB5
04A1A:  CLRF   xB6
04A1C:  CLRF   xB7
04A1E:  CLRF   xB8
04A20:  CLRF   xB9
04A22:  CLRF   xBA
04A24:  CLRF   xBB
04A26:  CLRF   xBC
04A28:  CLRF   xBD
04A2A:  CLRF   xBE
04A2C:  CLRF   xBF
04A2E:  CLRF   xC0
04A30:  CLRF   xC1
04A32:  CLRF   xC2
04A34:  CLRF   xC3
04A36:  CLRF   xC4
04A38:  CLRF   xC5
04A3A:  CLRF   xC6
04A3C:  CLRF   xC7
04A3E:  CLRF   xC8
04A40:  CLRF   xC9
04A42:  CLRF   xCA
04A44:  CLRF   xCB
04A46:  CLRF   xCC
04A48:  CLRF   xCD
04A4A:  CLRF   xCE
04A4C:  CLRF   xCF
04A4E:  CLRF   xD0
04A50:  CLRF   xD1
04A52:  CLRF   xD2
04A54:  CLRF   xD3
04A56:  CLRF   xD4
04A58:  CLRF   xD5
04A5A:  CLRF   xD6
04A5C:  CLRF   xD7
04A5E:  CLRF   xD8
04A60:  CLRF   xD9
04A62:  CLRF   xDA
04A64:  CLRF   xDB
04A66:  CLRF   xDC
04A68:  CLRF   xDD
04A6A:  CLRF   xDE
04A6C:  CLRF   xDF
04A6E:  CLRF   xE0
04A70:  CLRF   xE1
04A72:  CLRF   xE2
04A74:  CLRF   xE3
04A76:  CLRF   xE4
04A78:  CLRF   xE5
04A7A:  CLRF   xE6
04A7C:  CLRF   xE7
04A7E:  CLRF   xE8
04A80:  CLRF   xE9
04A82:  CLRF   xEA
04A84:  CLRF   xEB
04A86:  CLRF   xEC
04A88:  CLRF   xED
04A8A:  CLRF   xEE
04A8C:  CLRF   xEF
04A8E:  CLRF   xF0
04A90:  CLRF   xF1
04A92:  CLRF   xF2
04A94:  CLRF   xF3
04A96:  CLRF   xF4
04A98:  CLRF   xF5
04A9A:  CLRF   xF6
04A9C:  CLRF   xF7
04A9E:  CLRF   xF8
04AA0:  CLRF   xF9
04AA2:  CLRF   xFA
04AA4:  CLRF   xFB
04AA6:  CLRF   xFC
04AA8:  CLRF   xFD
04AAA:  CLRF   xFE
04AAC:  CLRF   xFF
04AAE:  MOVLB  6
04AB0:  CLRF   x00
04AB2:  CLRF   x01
04AB4:  CLRF   x02
....................    int i;
....................    //int j;
....................    long timeOut=0;
....................    int byteCount;
....................    int response;
.................... 
....................    //Flash Data variables
....................    //int dIndex;
....................    float distance;
....................    int16 dir;
....................    int m;
....................    int p;
....................   
....................    int inF = 1;
....................    int index;
....................    
....................    //char fc[100] = {};
....................    char dsdr[50] = {};
*
04ABE:  CLRF   x12
04AC0:  CLRF   x13
04AC2:  CLRF   x14
04AC4:  CLRF   x15
04AC6:  CLRF   x16
04AC8:  CLRF   x17
04ACA:  CLRF   x18
04ACC:  CLRF   x19
04ACE:  CLRF   x1A
04AD0:  CLRF   x1B
04AD2:  CLRF   x1C
04AD4:  CLRF   x1D
04AD6:  CLRF   x1E
04AD8:  CLRF   x1F
04ADA:  CLRF   x20
04ADC:  CLRF   x21
04ADE:  CLRF   x22
04AE0:  CLRF   x23
04AE2:  CLRF   x24
04AE4:  CLRF   x25
04AE6:  CLRF   x26
04AE8:  CLRF   x27
04AEA:  CLRF   x28
04AEC:  CLRF   x29
04AEE:  CLRF   x2A
04AF0:  CLRF   x2B
04AF2:  CLRF   x2C
04AF4:  CLRF   x2D
04AF6:  CLRF   x2E
04AF8:  CLRF   x2F
04AFA:  CLRF   x30
04AFC:  CLRF   x31
04AFE:  CLRF   x32
04B00:  CLRF   x33
04B02:  CLRF   x34
04B04:  CLRF   x35
04B06:  CLRF   x36
04B08:  CLRF   x37
04B0A:  CLRF   x38
04B0C:  CLRF   x39
04B0E:  CLRF   x3A
04B10:  CLRF   x3B
04B12:  CLRF   x3C
04B14:  CLRF   x3D
04B16:  CLRF   x3E
04B18:  CLRF   x3F
04B1A:  CLRF   x40
04B1C:  CLRF   x41
04B1E:  CLRF   x42
04B20:  CLRF   x43
....................    char dt[20]  = {};
04B22:  CLRF   x44
04B24:  CLRF   x45
04B26:  CLRF   x46
04B28:  CLRF   x47
04B2A:  CLRF   x48
04B2C:  CLRF   x49
04B2E:  CLRF   x4A
04B30:  CLRF   x4B
04B32:  CLRF   x4C
04B34:  CLRF   x4D
04B36:  CLRF   x4E
04B38:  CLRF   x4F
04B3A:  CLRF   x50
04B3C:  CLRF   x51
04B3E:  CLRF   x52
04B40:  CLRF   x53
04B42:  CLRF   x54
04B44:  CLRF   x55
04B46:  CLRF   x56
04B48:  CLRF   x57
....................    char fcount[2] = {};   
04B4A:  CLRF   x58
04B4C:  CLRF   x59
....................    
....................    int16 dist[2];
....................    int16 dirc[2];
....................    
....................    while(kbhit(RS232_BTD200)&&++timeOut<50000){
04B4E:  BTFSC  F86.3
04B50:  BRA    4B70
04B52:  INCF   x04,F
04B54:  BTFSC  FD8.2
04B56:  INCF   x05,F
04B58:  MOVF   x05,W
04B5A:  SUBLW  C3
04B5C:  BNC   4B70
04B5E:  BNZ   4B66
04B60:  MOVF   x04,W
04B62:  SUBLW  4F
04B64:  BNC   4B70
....................      // fprintf(USB,"\nNo Data!\n");
....................       delay_us(10);
04B66:  MOVLW  0D
04B68:  MOVWF  00
04B6A:  DECFSZ 00,F
04B6C:  BRA    4B6A
04B6E:  BRA    4B4E
....................    }
....................      
....................    if (!kbhit(RS232_BTD200)){
04B70:  BTFSS  F86.3
04B72:  BRA    4CE2
....................       //fprintf(USB, "\nTest kbhit");
....................       //fprintf(USB, RS232_BTD200);
....................       //setup_wdt(WDT_OFF);
....................        
....................       //Catching header to byte count
....................       for (i=0;i<3;i++){
04B74:  CLRF   x03
04B76:  MOVF   x03,W
04B78:  SUBLW  02
04B7A:  BNC   4BAA
....................       //fprintf(USB, RS232_BTD200);
....................       cx[i] = fgetc(RS232_BTD200);        
04B7C:  CLRF   03
04B7E:  MOVF   x03,W
04B80:  ADDLW  9F
04B82:  MOVWF  FE9
04B84:  MOVLW  05
04B86:  ADDWFC 03,W
04B88:  MOVWF  FEA
04B8A:  MOVFF  FEA,665
04B8E:  MOVFF  FE9,664
04B92:  MOVLB  0
04B94:  CALL   1DCE
04B98:  MOVFF  665,FEA
04B9C:  MOVFF  664,FE9
04BA0:  MOVFF  01,FEF
04BA4:  MOVLB  6
04BA6:  INCF   x03,F
04BA8:  BRA    4B76
....................       }
....................       byteCount = cx[2];
04BAA:  MOVFF  5A1,606
....................       
....................       //Catching index 3 to byte count or last byte of message
....................       for (i=3;i<byteCount;i++){
04BAE:  MOVLW  03
04BB0:  MOVWF  x03
04BB2:  MOVF   x06,W
04BB4:  SUBWF  x03,W
04BB6:  BC    4BE6
....................          cx[i] = fgetc(RS232_BTD200);  
04BB8:  CLRF   03
04BBA:  MOVF   x03,W
04BBC:  ADDLW  9F
04BBE:  MOVWF  FE9
04BC0:  MOVLW  05
04BC2:  ADDWFC 03,W
04BC4:  MOVWF  FEA
04BC6:  MOVFF  FEA,665
04BCA:  MOVFF  FE9,664
04BCE:  MOVLB  0
04BD0:  CALL   1DCE
04BD4:  MOVFF  665,FEA
04BD8:  MOVFF  664,FE9
04BDC:  MOVFF  01,FEF
04BE0:  MOVLB  6
04BE2:  INCF   x03,F
04BE4:  BRA    4BB2
....................          //fprintf(USB, RS232_BTD200);
....................       }
....................       
....................       //Printing the complete hex message from BTD-200
....................       for (i=0;i<byteCount;i++){
04BE6:  CLRF   x03
04BE8:  MOVF   x06,W
04BEA:  SUBWF  x03,W
04BEC:  BC    4C1A
....................          fprintf(USB, "%X ", cx[i]);   
04BEE:  CLRF   03
04BF0:  MOVF   x03,W
04BF2:  ADDLW  9F
04BF4:  MOVWF  FE9
04BF6:  MOVLW  05
04BF8:  ADDWFC 03,W
04BFA:  MOVWF  FEA
04BFC:  MOVFF  FEF,663
04C00:  MOVLW  37
04C02:  MOVWF  x64
04C04:  MOVLB  0
04C06:  CALL   1E18
04C0A:  MOVLW  20
04C0C:  BTFSS  FA4.4
04C0E:  BRA    4C0C
04C10:  MOVLB  F
04C12:  MOVWF  x1C
04C14:  MOVLB  6
04C16:  INCF   x03,F
04C18:  BRA    4BE8
....................          //fprintf(USB, "\nPrinting");
....................          //fprintf(RS485_GDAT1, "%c", cx[i]);
....................       }
.................... 
....................       if (cx[0] == 0xff){
04C1A:  MOVLB  5
04C1C:  INCFSZ x9F,W
04C1E:  BRA    4CE0
....................          //fprintf(USB, RS232_BTD200);
....................          if (cx[1] == 0xff){ 
04C20:  INCFSZ xA0,W
04C22:  BRA    4CE0
....................             //fprintf(USB, RS232_BTD200);
....................             //fprintf(USB, "\nTest 2nd header");
....................             
....................             //Reading and analyzing the BTD-200 command and selecting the correct response
....................             response = readData(cx[2], cx[3], cx[4], cx[5], cx[6], cx[7]);
04C24:  MOVFF  5A1,662
04C28:  MOVFF  5A2,663
04C2C:  MOVFF  5A3,664
04C30:  MOVFF  5A4,665
04C34:  MOVFF  5A5,666
04C38:  MOVFF  5A6,667
04C3C:  MOVLB  0
04C3E:  GOTO   2112
04C42:  MOVFF  01,607
....................             //fprintf(USB, "\nTest writeData"); 
....................             writeData(response, cx[7]);
04C46:  MOVFF  607,662
04C4A:  MOVFF  5A6,663
04C4E:  GOTO   28A4
....................             fprintf(USB, "\n");
04C52:  MOVLW  0A
04C54:  BTFSS  FA4.4
04C56:  BRA    4C54
04C58:  MOVLB  F
04C5A:  MOVWF  x1C
....................             
....................             getMcuDateTime();
04C5C:  MOVLB  0
04C5E:  CALL   1A76
....................             strcpy(biralBT, strDateTime);
04C62:  MOVLW  03
04C64:  MOVWF  FEA
04C66:  MOVLW  9B
04C68:  MOVWF  FE9
04C6A:  MOVLW  03
04C6C:  MOVWF  FE2
04C6E:  MOVLW  87
04C70:  MOVWF  FE1
04C72:  MOVF   FE7,F
04C74:  MOVFF  FE6,FEE
04C78:  BNZ   4C72
....................             fprintf(USB, "Date-Time: %s\n", biralBT);
04C7A:  MOVLW  2A
04C7C:  MOVWF  FF6
04C7E:  MOVLW  0E
04C80:  MOVWF  FF7
04C82:  MOVLW  00
04C84:  MOVWF  FF8
04C86:  MOVLW  0B
04C88:  MOVLB  6
04C8A:  MOVWF  x91
04C8C:  MOVLB  0
04C8E:  CALL   1080
04C92:  MOVLW  03
04C94:  MOVWF  FEA
04C96:  MOVLW  9B
04C98:  MOVWF  FE9
04C9A:  CALL   10B4
04C9E:  MOVLW  0A
04CA0:  BTFSS  FA4.4
04CA2:  BRA    4CA0
04CA4:  MOVLB  F
04CA6:  MOVWF  x1C
....................          
....................             strcpy(strDateTime, ""); 
04CA8:  MOVLW  03
04CAA:  MOVWF  FEA
04CAC:  MOVLW  87
04CAE:  MOVWF  FE9
04CB0:  MOVLW  00
04CB2:  MOVLB  0
04CB4:  CALL   00EE
04CB8:  TBLRD*-
04CBA:  TBLRD*+
04CBC:  MOVF   FF5,W
04CBE:  MOVWF  FEE
04CC0:  IORLW  00
04CC2:  BNZ   4CBA
....................             strcpy(biralBT, ""); 
04CC4:  MOVLW  03
04CC6:  MOVWF  FEA
04CC8:  MOVLW  9B
04CCA:  MOVWF  FE9
04CCC:  MOVLW  00
04CCE:  CALL   00EE
04CD2:  TBLRD*-
04CD4:  TBLRD*+
04CD6:  MOVF   FF5,W
04CD8:  MOVWF  FEE
04CDA:  IORLW  00
04CDC:  BNZ   4CD4
04CDE:  MOVLB  5
04CE0:  MOVLB  6
....................          }
....................       }     
....................    } 
....................               
....................           
....................    delay_ms(50);
04CE2:  MOVLW  32
04CE4:  MOVWF  x6E
04CE6:  MOVLB  0
04CE8:  CALL   0F16
....................    //fprintf(USB,"\nOngoing Read Serial!\n");
....................  
....................   
....................    //fprintf(USB, "\nWhere's data");
....................    if (cx[2]==0x0a && cx[2]==0x10 && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x01){
04CEC:  MOVLB  5
04CEE:  MOVF   xA1,W
04CF0:  SUBLW  0A
04CF2:  BNZ   4D1C
04CF4:  MOVF   xA1,W
04CF6:  SUBLW  10
04CF8:  BNZ   4D1C
04CFA:  MOVF   xA2,F
04CFC:  BNZ   4D1C
04CFE:  MOVF   xA3,W
04D00:  SUBLW  20
04D02:  BNZ   4D1C
04D04:  MOVF   xA4,F
04D06:  BNZ   4D1C
04D08:  DECFSZ xA5,W
04D0A:  BRA    4D1C
....................       btdStatus(2);    
04D0C:  MOVLW  02
04D0E:  MOVLB  6
04D10:  MOVWF  x62
04D12:  MOVLB  0
04D14:  CALL   2C58
....................    }
04D18:  BRA    50A2
04D1A:  MOVLB  5
....................    
....................     else if (cx[7]==0 && cx[2]==0x0a && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x21){
04D1C:  MOVF   xA6,F
04D1E:  BNZ   4D4A
04D20:  MOVF   xA1,W
04D22:  SUBLW  0A
04D24:  BNZ   4D4A
04D26:  MOVF   xA2,F
04D28:  BNZ   4D4A
04D2A:  MOVF   xA3,W
04D2C:  SUBLW  20
04D2E:  BNZ   4D4A
04D30:  MOVF   xA4,F
04D32:  BNZ   4D4A
04D34:  MOVF   xA5,W
04D36:  SUBLW  21
04D38:  BNZ   4D4A
....................       btdStatus(3);
04D3A:  MOVLW  03
04D3C:  MOVLB  6
04D3E:  MOVWF  x62
04D40:  MOVLB  0
04D42:  CALL   2C58
....................     }
04D46:  BRA    50A2
04D48:  MOVLB  5
....................    else if (cx[7]>1 && cx[7]<5) {
04D4A:  MOVF   xA6,W
04D4C:  SUBLW  01
04D4E:  BC    4D66
04D50:  MOVF   xA6,W
04D52:  SUBLW  04
04D54:  BNC   4D66
....................       btdStatus(3);
04D56:  MOVLW  03
04D58:  MOVLB  6
04D5A:  MOVWF  x62
04D5C:  MOVLB  0
04D5E:  CALL   2C58
....................    }
04D62:  BRA    50A2
04D64:  MOVLB  5
....................    
....................    else if (cx[7]==63){
04D66:  MOVF   xA6,W
04D68:  SUBLW  3F
04D6A:  BNZ   4D7C
....................       btdStatus(4);
04D6C:  MOVLW  04
04D6E:  MOVLB  6
04D70:  MOVWF  x62
04D72:  MOVLB  0
04D74:  CALL   2C58
....................    }
04D78:  BRA    50A2
04D7A:  MOVLB  5
....................                 
....................                 
....................    else if (cx[2]==0x57 && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x04 ){
04D7C:  MOVF   xA1,W
04D7E:  SUBLW  57
04D80:  BTFSS  FD8.2
04D82:  BRA    50A4
04D84:  MOVF   xA2,F
04D86:  BTFSS  FD8.2
04D88:  BRA    50A4
04D8A:  MOVF   xA3,W
04D8C:  SUBLW  20
04D8E:  BTFSS  FD8.2
04D90:  BRA    50A4
04D92:  MOVF   xA4,F
04D94:  BTFSS  FD8.2
04D96:  BRA    50A4
04D98:  MOVF   xA5,W
04D9A:  SUBLW  04
04D9C:  BTFSS  FD8.2
04D9E:  BRA    50A4
....................        getMcuDateTime();
04DA0:  MOVLB  0
04DA2:  CALL   1A76
....................        strcpy(biralBT, strDateTime);
04DA6:  MOVLW  03
04DA8:  MOVWF  FEA
04DAA:  MOVLW  9B
04DAC:  MOVWF  FE9
04DAE:  MOVLW  03
04DB0:  MOVWF  FE2
04DB2:  MOVLW  87
04DB4:  MOVWF  FE1
04DB6:  MOVF   FE7,F
04DB8:  MOVFF  FE6,FEE
04DBC:  BNZ   4DB6
....................       //fprintf(USB, "\nTest");
....................     
....................       fprintf(USB, "Warning - Flash Count: %X  ", cx[18]);  
04DBE:  MOVLW  3A
04DC0:  MOVWF  FF6
04DC2:  MOVLW  0E
04DC4:  MOVWF  FF7
04DC6:  MOVLW  00
04DC8:  MOVWF  FF8
04DCA:  MOVLW  17
04DCC:  MOVLB  6
04DCE:  MOVWF  x91
04DD0:  MOVLB  0
04DD2:  CALL   1080
04DD6:  MOVFF  5B1,663
04DDA:  MOVLW  37
04DDC:  MOVLB  6
04DDE:  MOVWF  x64
04DE0:  MOVLB  0
04DE2:  CALL   1E18
04DE6:  MOVLW  20
04DE8:  BTFSS  FA4.4
04DEA:  BRA    4DE8
04DEC:  MOVLB  F
04DEE:  MOVWF  x1C
04DF0:  MOVLW  20
04DF2:  BTFSS  FA4.4
04DF4:  BRA    4DF2
04DF6:  MOVWF  x1C
....................       //sprintf(fc, "FC:%i+", cx[18]); // integer to string    
....................       for (index=0;index<48;index=index+12){
04DF8:  MOVLB  6
04DFA:  CLRF   x11
04DFC:  MOVF   x11,W
04DFE:  SUBLW  2F
04E00:  BTFSS  FD8.0
04E02:  BRA    5016
....................       //fprintf(USB, "\nIndex: %i", inF);
....................          for (i=0;i<2;i++){
04E04:  CLRF   x03
04E06:  MOVF   x03,W
04E08:  SUBLW  01
04E0A:  BNC   4E3C
....................             dist[0] = cx[40+index];
04E0C:  MOVLW  28
04E0E:  ADDWF  x11,W
04E10:  CLRF   03
04E12:  ADDLW  9F
04E14:  MOVWF  FE9
04E16:  MOVLW  05
04E18:  ADDWFC 03,W
04E1A:  MOVWF  FEA
04E1C:  CLRF   x5B
04E1E:  MOVFF  FEF,65A
....................             dist[1] = cx[41+index];
04E22:  MOVLW  29
04E24:  ADDWF  x11,W
04E26:  CLRF   03
04E28:  ADDLW  9F
04E2A:  MOVWF  FE9
04E2C:  MOVLW  05
04E2E:  ADDWFC 03,W
04E30:  MOVWF  FEA
04E32:  CLRF   x5D
04E34:  MOVFF  FEF,65C
04E38:  INCF   x03,F
04E3A:  BRA    4E06
....................          }
.................... 
....................          distance = (dist[1]<<8 | dist[0])*0.01;     
04E3C:  MOVFF  65C,664
04E40:  CLRF   x63
04E42:  MOVF   x5A,W
04E44:  IORWF  x63,F
04E46:  MOVF   x5B,W
04E48:  IORWF  x64,F
04E4A:  MOVFF  664,6E3
04E4E:  MOVFF  663,6E2
04E52:  MOVLB  0
04E54:  CALL   326E
04E58:  MOVFF  03,6E5
04E5C:  MOVFF  02,6E4
04E60:  MOVFF  01,6E3
04E64:  MOVFF  00,6E2
04E68:  MOVLW  0A
04E6A:  MOVLB  6
04E6C:  MOVWF  xE9
04E6E:  MOVLW  D7
04E70:  MOVWF  xE8
04E72:  MOVLW  23
04E74:  MOVWF  xE7
04E76:  MOVLW  78
04E78:  MOVWF  xE6
04E7A:  MOVLB  0
04E7C:  CALL   32A4
04E80:  MOVFF  03,60B
04E84:  MOVFF  02,60A
04E88:  MOVFF  01,609
04E8C:  MOVFF  00,608
.................... 
....................          if (cx[43+index] == 0){
04E90:  MOVLW  2B
04E92:  MOVLB  6
04E94:  ADDWF  x11,W
04E96:  CLRF   03
04E98:  ADDLW  9F
04E9A:  MOVWF  FE9
04E9C:  MOVLW  05
04E9E:  ADDWFC 03,W
04EA0:  MOVWF  FEA
04EA2:  MOVF   FEF,F
04EA4:  BNZ   4ED0
....................             dir =   cx[43+index]<<8 | cx[42+index];
04EA6:  MOVLW  2B
04EA8:  ADDWF  x11,W
04EAA:  CLRF   03
04EAC:  ADDLW  9F
04EAE:  MOVWF  FE9
04EB0:  MOVLW  05
04EB2:  ADDWFC 03,W
04EB4:  MOVWF  FEA
04EB6:  CLRF   x62
04EB8:  MOVLW  2A
04EBA:  ADDWF  x11,W
04EBC:  CLRF   03
04EBE:  ADDLW  9F
04EC0:  MOVWF  FE9
04EC2:  MOVLW  05
04EC4:  ADDWFC 03,W
04EC6:  MOVWF  FEA
04EC8:  MOVF   FEF,W
04ECA:  IORWF  x62,W
04ECC:  MOVWF  x0C
04ECE:  CLRF   x0D
....................          }
....................                
....................          if (cx[43+index] > 0){
04ED0:  MOVLW  2B
04ED2:  ADDWF  x11,W
04ED4:  CLRF   03
04ED6:  ADDLW  9F
04ED8:  MOVWF  FE9
04EDA:  MOVLW  05
04EDC:  ADDWFC 03,W
04EDE:  MOVWF  FEA
04EE0:  MOVF   FEF,F
04EE2:  BZ    4F2A
....................             for (i=0;i<2;i++){
04EE4:  CLRF   x03
04EE6:  MOVF   x03,W
04EE8:  SUBLW  01
04EEA:  BNC   4F1C
....................                dirc[0] = cx[42+index];
04EEC:  MOVLW  2A
04EEE:  ADDWF  x11,W
04EF0:  CLRF   03
04EF2:  ADDLW  9F
04EF4:  MOVWF  FE9
04EF6:  MOVLW  05
04EF8:  ADDWFC 03,W
04EFA:  MOVWF  FEA
04EFC:  CLRF   x5F
04EFE:  MOVFF  FEF,65E
....................                dirc[1] = cx[43+index];
04F02:  MOVLW  2B
04F04:  ADDWF  x11,W
04F06:  CLRF   03
04F08:  ADDLW  9F
04F0A:  MOVWF  FE9
04F0C:  MOVLW  05
04F0E:  ADDWFC 03,W
04F10:  MOVWF  FEA
04F12:  CLRF   x61
04F14:  MOVFF  FEF,660
04F18:  INCF   x03,F
04F1A:  BRA    4EE6
....................             }
....................             dir = dirc[1]<<8 | dirc[0];
04F1C:  CLRF   x62
04F1E:  MOVF   x62,W
04F20:  IORWF  x5E,W
04F22:  MOVWF  x0C
04F24:  MOVF   x60,W
04F26:  IORWF  x5F,W
04F28:  MOVWF  x0D
....................             //fprintf(USB, "\nDirection Hex: %X %X degrees  ", cx[42], cx[43]);
....................          }
....................          
....................          m = cx[36];
04F2A:  MOVFF  5C3,60E
....................          p = cx[18];
04F2E:  MOVFF  5B1,60F
....................                
....................          //delay_ms(50);
....................          //fprintf(USB, "\nDistance: %lf km  Direction: %li degrees  ", distance, dir);
....................          //fprintf(USB, "Date: ");
....................          //dMonth(m);
....................          //fprintf(USB, " %i, 20%i", cx[35+index], cx[37+index]);
....................          //fprintf(USB, "  Time: %02i:%02i:%02i", cx[34+index], cx[33+index], cx[32+index]);                           
....................          
....................          sprintf(dsdr, "%lf+%li+%i", distance, dir, inF);
04F32:  MOVLW  06
04F34:  MOVLB  4
04F36:  MOVWF  x90
04F38:  MOVLW  12
04F3A:  MOVWF  x8F
04F3C:  MOVLW  89
04F3E:  MOVWF  FE9
04F40:  MOVFF  60B,6B3
04F44:  MOVFF  60A,6B2
04F48:  MOVFF  609,6B1
04F4C:  MOVFF  608,6B0
04F50:  MOVLW  02
04F52:  MOVLB  6
04F54:  MOVWF  xB4
04F56:  MOVLB  0
04F58:  CALL   3472
04F5C:  MOVLW  2B
04F5E:  MOVLB  6
04F60:  MOVWF  xBD
04F62:  MOVLB  0
04F64:  CALL   0FC6
04F68:  MOVLW  10
04F6A:  MOVWF  FE9
04F6C:  MOVFF  60D,663
04F70:  MOVFF  60C,662
04F74:  GOTO   3620
04F78:  MOVLW  2B
04F7A:  MOVLB  6
04F7C:  MOVWF  xBD
04F7E:  MOVLB  0
04F80:  CALL   0FC6
04F84:  MOVFF  610,6B0
04F88:  MOVLW  18
04F8A:  MOVLB  6
04F8C:  MOVWF  xB1
04F8E:  MOVLB  0
04F90:  CALL   1860
....................          sprintf(fcount, "%i", p);
04F94:  MOVLW  06
04F96:  MOVLB  4
04F98:  MOVWF  x90
04F9A:  MOVLW  58
04F9C:  MOVWF  x8F
04F9E:  MOVFF  60F,6B0
04FA2:  MOVLW  18
04FA4:  MOVLB  6
04FA6:  MOVWF  xB1
04FA8:  MOVLB  0
04FAA:  CALL   1860
....................           
....................          //fprintf(USB, "\nDistance: %s  ", dsdr);
....................          //fprintf(USB, "\nTest: %s", dsdr);
....................                
....................          strcpy(distDir, dsdr);
04FAE:  MOVLW  04
04FB0:  MOVWF  FEA
04FB2:  MOVLW  45
04FB4:  MOVWF  FE9
04FB6:  MOVLW  06
04FB8:  MOVWF  FE2
04FBA:  MOVLW  12
04FBC:  MOVWF  FE1
04FBE:  MOVF   FE7,F
04FC0:  MOVFF  FE6,FEE
04FC4:  BNZ   4FBE
....................          strcpy(flashCount, fcount);
04FC6:  MOVLW  04
04FC8:  MOVWF  FEA
04FCA:  MOVLW  4F
04FCC:  MOVWF  FE9
04FCE:  MOVLW  06
04FD0:  MOVWF  FE2
04FD2:  MOVLW  58
04FD4:  MOVWF  FE1
04FD6:  MOVF   FE7,F
04FD8:  MOVFF  FE6,FEE
04FDC:  BNZ   4FD6
....................          
....................          polarConverter();
04FDE:  GOTO   43A4
....................          
....................          //delay_ms(100);
....................          
....................          inF = inF + 1; 
04FE2:  MOVLW  01
04FE4:  MOVLB  6
04FE6:  ADDWF  x10,F
....................               
....................          //strcat(strBTD, dsdr);
....................          //fprintf(USB, "\nBiral Data: %s\n", BTDLaLo);
....................          strcpy(dsdr, NULL);
04FE8:  MOVLW  06
04FEA:  MOVWF  FEA
04FEC:  MOVLW  12
04FEE:  MOVWF  FE9
04FF0:  CLRF   FE2
04FF2:  CLRF   FE1
04FF4:  MOVF   FE7,F
04FF6:  MOVFF  FE6,FEE
04FFA:  BNZ   4FF4
....................          strcpy(fcount, NULL);
04FFC:  MOVLW  06
04FFE:  MOVWF  FEA
05000:  MOVLW  58
05002:  MOVWF  FE9
05004:  CLRF   FE2
05006:  CLRF   FE1
05008:  MOVF   FE7,F
0500A:  MOVFF  FE6,FEE
0500E:  BNZ   5008
05010:  MOVLW  0C
05012:  ADDWF  x11,F
05014:  BRA    4DFC
....................          
....................          }
....................          
....................          delay_ms(50);
05016:  MOVLW  32
05018:  MOVWF  x6E
0501A:  MOVLB  0
0501C:  CALL   0F16
....................          //Storing Date and Time   190905/175000  YYMMDD/HHMMSS
....................          sprintf(dt, "%02i%02i%02i/%02i%02i%02i", cx[37], cx[36], cx[35], cx[34], cx[33], cx[32]);
05020:  MOVLW  06
05022:  MOVLB  4
05024:  MOVWF  x90
05026:  MOVLW  44
05028:  MOVWF  x8F
0502A:  MOVFF  5C4,662
0502E:  MOVLW  01
05030:  MOVLB  6
05032:  MOVWF  x63
05034:  MOVLB  0
05036:  RCALL  490A
05038:  MOVFF  5C3,662
0503C:  MOVLW  01
0503E:  MOVLB  6
05040:  MOVWF  x63
05042:  MOVLB  0
05044:  RCALL  490A
05046:  MOVFF  5C2,662
0504A:  MOVLW  01
0504C:  MOVLB  6
0504E:  MOVWF  x63
05050:  MOVLB  0
05052:  RCALL  490A
05054:  MOVLW  2F
05056:  MOVLB  6
05058:  MOVWF  xBD
0505A:  MOVLB  0
0505C:  CALL   0FC6
05060:  MOVFF  5C1,662
05064:  MOVLW  01
05066:  MOVLB  6
05068:  MOVWF  x63
0506A:  MOVLB  0
0506C:  RCALL  490A
0506E:  MOVFF  5C0,662
05072:  MOVLW  01
05074:  MOVLB  6
05076:  MOVWF  x63
05078:  MOVLB  0
0507A:  RCALL  490A
0507C:  MOVFF  5BF,662
05080:  MOVLW  01
05082:  MOVLB  6
05084:  MOVWF  x63
05086:  MOVLB  0
05088:  RCALL  490A
....................          //fprintf(USB, "\nBiral Time: %s\n", dt);
....................             
....................          //delay_ms(100);
....................          
....................          //Carbs ---- Change BTD time to arQ Time
....................          //strcpy(biralBT, dt);
....................          
....................          
....................          
....................          //fprintf(USB, "\nBiral Data: %s\n", BTDLaLo);
....................          //BTDhealth[0] = 6;
....................          btdStatus(1);
0508A:  MOVLW  01
0508C:  MOVLB  6
0508E:  MOVWF  x62
05090:  MOVLB  0
05092:  CALL   2C58
....................          delay_ms(50);
05096:  MOVLW  32
05098:  MOVLB  6
0509A:  MOVWF  x6E
0509C:  MOVLB  0
0509E:  CALL   0F16
050A2:  MOVLB  5
....................       
....................       }
....................          
.................... //!      else if (cx[2]==0x27 && cx[3]==0x00 && cx[4]==0x20 && cx[5]==0x00 && cx[6]==0x03){
.................... //!         btdStatus(5);
.................... //!         delay_ms(50);
.................... //!      }
....................          
....................       //fprintf(USB, "\nTest end of Serial Read"); 
....................       //setup_wdt(WDT_ON);
....................       //cx[7] = 0x0a;
....................       //sprintf(strBTD_info, "NFD*%X\r", cx[7]);
....................       //strcpy(strBTD_con, strBTD_info);
....................       //btdStatus(5);
....................       //strcpy(strBTD_info, "");
....................       delay_ms(50);
050A4:  MOVLW  32
050A6:  MOVLB  6
050A8:  MOVWF  x6E
050AA:  MOVLB  0
050AC:  CALL   0F16
050B0:  GOTO   591C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... void mcuStatusOnStartUp(){
....................    char strx[20] = {};
*
01C68:  MOVLB  5
01C6A:  CLRF   x9F
01C6C:  CLRF   xA0
01C6E:  CLRF   xA1
01C70:  CLRF   xA2
01C72:  CLRF   xA3
01C74:  CLRF   xA4
01C76:  CLRF   xA5
01C78:  CLRF   xA6
01C7A:  CLRF   xA7
01C7C:  CLRF   xA8
01C7E:  CLRF   xA9
01C80:  CLRF   xAA
01C82:  CLRF   xAB
01C84:  CLRF   xAC
01C86:  CLRF   xAD
01C88:  CLRF   xAE
01C8A:  CLRF   xAF
01C8C:  CLRF   xB0
01C8E:  CLRF   xB1
01C90:  CLRF   xB2
....................    //char *msgP1=NULL;
....................    char message[40];
....................    int cause;
....................    
....................    cause=restart_cause();
01C92:  MOVF   FD0,W
01C94:  ANDLW  0F
01C96:  BTFSS  FD0.4
01C98:  MOVLW  00
01C9A:  BSF    FD0.0
01C9C:  BSF    FD0.1
01C9E:  BSF    FD0.4
01CA0:  BSF    FD8.3
01CA2:  BSF    FD8.4
01CA4:  MOVWF  xDB
....................    switch (cause){
01CA6:  MOVF   xDB,W
01CA8:  XORLW  07
01CAA:  MOVLB  0
01CAC:  BZ    1CBC
01CAE:  XORLW  0B
01CB0:  BZ    1CD8
01CB2:  XORLW  0C
01CB4:  BZ    1CF4
01CB6:  XORLW  0F
01CB8:  BZ    1D10
01CBA:  BRA    1D2C
....................       case WDT_TIMEOUT:{ 
....................           strcpy(strx,"WATCHDOG TIMEOUT");
01CBC:  MOVLW  05
01CBE:  MOVWF  FEA
01CC0:  MOVLW  9F
01CC2:  MOVWF  FE9
01CC4:  MOVLW  00
01CC6:  CALL   0210
01CCA:  TBLRD*-
01CCC:  TBLRD*+
01CCE:  MOVF   FF5,W
01CD0:  MOVWF  FEE
01CD2:  IORLW  00
01CD4:  BNZ   1CCC
....................           break;
01CD6:  BRA    1D66
....................       }
....................       
....................      
....................       case NORMAL_POWER_UP:{  //12 after upload of firmware
....................          strcpy(strx,"FRESH POWER UP!");
01CD8:  MOVLW  05
01CDA:  MOVWF  FEA
01CDC:  MOVLW  9F
01CDE:  MOVWF  FE9
01CE0:  MOVLW  00
01CE2:  CALL   0236
01CE6:  TBLRD*-
01CE8:  TBLRD*+
01CEA:  MOVF   FF5,W
01CEC:  MOVWF  FEE
01CEE:  IORLW  00
01CF0:  BNZ   1CE8
....................          break;
01CF2:  BRA    1D66
....................       }
....................       
....................     
....................       case RESET_INSTRUCTION:{   //0
....................          //readDataEEprom(EEPROM_RESET_NUMBER);
....................          strcpy(strx, "SOFTWARE RESET-");
01CF4:  MOVLW  05
01CF6:  MOVWF  FEA
01CF8:  MOVLW  9F
01CFA:  MOVWF  FE9
01CFC:  MOVLW  00
01CFE:  CALL   025A
01D02:  TBLRD*-
01D04:  TBLRD*+
01D06:  MOVF   FF5,W
01D08:  MOVWF  FEE
01D0A:  IORLW  00
01D0C:  BNZ   1D04
....................          //strcat(strx, funcReturnVar);
....................          break;
01D0E:  BRA    1D66
....................       }
....................       
....................       case MCLR_FROM_RUN:{    //15
....................          strcpy(strx,"HARDWARE RESET");
01D10:  MOVLW  05
01D12:  MOVWF  FEA
01D14:  MOVLW  9F
01D16:  MOVWF  FE9
01D18:  MOVLW  00
01D1A:  CALL   027E
01D1E:  TBLRD*-
01D20:  TBLRD*+
01D22:  MOVF   FF5,W
01D24:  MOVWF  FEE
01D26:  IORLW  00
01D28:  BNZ   1D20
....................          break;
01D2A:  BRA    1D66
....................       }
....................       
....................       default:{
....................          sprintf(strx, "OTHER RESET CAUSE (%i)", cause );
01D2C:  MOVLW  05
01D2E:  MOVLB  4
01D30:  MOVWF  x90
01D32:  MOVLW  9F
01D34:  MOVWF  x8F
01D36:  MOVLW  56
01D38:  MOVWF  FF6
01D3A:  MOVLW  0E
01D3C:  MOVWF  FF7
01D3E:  MOVLW  00
01D40:  MOVWF  FF8
01D42:  MOVLW  13
01D44:  MOVLB  6
01D46:  MOVWF  xB0
01D48:  MOVLB  0
01D4A:  RCALL  1C10
01D4C:  MOVFF  5DB,6B0
01D50:  MOVLW  18
01D52:  MOVLB  6
01D54:  MOVWF  xB1
01D56:  MOVLB  0
01D58:  RCALL  1860
01D5A:  MOVLW  29
01D5C:  MOVLB  6
01D5E:  MOVWF  xBD
01D60:  MOVLB  0
01D62:  CALL   0FC6
....................       }
....................    }
....................    
....................    fprintf(USB,"%s\n",strx);
01D66:  MOVLW  05
01D68:  MOVWF  FEA
01D6A:  MOVLW  9F
01D6C:  MOVWF  FE9
01D6E:  CALL   10B4
01D72:  MOVLW  0A
01D74:  BTFSS  FA4.4
01D76:  BRA    1D74
01D78:  MOVLB  F
01D7A:  MOVWF  x1C
....................    //strcpy(SMS_TOBE_SENT,strx);
....................    getMcuDateTime();
01D7C:  MOVLB  0
01D7E:  RCALL  1A76
....................    //sprintf(SMS_TOBE_SENT, "%s - %s", strx, getMcuDateTime()); //getDateTime()
....................    //sprintf(message, "%s - %s", strx, globalDT); //getDateTime()  
....................    sprintf(message, "%s - %s", strx, strDateTime); //getDateTime() 
01D80:  MOVLW  05
01D82:  MOVLB  4
01D84:  MOVWF  x90
01D86:  MOVLW  B3
01D88:  MOVWF  x8F
01D8A:  MOVFF  490,FEA
01D8E:  MOVFF  48F,FE9
01D92:  CLRF   FEF
01D94:  MOVLW  05
01D96:  MOVWF  FEA
01D98:  MOVLW  9F
01D9A:  MOVWF  FE9
01D9C:  MOVLB  0
01D9E:  RCALL  1C42
01DA0:  MOVLW  70
01DA2:  MOVWF  FF6
01DA4:  MOVLW  0E
01DA6:  MOVWF  FF7
01DA8:  MOVLW  00
01DAA:  MOVWF  FF8
01DAC:  MOVLW  03
01DAE:  MOVLB  6
01DB0:  MOVWF  xB0
01DB2:  MOVLB  0
01DB4:  RCALL  1C10
01DB6:  MOVFF  490,FEA
01DBA:  MOVFF  48F,FE9
01DBE:  CLRF   FEF
01DC0:  MOVLW  03
01DC2:  MOVWF  FEA
01DC4:  MOVLW  87
01DC6:  MOVWF  FE9
01DC8:  RCALL  1C42
01DCA:  GOTO   58EE (RETURN)
....................    //AttemptToSend(message,MYNUMBER2);
.................... }
.................... 
.................... 
.................... //char xxx[255]={};
.................... void main(){
*
056CC:  CLRF   FF8
056CE:  BCF    FD0.7
056D0:  BSF    07.7
056D2:  MOVLW  72
056D4:  MOVWF  FD3
056D6:  CLRF   F9B
056D8:  CLRF   F64
056DA:  BCF    FC6.5
056DC:  MOVLW  00
056DE:  MOVWF  FC7
056E0:  MOVLW  20
056E2:  MOVWF  FC6
056E4:  BCF    F94.5
056E6:  BSF    F94.4
056E8:  BCF    F94.3
056EA:  BSF    F95.6
056EC:  BSF    F95.5
056EE:  MOVLW  27
056F0:  MOVWF  F69
056F2:  MOVLW  28
056F4:  MOVWF  F67
056F6:  BSF    F68.7
056F8:  BCF    F68.6
056FA:  BCF    F96.4
056FC:  BSF    F8D.4
056FE:  BCF    F98.4
05700:  BSF    F8F.4
05702:  BCF    F65.3
05704:  MOVLW  0C
05706:  MOVWF  FAF
05708:  MOVLW  A2
0570A:  MOVWF  FAC
0570C:  MOVLW  90
0570E:  MOVWF  FAB
05710:  BCF    40.0
05712:  CLRF   41
05714:  BCF    40.1
05716:  MOVLB  1
05718:  CLRF   x41
0571A:  CLRF   x42
0571C:  CLRF   x43
0571E:  BCF    40.2
05720:  MOVLB  3
05722:  CLRF   x80
05724:  CLRF   x81
05726:  CLRF   x82
05728:  CLRF   x83
0572A:  CLRF   x84
0572C:  CLRF   x85
0572E:  CLRF   x86
05730:  MOVLB  4
05732:  CLRF   x8B
05734:  MOVLW  0F
05736:  MOVWF  x8C
05738:  BCF    40.3
0573A:  BCF    40.4
0573C:  CLRF   x8D
0573E:  BCF    40.5
05740:  BCF    40.6
05742:  BCF    40.7
05744:  BCF    x8E.0
05746:  MOVLB  F
05748:  BSF    x20.3
0574A:  MOVLW  44
0574C:  MOVWF  x1E
0574E:  MOVLW  00
05750:  MOVWF  x1F
05752:  MOVLW  A6
05754:  MOVWF  x21
05756:  MOVLW  90
05758:  MOVWF  x22
0575A:  MOVLB  4
0575C:  BCF    x8E.1
0575E:  CLRF   x90
05760:  CLRF   x8F
05762:  CLRF   x91
05764:  MOVLW  00
05766:  MOVLB  F
05768:  MOVWF  x23
0576A:  MOVWF  x24
0576C:  MOVWF  x25
0576E:  BCF    FC1.3
05770:  BCF    FC1.4
05772:  BCF    FC1.5
05774:  CLRF   x2E
05776:  CLRF   x2F
05778:  CLRF   x54
0577A:  MOVLB  4
0577C:  BCF    x8E.2
0577E:  BRA    57A4
05780:  DATA 02,00
05782:  DATA 1C,00
05784:  DATA 00,1E
05786:  DATA 40,22
05788:  DATA 00,FF
0578A:  DATA 40,42
0578C:  DATA 00,FF
0578E:  DATA 41,44
05790:  DATA 00,FF
05792:  DATA C0,00
05794:  DATA 3E,C0
05796:  DATA 00,FF
05798:  DATA 43,87
0579A:  DATA 00,05
0579C:  DATA C0,00
0579E:  DATA FF,44
057A0:  DATA 93,00
057A2:  DATA 00,00
057A4:  MOVLW  00
057A6:  MOVWF  FF8
057A8:  MOVLW  57
057AA:  MOVWF  FF7
057AC:  MOVLW  80
057AE:  MOVWF  FF6
057B0:  TBLRD*+
057B2:  MOVF   FF5,W
057B4:  MOVWF  00
057B6:  XORLW  00
057B8:  BZ    57E0
057BA:  TBLRD*+
057BC:  MOVF   FF5,W
057BE:  MOVWF  01
057C0:  BTFSC  FE8.7
057C2:  BRA    57CE
057C4:  ANDLW  3F
057C6:  MOVWF  FEA
057C8:  TBLRD*+
057CA:  MOVFF  FF5,FE9
057CE:  BTFSC  01.6
057D0:  TBLRD*+
057D2:  BTFSS  01.6
057D4:  TBLRD*+
057D6:  MOVFF  FF5,FEE
057DA:  DCFSNZ 00,F
057DC:  BRA    57B0
057DE:  BRA    57D2
057E0:  CLRF   FF8
....................    char dbg[6]="debug";
057E2:  MOVLW  64
057E4:  MOVLB  5
057E6:  MOVWF  x92
057E8:  MOVLW  65
057EA:  MOVWF  x93
057EC:  MOVLW  62
057EE:  MOVWF  x94
057F0:  MOVLW  75
057F2:  MOVWF  x95
057F4:  MOVLW  67
057F6:  MOVWF  x96
057F8:  CLRF   x97
....................    char reset[6]="reset";
057FA:  MOVLW  72
057FC:  MOVWF  x98
057FE:  MOVLW  65
05800:  MOVWF  x99
05802:  MOVLW  73
05804:  MOVWF  x9A
05806:  MOVLW  65
05808:  MOVWF  x9B
0580A:  MOVLW  74
0580C:  MOVWF  x9C
0580E:  CLRF   x9D
....................    //char *ptr=NULL;
....................    //char *bptr=NULL;
....................    //char *signal=NULL;
....................    //char septr[6];   
....................    //char mainBT[20];
....................    //char fcBTD[60];
....................    unsigned int8 tmp1;
....................    
....................    //int byteCount;
....................    //char message[255]={};
....................    delay_ms(500);
05810:  MOVLW  02
05812:  MOVWF  x9F
05814:  MOVLW  FA
05816:  MOVLB  6
05818:  MOVWF  x6E
0581A:  MOVLB  0
0581C:  CALL   0F16
05820:  MOVLB  5
05822:  DECFSZ x9F,F
05824:  BRA    5814
....................    
....................    fprintf(USB, "\n*************************************************\n");
05826:  MOVLW  76
05828:  MOVWF  FF6
0582A:  MOVLW  0E
0582C:  MOVWF  FF7
0582E:  MOVLW  00
05830:  MOVWF  FF8
05832:  MOVLB  0
05834:  CALL   0F40
....................    fprintf(USB, "ULAT Lightning Monitoring Station (Beta version)\n");
05838:  MOVLW  AA
0583A:  MOVWF  FF6
0583C:  MOVLW  0E
0583E:  MOVWF  FF7
05840:  MOVLW  00
05842:  MOVWF  FF8
05844:  CALL   0F40
....................   
....................    enable_interrupts(INT_TIMER1); // enable timer1 interrupt, through the use of the 32 khz oscillator, it will be triggered every second   
05848:  BSF    F9D.0
....................    enable_interrupts(INT_RDA);    // hardware UART interrupt, used by Radio/GSM module
0584A:  BSF    F9D.5
....................    enable_interrupts(INT_RDA2);   // hardware UART interrupt, used by USB through RS232 interface via the USB port
0584C:  BSF    FA3.5
....................    enable_interrupts(INT_EXT);    // B0 used by rain gauge
0584E:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1);   // RING OUT - will be triggered once a call or text is received by the gsm module
05850:  BSF    FF0.3
....................    //enable_interrupts(INT_EXT2);   // Interrupt 2 is triggered when there is interrupt signal from the AS3935
....................    enable_interrupts(GLOBAL);     // main switch for all the interrupts
05852:  MOVLW  C0
05854:  IORWF  FF2,F
....................  
....................    ext_int_edge(2,H_TO_L);         // configure INT2 state change to trigger interrupt 2  
05856:  BCF    FF1.4
....................    
....................    setup_wdt(WDT_ON);// enable watch dog
05858:  BSF    FD1.0
....................    //setup_wdt(WDT_128S);  
....................    
....................    setup_timer_1(T1_EXTERNAL|T1_DIV_BY_1|T1_ENABLE_SOSC); //no T1_CLK_OUT
0585A:  MOVLW  8F
0585C:  MOVWF  FCD
0585E:  CLRF   FAA
....................    
....................    setup_spi(SPI_MASTER |SPI_L_TO_H | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);  // Working with AS3935, set as default
05860:  BCF    FC6.5
05862:  BCF    F94.5
05864:  BSF    F94.4
05866:  BCF    F94.3
05868:  MOVLW  22
0586A:  MOVWF  FC6
0586C:  MOVLW  00
0586E:  MOVWF  FC7
....................     
....................    delay_ms(500);
05870:  MOVLW  02
05872:  MOVLB  5
05874:  MOVWF  x9F
05876:  MOVLW  FA
05878:  MOVLB  6
0587A:  MOVWF  x6E
0587C:  MOVLB  0
0587E:  CALL   0F16
05882:  MOVLB  5
05884:  DECFSZ x9F,F
05886:  BRA    5876
....................    //Thunder_Init();
....................     
....................    
....................    //igniteGSM();
....................    //InitGSM();                      // initialize GSM
....................    
....................    
....................    
....................    // igtLTE();
....................    delay_ms(2000);
05888:  MOVLW  08
0588A:  MOVWF  x9F
0588C:  MOVLW  FA
0588E:  MOVLB  6
05890:  MOVWF  x6E
05892:  MOVLB  0
05894:  CALL   0F16
05898:  MOVLB  5
0589A:  DECFSZ x9F,F
0589C:  BRA    588C
....................   
....................    
....................    
....................    
....................    //fprintf(GSM, "init\r");
....................    rtc_acquire_sync();             // sync datetime from rtc chip to both GSM and MCU
0589E:  MOVLB  0
058A0:  CALL   1B84
....................    
.................... 
....................    InterruptInput2_Flag=0;
058A4:  MOVLB  4
058A6:  BCF    x8E.1
....................       
....................    clear_InterruptUSB();
058A8:  MOVLB  0
058AA:  CALL   1BF2
.................... 
....................   
....................    //Send to server through message format
.................... 
....................    strcpy(SERVERNUMBER,"639564334913");
058AE:  MOVLW  01
058B0:  MOVWF  FEA
058B2:  MOVLW  44
058B4:  MOVWF  FE9
058B6:  MOVLW  00
058B8:  CALL   02A2
058BC:  TBLRD*-
058BE:  TBLRD*+
058C0:  MOVF   FF5,W
058C2:  MOVWF  FEE
058C4:  IORLW  00
058C6:  BNZ   58BE
....................    //strcpy(MYNUMBER1,"639564334913");
....................    strcpy(MYNUMBER2,"639564334913");
058C8:  MOVLW  01
058CA:  MOVWF  FEA
058CC:  MOVLW  62
058CE:  MOVWF  FE9
058D0:  MOVLW  00
058D2:  CALL   02A2
058D6:  TBLRD*-
058D8:  TBLRD*+
058DA:  MOVF   FF5,W
058DC:  MOVWF  FEE
058DE:  IORLW  00
058E0:  BNZ   58D8
....................    //strcpy(MyNUMBER,"");
....................    SENDING_TIME = 60; //60
058E2:  MOVLW  3C
058E4:  MOVLB  4
058E6:  MOVWF  x8C
....................    
....................    mcuStatusOnStartUp(); // function determines cause of MCU restart
058E8:  MOVLB  0
058EA:  GOTO   1C68
....................    
....................    //output_high(pin_BOOST1);  //5 volts
....................    //output_high(pin_BOOST2); //18 volts
....................    
....................    fprintf(USB, "\nInitializing BTD200\n");
058EE:  MOVLW  DC
058F0:  MOVWF  FF6
058F2:  MOVLW  0E
058F4:  MOVWF  FF7
058F6:  MOVLW  00
058F8:  MOVWF  FF8
058FA:  CALL   0F40
....................    //igtLTE();
....................    //char gsLTE;
....................   
....................    delay_ms(200);
058FE:  MOVLW  C8
05900:  MOVLB  6
05902:  MOVWF  x6E
05904:  MOVLB  0
05906:  CALL   0F16
....................    //clear_inputs();
....................    
....................    
....................    delay_ms(200);
0590A:  MOVLW  C8
0590C:  MOVLB  6
0590E:  MOVWF  x6E
05910:  MOVLB  0
05912:  CALL   0F16
....................    //sprintf(message, "FC:4+LT1:14.682+LN1:121.282+LT2:14.637+LN2:121.356+LT3:14.700+LN3:121.253+LT4:14.752+LN4:121.023+GS:%s+BT:230216/152710+DT:230216/15272170\r", signal);
....................    
....................    //sendToLTE(message);
....................    //fprintf(GSM, message);
....................    //write_eeprom(0, 0x55);
....................    //write_eeprom(1, 0x56);
....................    
....................    //fprintf(USB,"Wrote 0x55 to eeprom address 0\n\r");
....................    //fprintf(USB,"Read1 %X\n\r", read_eeprom(0));
....................    //fprintf(USB,"Read2 %X\n\r", read_eeprom(1));
....................    
....................    //fprintf("\n\r");        
....................          
....................    //fprintf(USB,"\n\nWrote 0xAA to eeprom address 0\n\r");
....................    ///write_eeprom(0, 3);
....................    //write_eeprom(1, 4);
....................    //int k = read_eeprom(0);
....................    //int l = read_eeprom(1);
.................... 
....................    //fprintf(USB,"Read1 %i\n\r", k);
....................    //fprintf(USB,"Read2 %i\n\r", l);
....................    //fprintf(USB,"\n\rDone\n\r");
....................    //write_eeprom(0, 1);
....................    //write_eeprom(1, 2);
....................    
....................   
....................    
....................             
....................    while(1){
....................       restart_wdt();
05916:  CLRWDT
....................       readSerial();
05918:  GOTO   49EA
....................       
.................... //!      fprintf(USB, "\nBTD Recon");
....................       //sprintf(message, "BTDcon\r");
....................       //FC:4+LT1:14.682+LN1:121.282+LT2:14.637+LN2:121.356+LT3:14.700+LN3:121.253+LT4:14.752+LN4:121.023+GS:*+BT:230216/152710+DT:*
....................       //delay_ms(100);
....................       //sendToLTE(message);
....................       
....................      // delay_ms(180000);
....................       
....................       //fprintf(USB, "\nBTD con");
....................       //sprintf(message, "BTDcon\r");
....................       //FC:4+LT1:14.682+LN1:121.282+LT2:14.637+LN2:121.356+LT3:14.700+LN3:121.253+LT4:14.752+LN4:121.023+GS:*+BT:230216/152710+DT:*
....................       //delay_ms(100);
....................       //sendToLTE(message);
....................       
....................       //signal = signalLTE();
....................       delay_ms(200);
0591C:  MOVLW  C8
0591E:  MOVLB  6
05920:  MOVWF  x6E
05922:  MOVLB  0
05924:  CALL   0F16
....................       //fprintf(USB, "\nSignal Strength: %s", signal);
....................       //relayON();
....................       //delay_ms(2000);
....................       //relayOFF();
....................       //delay_ms(100);
....................          
....................       //sprintf(message, "FC:4+LT1:14.682+LN1:121.282+LT2:14.637+LN2:121.356+LT3:14.700+LN3:121.253+LT4:14.752+LN4:121.023+GS:*+BT:230216/152710+DT:230216/15272170\r");
....................       //FC:4+LT1:14.682+LN1:121.282+LT2:14.637+LN2:121.356+LT3:14.700+LN3:121.253+LT4:14.752+LN4:121.023+GS:*+BT:230216/152710+DT:*
....................       //delay_ms(100);
....................       //sendToLTE(message);
....................          
....................       //write_eeprom(0, 3);
....................       //write_eeprom(1, 4);
....................       //fprintf(GSM, "ON\r");
....................       //delay_ms(3000);
....................       //fprintf(GSM, "OFF\r");
....................       //sendToLTE(message);
....................          
....................       //readSerial(); //Check message on address 1 inside inbox
.................... 
....................       if (InterruptUSB_Flag==1){              // if there is a character from USB, the interrupt will trigger            
05928:  BTFSS  40.0
0592A:  BRA    59CE
....................          ledConfig(LED_GREEN);
0592C:  MOVLW  01
0592E:  MOVLB  5
05930:  MOVWF  xA0
05932:  MOVLB  0
05934:  CALL   50B4
....................          
....................          InterruptUSB_Rxd[InterruptUSB_Counter-1]='\0';       
05938:  MOVLW  01
0593A:  SUBWF  41,W
0593C:  CLRF   03
0593E:  ADDLW  2C
05940:  MOVWF  FE9
05942:  MOVLW  00
05944:  ADDWFC 03,W
05946:  MOVWF  FEA
05948:  CLRF   FEF
....................          if (!stricmp(InterruptUSB_Rxd,dbg)){ // if data from USB = debug, it will go into debug mode.
0594A:  MOVLB  5
0594C:  CLRF   xA0
0594E:  MOVLW  2C
05950:  MOVWF  x9F
05952:  MOVLW  05
05954:  MOVWF  xA2
05956:  MOVLW  92
05958:  MOVWF  xA1
0595A:  MOVLB  0
0595C:  CALL   50E2
05960:  MOVF   01,F
05962:  BNZ   5984
....................             ledConfig(LED_GREEN);
05964:  MOVLW  01
05966:  MOVLB  5
05968:  MOVWF  xA0
0596A:  MOVLB  0
0596C:  CALL   50B4
....................             fprintf(USB,"DEBUG MODE");
05970:  MOVLW  F2
05972:  MOVWF  FF6
05974:  MOVLW  0E
05976:  MOVWF  FF7
05978:  MOVLW  00
0597A:  MOVWF  FF8
0597C:  CALL   0F40
....................             debugDetails();
05980:  BRA    5528
....................             //whilex=1;
....................             //debugMenu();
....................             //while(whilex==1){
....................             //if (debugDetails()){
....................                //whilex=0;
....................             //}   
....................          }
05982:  BRA    59C8
....................          
....................          else if (!stricmp(InterruptUSB_Rxd,reset )){ // if data from USB = debug, it will go into debug mode.
05984:  MOVLB  5
05986:  CLRF   xA0
05988:  MOVLW  2C
0598A:  MOVWF  x9F
0598C:  MOVLW  05
0598E:  MOVWF  xA2
05990:  MOVLW  98
05992:  MOVWF  xA1
05994:  MOVLB  0
05996:  CALL   50E2
0599A:  MOVF   01,F
0599C:  BNZ   59C8
....................             ledConfig(LED_GREEN);
0599E:  MOVLW  01
059A0:  MOVLB  5
059A2:  MOVWF  xA0
059A4:  MOVLB  0
059A6:  CALL   50B4
....................             fprintf(USB,"Reset MCU\n");
059AA:  MOVLW  FE
059AC:  MOVWF  FF6
059AE:  MOVLW  0E
059B0:  MOVWF  FF7
059B2:  MOVLW  00
059B4:  MOVWF  FF8
059B6:  CALL   0F40
....................             delay_ms(50);
059BA:  MOVLW  32
059BC:  MOVLB  6
059BE:  MOVWF  x6E
059C0:  MOVLB  0
059C2:  CALL   0F16
....................             reset_cpu();
059C6:  RESET
....................          }
....................          clear_InterruptUSB();
059C8:  CALL   1BF2
....................       }
059CC:  BRA    5A3E
....................         
....................       else{ //nothing happens in otherwords no interrupts  
....................       
....................       if (SAMPLINGFLAG == TRUE){        
059CE:  BTFSS  40.3
059D0:  BRA    59DE
....................          ledConfig(LED_GREEN);
059D2:  MOVLW  01
059D4:  MOVLB  5
059D6:  MOVWF  xA0
059D8:  MOVLB  0
059DA:  CALL   50B4
....................                
....................          //readRtc(0);
....................          //getMcuDateTime();
....................          //SAMPLINGFLAG = FALSE;
....................       }
....................             
....................       if (SYNCFLAG==TRUE){                      
059DE:  BTFSS  40.7
059E0:  BRA    5A04
....................          ledConfig(LED_GREEN);
059E2:  MOVLW  01
059E4:  MOVLB  5
059E6:  MOVWF  xA0
059E8:  MOVLB  0
059EA:  CALL   50B4
....................          fprintf(USB,"Time Sync\n");
059EE:  MOVLW  0A
059F0:  MOVWF  FF6
059F2:  MOVLW  0F
059F4:  MOVWF  FF7
059F6:  MOVLW  00
059F8:  MOVWF  FF8
059FA:  CALL   0F40
....................    
....................          rtc_acquire_sync();           // sync rtc datetime to both mcu and gsm 
059FE:  CALL   1B84
....................          SYNCFLAG = FALSE;             // two minutes before reaching the next hour, this will be activated      
05A02:  BCF    40.7
....................       }
....................                
....................       if (RESETFLAG==TRUE){                      
05A04:  MOVLB  4
05A06:  BTFSS  x8E.0
05A08:  BRA    5A1A
....................          ledConfig(LED_GREEN);
05A0A:  MOVLW  01
05A0C:  MOVLB  5
05A0E:  MOVWF  xA0
05A10:  MOVLB  0
05A12:  CALL   50B4
....................          //Thunder_Init();
....................          RESETFLAG=FALSE;
05A16:  MOVLB  4
05A18:  BCF    x8E.0
....................       }   
....................                
....................             
....................       ledToggle(LED_GREEN);
05A1A:  MOVLW  01
05A1C:  MOVLB  5
05A1E:  MOVWF  x9F
05A20:  MOVLB  0
05A22:  BRA    568C
....................       delay_ms(500);                   
05A24:  MOVLW  02
05A26:  MOVLB  5
05A28:  MOVWF  x9F
05A2A:  MOVLW  FA
05A2C:  MOVLB  6
05A2E:  MOVWF  x6E
05A30:  MOVLB  0
05A32:  CALL   0F16
05A36:  MOVLB  5
05A38:  DECFSZ x9F,F
05A3A:  BRA    5A2A
05A3C:  MOVLB  0
....................       }  
05A3E:  BRA    5916
....................    }
.................... }  
.................... 
05A40:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: 481D   VREGSLEEP INTRC_HP SOSC_HIGH NOXINST INTRC_IO NOPLLEN FCMEN NOIESO
   Word  2: 3E7E   PUT BROWNOUT BORV18 ZPBORM WDT_SW WDT32768
   Word  3: 8BF9   RTCOSC_T1 EXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
