
int1 dataPresent()
{
   int16 timeOut=0;
   
   while(!kbhit(RS485_WL450)&&++timeOut<50000)
   { delay_us(100); }
   if(!kbhit(RS485_WL450))
      return 0;
   else
      return 1;
}

int1 CalcCRC16B(char *SC_Buffer,int SC_Amount)
{
// locals
unsigned int16 Crc;
int n, m, x;
char CRC_H;
char CRC_L;
//int i;
/*
fprintf(PC,"\nBuffer: ");
for(i=0;i<SC_Amount;i++)
   {fprintf(PC,"%X ",SC_Buffer[i]);}
fprintf(PC,"\nAmount: %i",SC_Amount);
*/

// initialisation
Crc= 0xFFFF;
m= SC_Amount-2;
x= 0;
// loop over all bits
while(m>0)
   {//fprintf(PC,"\nBuff[%i]=%X",x,SC_Buffer[x]);
    Crc^= SC_Buffer[x];

    for(n=0; n<8; n++)
      {
       if(Crc&1)
         {
          Crc>>= 1;
          Crc^= 0xA001;
         }
       else
          Crc>>= 1;
      }
    m--; 
    x++;
   }
// result
CRC_H= (Crc>>8)&0xFF;
CRC_L= Crc&0xFF;

//fprintf(PC,"\nCRC_H: %X, CRC_L: %X",CRC_H,CRC_L);

if(CRC_H==SC_Buffer[SC_Amount-2]&&CRC_L==SC_Buffer[SC_Amount-1])
   {return TRUE;}
else
   {return FALSE;}
}// end CalcCRC16

void initWL450()
   {char cx[20];
    int i=0;
    int1 dp=0;
    int cntx = 0;
    
    char temp[5]={0xFA,0x30,0x04,0x43,0X00}; //F48: initialise

retx:
    delay_ms(100);
    
    i=0;
    
    output_high(EN_DE_WL450);
    output_high(EN_RE_WL450);
    fprintf(RS485_WL450, "%s",temp);
    output_low(EN_DE_WL450);
    output_low(EN_RE_WL450);
    
    dp = dataPresent();
    if (dp==0)
    {
      cntx++;
      if (cntx <= 3)
      {
         fprintf(PC,"retry INI...\n");
         goto retx;
      }         
      else
      {
         fprintf(PC,"ERR_INI...\n");
         return;
      }         
    }
    
    while(i<10)
      {cx[i]=fgetc(RS485_WL450);
       //if (cx[i]!= 0x00)
         i++;
      }
    /*
    fprintf(PC, "\nrcv: ");
    i=0;
    while(i<10)
      {fprintf(PC,"%X ",cx[i]);
       i++;
      }
    */
    
    cx[i]=0x00;
/*    
    fprintf(PC,"-------------\n");
    for(xx=0;xx<=i;xx++)
      fprintf(PC,"%x ",cx[xx]);
    fprintf(PC,"-------------\n");
*/    
    if(CalcCRC16B(cx,10))
     {fprintf(PC,"WL450 INITIALISED\n");}
    else
     {fprintf(PC,"WL450 NOT INITIALISED!\n");}   
  }

void readWL450Pressure()
   {char cx[20];
    
   // char temp[6]={0xFA,0x73,0x01,0x01,0XB5,0X00}; //read value float
    char temp[6]={0xFA,0x4A,0x01,0x51,0XA7,0X00}; //read value integer
    //char temp[9]={0xFA,0x03,0x00,0x11,0x00,0x01,0x84,0xC1,0X00}; //read value float
    unsigned int32 pressure; 
    
    
retx:
    int1 dp=0;
    int cntx = 0;
    int i=0;
    
    delay_ms(100);
    /*
    if(CalcCRC16B(temp,5))
     {fprintf(PC,"\nCRC VALID!");}
    else
     {fprintf(PC,"\nCRC ERROR!");}
    */
    output_high(EN_DE_WL450);
    output_high(EN_RE_WL450);
    fprintf(RS485_WL450, "%s",temp);
    output_low(EN_RE_WL450);
    output_low(EN_DE_WL450);
    
    dp = dataPresent();
    if (dp==0)
    {
      cntx++;
      if (cntx <= 3)
      {
         fprintf(PC,"retry PRESS...\n");
         goto retx;
      }
      else
      {
         strcpy(funcReturnVar,"0.0");
         return;
      }         
    }  
    while(i<9)
      {cx[i]=fgetc(RS485_WL450);
         {i++;}
      }
    cx[i]=0x00;
    /*
    fprintf(PC, "\nrcv: ");
    i=0;
    while(i<9)
      {fprintf(PC,"%X ",cx[i]);
       i++;
      }
    */
    if(CalcCRC16B(cx,9))
    { fprintf(PC,"\nPRESSURE DATA VALID!");
      pressure=make32(cx[2],cx[3],cx[4],cx[5]);
      fprintf(PC,"\nPressure: %lu",pressure);
    }
    else
     {//fprintf(PC,"\nPRESSURE DATA ERROR!");
      if (cntx++ <= 3)
      {
         fprintf(PC,"retry PRESS...\n");
         delay_ms(1000);
         goto retx;
      }
      else
         pressure =0;
         
     }
     if (pressure > 5000)
      pressure = 0;
     
     itoa(pressure,10,funcReturnVar);
    
  }
  
void readWL450Temp()
   {char cx[20];
    char temp[6]={0xFA,0x4A,0x04,0x52,0X67,0X00}; //read value integer
    
retx:
   float tempf=0;
    int1 dp=0;
    int cntx=0;
    int i=0;
    unsigned int32 temp32=0;

    delay_ms(100);
    /*
    if(CalcCRC16B(temp,5))
     {fprintf(PC,"\nCRC VALID!");}
    else
     {fprintf(PC,"\nCRC ERROR!");}
    */
    output_high(EN_DE_WL450);
    output_high(EN_RE_WL450);
    fprintf(RS485_WL450, "%s",temp);
    output_low(EN_RE_WL450);
    output_low(EN_DE_WL450);
    
    dp = dataPresent();
    if (dp==0)
    {
      cntx++;
      if (cntx <= 3)
      {
         fprintf(PC,"retry TEMP...\n");
         goto retx;
      }
      else
      {
         strcpy(funcReturnVar,"0.0");
         return;
      }         
    }  
    while(i<9)
      {cx[i]=fgetc(RS485_WL450);
         {i++;}
      }
    
    cx[i]=0x00;
    if(CalcCRC16B(cx,9))
     {fprintf(PC,"\nTEMPERATURE DATA VALID!");
      temp32=make32(cx[2],cx[3],cx[4],cx[5]);
      tempf=temp32*0.01;
      fprintf(PC,"\nTemperature: %f",tempf);
     }
    else
     {//fprintf(PC,"\nTEMPERATURE DATA ERROR!");
      if (cntx++ <= 3)
      {
         fprintf(PC,"retry TEMP...\n");
         delay_ms(1000);
         goto retx;
      }
      else
         tempf= 0;
     }
     sprintf(funcReturnVar,"%2.2f",tempf);
    
  }  
