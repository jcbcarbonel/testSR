#include <18F67K22.h>
#device adc=12
#device PASS_STRINGS = IN_RAM

#FUSES WDT_SW, WDT32768, INTRC_IO, NOPROTECT, NOIESO, BROWNOUT, PUT, NOCPD, STVREN, NODEBUG, NOWRT, NOWRTD, NOEBTR, NOCPB, NOEBTRB, NOWRTC, NOWRTB, FCMEN, NOXINST, MCLR, RTCOSC_T1
#use delay(clock=16000000)

#use rs232(baud=57600, xmit=PIN_G1, rcv=PIN_G2, stream=PC)
#use rs232 (baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=SERIAL_INT)
//#include "bootloader.h"

#include <math.h>
#include <stdlib.h>
#include <string.h>


#define INTERNAL_LED_STAT

#case

#define BUFFER_SIZE      255
#define GETBOOSTVOLTAGE
#define URBAN
#define GPRS

unsigned char const FIRMWARE[] = {"v.2.8"};

char SENSORTYPE=NULL;
char SERVERNUMBER[15]={};
char SERVERIP[15]={};
char funcReturnVar[BUFFER_SIZE]={};
char FROMSERIALPC[25]={};
char REALDATA[BUFFER_SIZE];

#include <sensors/camera.h>
#include <sensors/camera.c>

void cameraTest()
{
   int ii=0;
   int16 cnz = 0;
   int zzz=0;
   char c;
   //char msgx[]
   
resetx:
   
   fprintf(PC,"REading frm camera..\n");

   restart_wdt();   
   
   //strcpy(VAISALA_STREAM,"");
   delay_ms(45);

   fprintf(PC,"iii=%i\n",ii);
   fprintf(CAMERA,"%c%c%c%c",0x56,0x00,0x26,0x00);
   delay_ms(10);
   do
   {
      while(!kbhit(CAMERA))
      {
         cnz++;
         if (cnz >= 40000)
         {
            zzz++;
            //output_high(SENSOR_PIN);
            delay_ms(300);
            //output_low(SENSOR_PIN);
            cnz =0;
            if (zzz>=5)
            {
               fprintf(PC,"ii=%i\n",ii);
               return;
            }
            goto resetx;
         }
      }
      c = fgetc(CAMERA);
      fprintf(PC,"%c",c);
      ii++;
   }while (c!='R');
   fprintf(PC,"%x",c);
   fprintf(PC,"ii=%i\n",ii);
   //VAISALA_STREAM[ii-1] = '\0';
   //return ii;
}

/*
void camera_reset()
{
   char response[30];
   int cnt=0;
   
   cnt = sendCommand(RESET_CAMERA, response, 4);
   if (cnt > 4)
      fprintf(PC,"Camera Initialize");
   else
      err(0);
}

void power_saving()
{
   char response[30];
   int cnt=0;
   
   cnt = sendCommand(POWER_SAVING, response, 7);
   if (cnt > 4)
      fprintf(PC,"power saving..");
   else
      err(1);
}



void compression()
{
   char response[30];
   int cnt=0;
   
   cnt = sendCommand(COMPRESSION, response, 9);
   if (cnt > 4)
      fprintf(PC,"compression..");
   else
      err(1);
}
*/

unsigned int16 getPicSize()
{
  char *response;
  int cnt=0;
  int msb=0;
  int lsb=0;
  int16 size=0;
  int i=0;
  //char response[9]={};
  //Send the GET_SIZE command string to the camera
/*  
  for (i=0;i<5;i++)
      fprintf(CAMERA,"%c",GET_SIZE[i]);
  while(kbhit(CAMERA)
  {
   
   for(i=0;i<7;i++)
   fgetc(CAMERA);
*/   
  msb = fgetc(CAMERA);
  lsb = fgetc(CAMERA);
  size=make16(msb,lsb);
  fprintf(PC,"%lu",size);
  return size;
}
   
void checkoutput(int mode, int cnt, char *response)
{
   int i=0;
/*   
   fprintf(PC,"\n");
   for (i=0;i<cnt;i++)
      fprintf(PC,"%x ",*response++);
   fprintf(PC,"\n");
*/   
   if (cnt > 4)
   {
      if (mode==0)
         fprintf(PC,"Camera Initialize..\n");
      else if (mode==1)
         fprintf(PC,"power saving..\n");
      else if (mode==2)
         fprintf(PC,"picture size set..\n");         
      else if (mode==3)
         fprintf(PC,"compression set..\n");         
      else if (mode==4)
         fprintf(PC,"picture taken..\n");            
      else if (mode==5)
         fprintf(PC,"file size retrieved..\n");            
   }  
   else
      fprintf(PC,"err: %i\n",mode);
}

void chPictureSize(int size)
{
  switch(size) {
  case 0: // 160x120
    CHANGE_PICT_SIZE[4] = 0x22;
    break;
  case 1: // 320x240
    CHANGE_PICT_SIZE[4] = 0x11;
    break;
  case 2: // 640x480
    CHANGE_PICT_SIZE[4] = 0x00;
    break;
  default: //Everything else -> 320x240
    CHANGE_PICT_SIZE[4] = 0x11;
  }
}



int readData_(unsigned int16 size)
{
  unsigned long count=0;
  int buf[32]; // Buffer to hold the current chunk of the picture
  int flag=0;
  int i,j;

  int16   address=0;
  #byte   address_L=address;
  #byte   address_H=address+1;


  //Flush out any data currently in the serial buffer
  //while (kbhit(CAMERA)) 
  // fgetc(CAMERA);
   
  while (flag!=3) {
    
    //Send the command to get JPEGCAM_READ_SIZE bytes of data from the current address
    
    if (address > size)
    {  
      fprintf(PC,"error..\n");
      return;
    }      
    for(i=0; i<8; i++)
      fprintf(CAMERA,"%c",READ_DATA[i]);
   
    
    fprintf(CAMERA,"%c%c%c%c%c%c%c%c",address_H,address_L,0x00,0x00,0x00,0x20,0x00,0x0A);
    address += 32;

    //delay_ms(55);

    //Discard the response header.
    while(!kbhit(CAMERA));
    for(i=0; i<5; i++)
      fgetc(CAMERA);

    //Now read the actual data
    i=0;
    for (i=0;(i<32) && (flag!=3);i++) {
      count ++;
      while (!kbhit(CAMERA));
      buf[i]=fgetc(CAMERA);
      if (buf[i] == 0xFF) 
      {
         flag |= 1;
      }         
      else if ((buf[i] == 0xD9) && (flag == 1))
      {
         flag |= 2;
      }         
      else flag = 0;
    }

    // Discard the footer
    //while (kbhit(CAMERA)) 
    //  fgetc(CAMERA);
    for (j=0;j<i;j++) 
      fprintf(PC,"%x ",buf[j]);
  }
   delay_ms(25);
  //Return the number of bytes
  return count;
}


int sendCommand(char *command, char  *response, int length)
{
   int i;
   char c;
   int zzz=0;
   int16 cnz=0;
   //Clear any data currently in the serial buffer
   //while(kbhit(CAMERA)) 
    //  fgetc(CAMERA);
   char xx[20]={};
//resetx:  
   int ii=0;
   int cntx=0;
   //Send each character in the command string to the camera through the camera serial port
   for (i=0;i<length;i++)
      fprintf(CAMERA,"%c",command[i]);
   do
   {
      while(!kbhit(CAMERA))
      {
         delay_us(10);
         cnz++;
         if (cnz >= 65000)
         {
            zzz++;
            delay_ms(300);
            cnz =0;
            fprintf(PC,"\n");
            for (i=0;i<ii;i++)
               fprintf(PC,"%x ",xx[i]);
            fprintf(PC,"\n");
            
            return ii;
         }
      }
      c = fgetc(CAMERA);
      fprintf(PC,"%c",c);
      xx[ii++] = c;
      cntx++;
//      if (cntx > 250)
//         return 0;
   }while (1);
  return ii;
}

void main(){
   char *response;
   int i=0;
   int ii=0;
   int cnt=0;
   delay_ms(2000); 
   
   int16 size = 0;
   
   
   //void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue)
   fprintf(PC,"starthere...\n");
   cnt = sendCommand(RESET_CAMERA, response, 4);
   checkoutput(0, cnt, response);
   
   cnt=sendCommand(POWER_SAVING, response, 7);
   checkoutput(1, cnt, response);
   
   chPictureSize(1);
   cnt=sendCommand(CHANGE_PICT_SIZE, response, 5);
   checkoutput(2, cnt,response);
   
   cnt=sendCommand(COMPRESSION, response, 9);
   checkoutput(3,cnt,response);
   
   cnt=sendCommand(TAKE_PICTURE, response, 5);
   checkoutput(4,cnt,response);
   delay_ms(1000);
   size = getPicSize();
   
   readData_(size);
   fprintf(PC,"end...\n");
   do{
                  
   }while(1);
}

