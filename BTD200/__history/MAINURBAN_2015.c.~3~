/*    04/17/2015 -- tested power saving features
                        - sleep mode if it reaches 3.4
                        - using 38k and 2.2k as divider resistors, reading has 0.03v difference from actual
                 -- arranged eeprom data holders
                 -- incorporated power board config option
                        - two digit that represents boost voltage of both power boards
                        - 0 (boost is turned off permanently)
                        - 1 (boost is turned on permanently)
                        - 2 (boost is turned on only during acquisition time)

      04/21/2015 -- port_d_pullups for 18f87k22 uses a single control bit to pull_up all the pins. it cant control the pins individually
                 -- 10k resistors on R11 and R16 should be placed
                 -- without these pull-up resistors, the RTC chip will not function
                 -- modified ReadEE() to terminate string by placing \0 at the end of the alloted length in case it cant find *
                 -- change pin assignment of SCP_CSB since it is incorrect
*/

#include <18F87K22.h>
#device adc=12
#device PASS_STRINGS = IN_RAM

#FUSES WDT_SW, WDT32768, INTRC_IO, SOSC_HIGH, NOPROTECT, NOIESO, BROWNOUT, PUT, NOCPD, STVREN, NODEBUG, NOWRT, NOWRTD, NOEBTR, NOCPB, NOEBTRB, NOWRTC, NOWRTB, FCMEN, NOXINST, MCLR, RTCOSC_T1
#use delay(clock=16000000)

#use rs232(baud=57600, xmit=PIN_G1, rcv=PIN_G2, stream=PC)
#use rs232(baud=19200, xmit=PIN_C6, rcv=PIN_C7, stream=SERIAL_INT)
#use i2c(MASTER, sda=PIN_D5, scl=PIN_D6)
//#include "bootloader.h"

#include <math.h>
#include <stdlib.h>
#include <string.h>


#define INTERNAL_LED_STAT

#case

#define BUFFER_SIZE      255

unsigned char const FIRMWARE[] = {"arq.3.0"};

char SENSORTYPE=NULL;
char SERVERNUMBER[15]={};
char SERVERIP[15]={};
char funcReturnVar[BUFFER_SIZE]={};
char FROMSERIALPC[25]={};
char REALDATA[BUFFER_SIZE];
char SMALLvar[10]={};

#include <headers.c>
#include <rtc.c>
#include <pinDefinitions.c>
#include <dualcolorLED.c>
#include <eeprom_.c>
#include <voltageDetails.c>
#include <gsm.c>
#include <generic.c>
#include <interrupSerial.c>
#include <interruptSerial2.c>
#include <flashmem_spi.c>
#include <dateTimeDetails.c>
#include <satellite.c>
#include <handleUnsent.c>
#include <gprs.c>
#include <debugMode.c>
#include <powerSaving.c>
#include <usingAstiConfigTool.c>
#include <firmware2flash.c>
#include <interruptTimer1.c>
#include <sensors/shtTempHum.c>
#include <sensors/vaisalaWXT520.c>
#include <sensors/waterSenix.c>
#include <sensors/pressure_scp.c>
#include <sensors/rainTipping.c>
#include <sensors/sunshineDuration.c>
#include <sensors/rs485.c>
#include <sensors/hmp155.c>
#include <sensors/smp3_A.c>
#include <sensors/ptb330.c>
#include <sensors/maxbotix.c>
#include <sensors/WL450.c>
//#include <sensors/senslope.c>

void dateTimeStatus()
{
   char strx[25]={};
   char *ptr;
   char year_[3]={};
   char month_[3]={};
   char day_[3]={};
   char hour_[3]={};
   char min_[3]={};
   char sec_[3]={};
   int cntx=0;

   strcpy(TOKEN,"/,:");
   
   GetDateTime();
   strcpy(strx,funcReturnVar);
   ptr=strtok(strx,TOKEN);
   strcpy(year_,ptr);
   while(ptr!=0)
   {
      ptr = strtok(0,TOKEN);
      cntx++;
      if (cntx==1)
         strcpy(month_,ptr);
      if (cntx==2)
         strcpy(day_,ptr); 
      if (cntx==3)
         strcpy(hour_,ptr);
      if (cntx==4)
         strcpy(min_,ptr);
      if (cntx==5)
         strcpy(sec_,ptr);
   }
   sprintf(funcReturnVar,"%s%s%s/%s%s%s",year_,month_,day_,hour_,min_,sec_);
   //fprintf(PC,"date___=%s\n",funcReturnVar);
}


void rainUrbanFormat()
{
   char cntx_[4]={};
   char cumx_[4]={};
   
   GetRainCount_TIPPING();
   strcpy(cntx_,funcReturnVar);
   RainCum_TIPPING_func();
   strcpy(cumx_,funcReturnVar);
   
   sprintf(funcReturnVar,"PN1A:%s,%s",cntx_,cumx_);
}


void sensorPoll()
{
   char charx='+';
   
   //IMEI:test+GW1A:104,31.33+PN1A:0,33:H1:33.3,75.7,21,4.1S,1.15,0.00,1901,140928/200622
   powerBoostConfig(1);
   delay_ms(100);
   
   if(!stricmp(SENSORCONFIG,"WL")) // water level
   {
      getDistance();
      strcpy(REALDATA,funcReturnVar);
      strncat(REALDATA,&charx,1);
   }
   else if (!stricmp(SENSORCONFIG,"RG")) // rain gauge
   {
      getRainFullwithPressure();
      strcpy(REALDATA,funcReturnVar);
      strncat(REALDATA,&charx,1);
   }
   else if (!stricmp(SENSORCONFIG,"TM")) // tandem
   {
      getDistance();
      strcpy(REALDATA,funcReturnVar);
      strncat(REALDATA,&charx,1);
      getRainFullwithPressure();
      strcat(REALDATA,funcReturnVar);
      strncat(REALDATA,&charx,1);
   }
   else if (!stricmp(SENSORCONFIG, "SS"))
   {
   
   }
   else
      strcpy(REALDATA,"no_sensor+");
   
   logger_health_status();
   strcat(REALDATA,funcReturnVar);
   strncat(REALDATA,&charx,1);
   dateTimeStatus();
   strcat(REALDATA,funcReturnVar);
   fprintf(PC,"*+%s\n",REALDATA);
   powerBoostConfig(0);
}


void header()
{
   fprintf(PC,"ADVANCED SCIENCE AND TECHNOLOGY INSTITUTE\n");
   fprintf(PC,"EMBEDDED SYSTEMS TECHNOLOGIES\n");
   fprintf(PC,"ARQ FIRMWARE v.3.0 2015\n");
}



void SensorInitialize()
{
   //disableBOOST1(); 
   powerBoostConfig(0);
   RAINCOUNT_TIPPING=0;
   clearRainCumVars();      
}

void setInitialValues()
{
   char strx[20]={};
   char forDeploy;
   char tempChar;
   // -- > default users
   
   readDataEEprom(EEPROM_SENDING_TIME);
   strcpy(strx,funcReturnVar);
   SENDING_TIME = atoi(strx);
   fprintf(PC,"sending=%i\n",SENDING_TIME);
   
   readDataEEprom(EEPROM_SERVER_NUMBER);
   strcpy(SERVERNUMBER,funcReturnVar);
   fprintf(PC,"server no.=%s\n",SERVERNUMBER);
   
   readDataEEprom(EEPROM_PASSWORD);
   strcpy(strx,funcReturnVar);
   fprintf(PC,"password=%s\n",strx);
   
   readDataEEprom(EEPROM_SENSOR_TYPE);
   strcpy(SENSORCONFIG,funcReturnVar);
   fprintf(PC,"sensorconfig=%s\n",SENSORCONFIG);
   
   readDataEEprom(EEPROM_PBOARD_CONFIG);
   strcpy(PBOARDCONFIG,funcReturnVar);
   
   //BATTERYUSED = readCharEE(346);
   BATTERYUSED=0;
   fprintf(PC,"battery=%i\n",BATTERYUSED);
   
   readDataEEprom(EEPROM_SERVER_IP);
   strcpy(SERVERIP,funcReturnVar); // get server ip
   fprintf(PC,"serverip=%s\n",SERVERIP);
   
   readCharEE(EEPROM_SATELLITE_STATUS, tempChar);
   
   readCharEE(EEPROM_DEPLOY_STATUS, forDeploy);  // for deploy
   if (forDeploy=='Y')
   {
      fprintf(PC,"findEndChar..\n");
      findEndChar();
   }   
   else
      fprintf(PC,"TESTING MODE..\n");
}

void mcuStatusOnStartUp()
{
   char strx[20] = {};
   char *msgP1=NULL;
   
   switch ( restart_cause() )
   {
      case WDT_TIMEOUT:
      {
         strcpy(DESIRED_RESPONSE, "+CCLK: ");
         clear_buffer();
         fprintf(SERIAL_INT,"AT+CCLK?\r");
         delay_ms(200);
         msgP1 = GetResponse();
         if (msgP1)
            strcpy(strx,"WATCHDOG TIMEOUT");
         break;
      }
      
      case NORMAL_POWER_UP:
      {
         strcpy(strx,"NORMAL POWER UP!");
         break;
      }
      
      case RESET_INSTRUCTION:
      {
         readDataEEprom(EEPROM_RESET_NUMBER);
         strcpy(strx, "SMS RESET by ");
         strcat(strx, funcReturnVar);
         break;
      }
      default:
      {
         strcpy(strx,"MANUAL RESET");
      }
   }
   clear_buffer();
   delay_ms(200);
   fprintf(PC,"%s\n",strx);
   fprintf(SERIAL_INT,"%s\n",strx);
   strcpy(SMS_TOBE_SENT,strx);
   SendSMS(SERVERNUMBER);   
}

void main(){
   int1 unsentCnt=0;
   int1 whilex=0;
   //int1 statGprs=0;
   
   delay_ms(2000);
   bootloadFlag();
   
   disableBatteryControl();  // select higher voltage
   
   //port_d_pullups(01100000); // pull-ups on sda_i2c and scl_i2c
   setup_adc(ADC_CLOCK_DIV_16);
   setup_adc_ports(sAN0 | sAN4 | sAN5 | sAN7 | sAN8 | sAN12 | sAN13 | sAN14 | sAN15); 
   
   setup_timer_1(T1_EXTERNAL|T1_DIV_BY_1|T1_ENABLE_SOSC); //no T1_CLK_OUT
   setup_spi(SPI_MASTER|SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_64);
   
   
   setup_wdt(WDT_ON);
   enable_interrupts(INT_TIMER1);
   enable_interrupts(INT_RDA);
   enable_interrupts(INT_RDA2);
   enable_interrupts(INT_EXT); //B0
   enable_interrupts(INT_EXT1); //RING OUT
   enable_interrupts(GLOBAL);
   //enable_interrupts(INT_EXT3); //B3
   
   ext_int_edge(0,L_TO_H);
   //ext_int_edge(3,L_TO_H);
   
   ledConfig(LED_GREEN);
   header();
   
   
   //----------------- REGISTER DEFAULT NUMBERS
   AddDataEEprom("09334556445",1);
   AddDataEEprom("09178747367",1);
   //AddDataEEprom("202.90.158.12",6);
   
   //----------------- GSM INITIALIZATION
   InitGSM();
   InitICP(0);
   rtc_acquire_sync();
   clear_buffer();
   clear_inputs(); //delete messages from inbox
   
   sht_init(); // initialize sht module
   DTFOpen();   // initialize flash
   SetSizeFT();
   setInitialValues(); // initialize config settings
   SensorInitialize();
   mcuStatusOnStartUp();
   
//-----------------    
   delay_ms(500);
   SAMPLINGFLAG=0;
   do{
      restart_wdt();
      whilex=0;
      if (INTSERIAL2_FLAG==1)
      {
         delay_ms(200);
         RXD2_DATA[WRITE2_CNTR-1]='\0';
         if (!stricmp(RXD2_DATA,"debug"))
         {
            clear_buffer2();
            whilex=1;
            debugMenu();
            while(whilex==1)
            {
               if (debugDetails())
                  whilex=0;
            }
         }
         clear_buffer2();
      }
      else
      {
         selectPowerSource();
         delay_ms(500);
         if (EXT_FLAG==1)
         {
            clear_buffer();
            strcpy(RXD_DATA,SMS_RCV);
            WRITE_CNTR = strlen(RXD_DATA);
            proc_receive();
            delay_ms(200);
            EXT_FLAG=0;
         }
         if (TESTFLAG==TRUE)
         {
//            if (DEBUGMODE != NO_USB)
//               PowerSavingIdentify(); // power saving check
            compareSourceVoltages(1); // just to display voltages of primary and secondary batteries
            if (POWERSAVING != 1)
            {
               if(!testGSM())
               {
                  ledConfig(LED_OFF);
                  InitGSM();
               }
            }
            
            TESTFLAG=FALSE;
         }
         
         if (POWERSAVING != 1)
         {
            ledToggle();
            if (SYNCFLAG==TRUE)
            {
               
               {
                  fprintf(PC,"Time Sync\n");
                  SYNCFLAG = FALSE;
                  rtc_acquire_sync();
               }
            }
            
            if (SUNSHINE_RESET_FLAG==TRUE)
            {
               SUNSHINE_RESET_FLAG=FALSE;
               sunshineReset();
            }
            
            
            if (SAMPLINGFLAG == TRUE)
            {
               ledConfig(LED_GREEN);
               counterNewYear();
               SAMPLINGFLAG = FALSE;
               
               if (unsentCnt != 0) //check if there are failed messages
               {
                  unsentCnt = findUnsentAndSend(0, unsentDTFByteCnt, unsentDTFPageCnt);
               }
               clear_buffer();
               delay_ms(200);
               
               sensorPoll();
               if (stricmp(SENDING_MODE,"GPRS")>0)
               {
                  strcpy(SMS_TOBE_SENT, REALDATA);
                  if (!AttemptToSend())
                  {
                     if (unsentCnt!=1)
                     {
                        unsentCnt=1;
                        unsentDTFPageCnt=DTFPageCnt;
                        unsentDTFByteCnt=DTFByteCnt;
                     }                  
                     fprintf(PC,"MESSAGE SENT FAILED\n");
                     //satelliteSend();   ----> to be removed
                  }
               }
               else
               {
                  
               }
               if (GPRS_FIRMWARE_STATUS != 1)
                  DTFWriteToFlash(SMS_TOBE_SENT,strlen(SMS_TOBE_SENT),0);
            }
            if (RESETFLAG==TRUE)
            {
               RESETFLAG=FALSE;
               clearRainCumVars();
            }
         }
         else
            ledConfig(LED_OFF);
      }         
   }while(1);
}

